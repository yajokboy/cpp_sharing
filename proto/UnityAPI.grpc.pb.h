// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: UnityAPI.proto
// Original file comments:
// Copyright 2015 gRPC authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
#ifndef GRPC_UnityAPI_2eproto__INCLUDED
#define GRPC_UnityAPI_2eproto__INCLUDED

#include "UnityAPI.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace UnityAPI {

// The greeting service definition.
class UnityAPIService final {
 public:
  static constexpr char const* service_full_name() {
    return "UnityAPI.UnityAPIService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status FrontLowLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLowLightRequest& request, ::UnityAPI::FrontLowLightReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontLowLightReply>> AsyncFrontLowLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLowLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontLowLightReply>>(AsyncFrontLowLightControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontLowLightReply>> PrepareAsyncFrontLowLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLowLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontLowLightReply>>(PrepareAsyncFrontLowLightControlRaw(context, request, cq));
    }
    virtual ::grpc::Status FrontHighLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontHighLightRequest& request, ::UnityAPI::FrontHighLightReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontHighLightReply>> AsyncFrontHighLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontHighLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontHighLightReply>>(AsyncFrontHighLightControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontHighLightReply>> PrepareAsyncFrontHighLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontHighLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontHighLightReply>>(PrepareAsyncFrontHighLightControlRaw(context, request, cq));
    }
    virtual ::grpc::Status RearLightControl(::grpc::ClientContext* context, const ::UnityAPI::RearLightRequest& request, ::UnityAPI::RearLightReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearLightReply>> AsyncRearLightControl(::grpc::ClientContext* context, const ::UnityAPI::RearLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearLightReply>>(AsyncRearLightControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearLightReply>> PrepareAsyncRearLightControl(::grpc::ClientContext* context, const ::UnityAPI::RearLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearLightReply>>(PrepareAsyncRearLightControlRaw(context, request, cq));
    }
    virtual ::grpc::Status FrontDaytimeLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontDaytimeLightRequest& request, ::UnityAPI::FrontDaytimeLightReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontDaytimeLightReply>> AsyncFrontDaytimeLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontDaytimeLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontDaytimeLightReply>>(AsyncFrontDaytimeLightControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontDaytimeLightReply>> PrepareAsyncFrontDaytimeLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontDaytimeLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontDaytimeLightReply>>(PrepareAsyncFrontDaytimeLightControlRaw(context, request, cq));
    }
    virtual ::grpc::Status BrakeLightControl(::grpc::ClientContext* context, const ::UnityAPI::BrakeLightRequest& request, ::UnityAPI::BrakeLightReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::BrakeLightReply>> AsyncBrakeLightControl(::grpc::ClientContext* context, const ::UnityAPI::BrakeLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::BrakeLightReply>>(AsyncBrakeLightControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::BrakeLightReply>> PrepareAsyncBrakeLightControl(::grpc::ClientContext* context, const ::UnityAPI::BrakeLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::BrakeLightReply>>(PrepareAsyncBrakeLightControlRaw(context, request, cq));
    }
    virtual ::grpc::Status ReverseLightControl(::grpc::ClientContext* context, const ::UnityAPI::ReverseLightRequest& request, ::UnityAPI::ReverseLightReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::ReverseLightReply>> AsyncReverseLightControl(::grpc::ClientContext* context, const ::UnityAPI::ReverseLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::ReverseLightReply>>(AsyncReverseLightControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::ReverseLightReply>> PrepareAsyncReverseLightControl(::grpc::ClientContext* context, const ::UnityAPI::ReverseLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::ReverseLightReply>>(PrepareAsyncReverseLightControlRaw(context, request, cq));
    }
    virtual ::grpc::Status FrontFogLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontFogLightRequest& request, ::UnityAPI::FrontFogLightReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontFogLightReply>> AsyncFrontFogLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontFogLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontFogLightReply>>(AsyncFrontFogLightControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontFogLightReply>> PrepareAsyncFrontFogLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontFogLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontFogLightReply>>(PrepareAsyncFrontFogLightControlRaw(context, request, cq));
    }
    virtual ::grpc::Status RearFogLightControl(::grpc::ClientContext* context, const ::UnityAPI::RearFogLightRequest& request, ::UnityAPI::RearFogLightReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearFogLightReply>> AsyncRearFogLightControl(::grpc::ClientContext* context, const ::UnityAPI::RearFogLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearFogLightReply>>(AsyncRearFogLightControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearFogLightReply>> PrepareAsyncRearFogLightControl(::grpc::ClientContext* context, const ::UnityAPI::RearFogLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearFogLightReply>>(PrepareAsyncRearFogLightControlRaw(context, request, cq));
    }
    virtual ::grpc::Status ClearanceLampControl(::grpc::ClientContext* context, const ::UnityAPI::ClearanceLampRequest& request, ::UnityAPI::ClearanceLampReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::ClearanceLampReply>> AsyncClearanceLampControl(::grpc::ClientContext* context, const ::UnityAPI::ClearanceLampRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::ClearanceLampReply>>(AsyncClearanceLampControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::ClearanceLampReply>> PrepareAsyncClearanceLampControl(::grpc::ClientContext* context, const ::UnityAPI::ClearanceLampRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::ClearanceLampReply>>(PrepareAsyncClearanceLampControlRaw(context, request, cq));
    }
    virtual ::grpc::Status FrontLeftBlinkerLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftBlinkerLightRequest& request, ::UnityAPI::FrontLeftBlinkerLightReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontLeftBlinkerLightReply>> AsyncFrontLeftBlinkerLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftBlinkerLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontLeftBlinkerLightReply>>(AsyncFrontLeftBlinkerLightControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontLeftBlinkerLightReply>> PrepareAsyncFrontLeftBlinkerLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftBlinkerLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontLeftBlinkerLightReply>>(PrepareAsyncFrontLeftBlinkerLightControlRaw(context, request, cq));
    }
    virtual ::grpc::Status FrontRightBlinkerLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightBlinkerLightRequest& request, ::UnityAPI::FrontRightBlinkerLightReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontRightBlinkerLightReply>> AsyncFrontRightBlinkerLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightBlinkerLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontRightBlinkerLightReply>>(AsyncFrontRightBlinkerLightControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontRightBlinkerLightReply>> PrepareAsyncFrontRightBlinkerLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightBlinkerLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontRightBlinkerLightReply>>(PrepareAsyncFrontRightBlinkerLightControlRaw(context, request, cq));
    }
    virtual ::grpc::Status RearLeftBlinkerLightControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftBlinkerLightRequest& request, ::UnityAPI::RearLeftBlinkerLightReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearLeftBlinkerLightReply>> AsyncRearLeftBlinkerLightControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftBlinkerLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearLeftBlinkerLightReply>>(AsyncRearLeftBlinkerLightControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearLeftBlinkerLightReply>> PrepareAsyncRearLeftBlinkerLightControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftBlinkerLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearLeftBlinkerLightReply>>(PrepareAsyncRearLeftBlinkerLightControlRaw(context, request, cq));
    }
    virtual ::grpc::Status RearRightBlinkerLightControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightBlinkerLightRequest& request, ::UnityAPI::RearRightBlinkerLightReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearRightBlinkerLightReply>> AsyncRearRightBlinkerLightControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightBlinkerLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearRightBlinkerLightReply>>(AsyncRearRightBlinkerLightControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearRightBlinkerLightReply>> PrepareAsyncRearRightBlinkerLightControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightBlinkerLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearRightBlinkerLightReply>>(PrepareAsyncRearRightBlinkerLightControlRaw(context, request, cq));
    }
    virtual ::grpc::Status FrontWiperControl(::grpc::ClientContext* context, const ::UnityAPI::FrontWiperRequest& request, ::UnityAPI::FrontWiperReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontWiperReply>> AsyncFrontWiperControl(::grpc::ClientContext* context, const ::UnityAPI::FrontWiperRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontWiperReply>>(AsyncFrontWiperControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontWiperReply>> PrepareAsyncFrontWiperControl(::grpc::ClientContext* context, const ::UnityAPI::FrontWiperRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontWiperReply>>(PrepareAsyncFrontWiperControlRaw(context, request, cq));
    }
    virtual ::grpc::Status RearWiperControl(::grpc::ClientContext* context, const ::UnityAPI::RearWiperRequest& request, ::UnityAPI::RearWiperReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearWiperReply>> AsyncRearWiperControl(::grpc::ClientContext* context, const ::UnityAPI::RearWiperRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearWiperReply>>(AsyncRearWiperControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearWiperReply>> PrepareAsyncRearWiperControl(::grpc::ClientContext* context, const ::UnityAPI::RearWiperRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearWiperReply>>(PrepareAsyncRearWiperControlRaw(context, request, cq));
    }
    virtual ::grpc::Status LeftSideMirrorControl(::grpc::ClientContext* context, const ::UnityAPI::LeftSideMirrorRequest& request, ::UnityAPI::LeftSideMirrorReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::LeftSideMirrorReply>> AsyncLeftSideMirrorControl(::grpc::ClientContext* context, const ::UnityAPI::LeftSideMirrorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::LeftSideMirrorReply>>(AsyncLeftSideMirrorControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::LeftSideMirrorReply>> PrepareAsyncLeftSideMirrorControl(::grpc::ClientContext* context, const ::UnityAPI::LeftSideMirrorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::LeftSideMirrorReply>>(PrepareAsyncLeftSideMirrorControlRaw(context, request, cq));
    }
    virtual ::grpc::Status RightSideMirrorControl(::grpc::ClientContext* context, const ::UnityAPI::RightSideMirrorRequest& request, ::UnityAPI::RightSideMirrorReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RightSideMirrorReply>> AsyncRightSideMirrorControl(::grpc::ClientContext* context, const ::UnityAPI::RightSideMirrorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RightSideMirrorReply>>(AsyncRightSideMirrorControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RightSideMirrorReply>> PrepareAsyncRightSideMirrorControl(::grpc::ClientContext* context, const ::UnityAPI::RightSideMirrorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RightSideMirrorReply>>(PrepareAsyncRightSideMirrorControlRaw(context, request, cq));
    }
    virtual ::grpc::Status FrontRightDoorControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightDoorRequest& request, ::UnityAPI::FrontRightDoorReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontRightDoorReply>> AsyncFrontRightDoorControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightDoorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontRightDoorReply>>(AsyncFrontRightDoorControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontRightDoorReply>> PrepareAsyncFrontRightDoorControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightDoorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontRightDoorReply>>(PrepareAsyncFrontRightDoorControlRaw(context, request, cq));
    }
    virtual ::grpc::Status FrontLeftDoorControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftDoorRequest& request, ::UnityAPI::FrontLeftDoorReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontLeftDoorReply>> AsyncFrontLeftDoorControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftDoorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontLeftDoorReply>>(AsyncFrontLeftDoorControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontLeftDoorReply>> PrepareAsyncFrontLeftDoorControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftDoorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontLeftDoorReply>>(PrepareAsyncFrontLeftDoorControlRaw(context, request, cq));
    }
    virtual ::grpc::Status RearRightDoorControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightDoorRequest& request, ::UnityAPI::RearRightDoorReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearRightDoorReply>> AsyncRearRightDoorControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightDoorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearRightDoorReply>>(AsyncRearRightDoorControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearRightDoorReply>> PrepareAsyncRearRightDoorControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightDoorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearRightDoorReply>>(PrepareAsyncRearRightDoorControlRaw(context, request, cq));
    }
    virtual ::grpc::Status RearLeftDoorControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftDoorRequest& request, ::UnityAPI::RearLeftDoorReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearLeftDoorReply>> AsyncRearLeftDoorControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftDoorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearLeftDoorReply>>(AsyncRearLeftDoorControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearLeftDoorReply>> PrepareAsyncRearLeftDoorControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftDoorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearLeftDoorReply>>(PrepareAsyncRearLeftDoorControlRaw(context, request, cq));
    }
    virtual ::grpc::Status TrunkControl(::grpc::ClientContext* context, const ::UnityAPI::TrunkRequest& request, ::UnityAPI::TrunkReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::TrunkReply>> AsyncTrunkControl(::grpc::ClientContext* context, const ::UnityAPI::TrunkRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::TrunkReply>>(AsyncTrunkControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::TrunkReply>> PrepareAsyncTrunkControl(::grpc::ClientContext* context, const ::UnityAPI::TrunkRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::TrunkReply>>(PrepareAsyncTrunkControlRaw(context, request, cq));
    }
    virtual ::grpc::Status SunRoofControl(::grpc::ClientContext* context, const ::UnityAPI::SunRoofRequest& request, ::UnityAPI::SunRoofReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::SunRoofReply>> AsyncSunRoofControl(::grpc::ClientContext* context, const ::UnityAPI::SunRoofRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::SunRoofReply>>(AsyncSunRoofControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::SunRoofReply>> PrepareAsyncSunRoofControl(::grpc::ClientContext* context, const ::UnityAPI::SunRoofRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::SunRoofReply>>(PrepareAsyncSunRoofControlRaw(context, request, cq));
    }
    virtual ::grpc::Status FrontRightPowerWindowsControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightPowerWindowsRequest& request, ::UnityAPI::FrontRightPowerWindowsReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontRightPowerWindowsReply>> AsyncFrontRightPowerWindowsControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightPowerWindowsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontRightPowerWindowsReply>>(AsyncFrontRightPowerWindowsControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontRightPowerWindowsReply>> PrepareAsyncFrontRightPowerWindowsControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightPowerWindowsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontRightPowerWindowsReply>>(PrepareAsyncFrontRightPowerWindowsControlRaw(context, request, cq));
    }
    virtual ::grpc::Status FrontLeftPowerWindowsControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftPowerWindowsRequest& request, ::UnityAPI::FrontLeftPowerWindowsReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontLeftPowerWindowsReply>> AsyncFrontLeftPowerWindowsControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftPowerWindowsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontLeftPowerWindowsReply>>(AsyncFrontLeftPowerWindowsControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontLeftPowerWindowsReply>> PrepareAsyncFrontLeftPowerWindowsControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftPowerWindowsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontLeftPowerWindowsReply>>(PrepareAsyncFrontLeftPowerWindowsControlRaw(context, request, cq));
    }
    virtual ::grpc::Status RearRightPowerWindowsControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightPowerWindowsRequest& request, ::UnityAPI::RearRightPowerWindowsReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearRightPowerWindowsReply>> AsyncRearRightPowerWindowsControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightPowerWindowsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearRightPowerWindowsReply>>(AsyncRearRightPowerWindowsControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearRightPowerWindowsReply>> PrepareAsyncRearRightPowerWindowsControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightPowerWindowsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearRightPowerWindowsReply>>(PrepareAsyncRearRightPowerWindowsControlRaw(context, request, cq));
    }
    virtual ::grpc::Status RearLeftPowerWindowsControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftPowerWindowsRequest& request, ::UnityAPI::RearLeftPowerWindowsReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearLeftPowerWindowsReply>> AsyncRearLeftPowerWindowsControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftPowerWindowsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearLeftPowerWindowsReply>>(AsyncRearLeftPowerWindowsControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearLeftPowerWindowsReply>> PrepareAsyncRearLeftPowerWindowsControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftPowerWindowsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearLeftPowerWindowsReply>>(PrepareAsyncRearLeftPowerWindowsControlRaw(context, request, cq));
    }
    virtual ::grpc::Status SideMirrorSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::SideMirrorSwitchRequest& request, ::UnityAPI::SideMirrorSwitchReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::SideMirrorSwitchReply>> AsyncSideMirrorSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::SideMirrorSwitchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::SideMirrorSwitchReply>>(AsyncSideMirrorSwitchControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::SideMirrorSwitchReply>> PrepareAsyncSideMirrorSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::SideMirrorSwitchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::SideMirrorSwitchReply>>(PrepareAsyncSideMirrorSwitchControlRaw(context, request, cq));
    }
    virtual ::grpc::Status InstrumentLightControl(::grpc::ClientContext* context, const ::UnityAPI::InstrumentLightRequest& request, ::UnityAPI::InstrumentLightReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::InstrumentLightReply>> AsyncInstrumentLightControl(::grpc::ClientContext* context, const ::UnityAPI::InstrumentLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::InstrumentLightReply>>(AsyncInstrumentLightControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::InstrumentLightReply>> PrepareAsyncInstrumentLightControl(::grpc::ClientContext* context, const ::UnityAPI::InstrumentLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::InstrumentLightReply>>(PrepareAsyncInstrumentLightControlRaw(context, request, cq));
    }
    virtual ::grpc::Status PassgenerRoomDomeLightControl(::grpc::ClientContext* context, const ::UnityAPI::PassgenerRoomDomeLightRequest& request, ::UnityAPI::PassgenerRoomDomeLightReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::PassgenerRoomDomeLightReply>> AsyncPassgenerRoomDomeLightControl(::grpc::ClientContext* context, const ::UnityAPI::PassgenerRoomDomeLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::PassgenerRoomDomeLightReply>>(AsyncPassgenerRoomDomeLightControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::PassgenerRoomDomeLightReply>> PrepareAsyncPassgenerRoomDomeLightControl(::grpc::ClientContext* context, const ::UnityAPI::PassgenerRoomDomeLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::PassgenerRoomDomeLightReply>>(PrepareAsyncPassgenerRoomDomeLightControlRaw(context, request, cq));
    }
    virtual ::grpc::Status ReadingLightDriverSideControl(::grpc::ClientContext* context, const ::UnityAPI::ReadingLightDriverSideRequest& request, ::UnityAPI::ReadingLightDriverSideReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::ReadingLightDriverSideReply>> AsyncReadingLightDriverSideControl(::grpc::ClientContext* context, const ::UnityAPI::ReadingLightDriverSideRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::ReadingLightDriverSideReply>>(AsyncReadingLightDriverSideControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::ReadingLightDriverSideReply>> PrepareAsyncReadingLightDriverSideControl(::grpc::ClientContext* context, const ::UnityAPI::ReadingLightDriverSideRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::ReadingLightDriverSideReply>>(PrepareAsyncReadingLightDriverSideControlRaw(context, request, cq));
    }
    virtual ::grpc::Status ReadingLightPassgenerSideControl(::grpc::ClientContext* context, const ::UnityAPI::ReadingLightPassgenerSideRequest& request, ::UnityAPI::ReadingLightPassgenerSideReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::ReadingLightPassgenerSideReply>> AsyncReadingLightPassgenerSideControl(::grpc::ClientContext* context, const ::UnityAPI::ReadingLightPassgenerSideRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::ReadingLightPassgenerSideReply>>(AsyncReadingLightPassgenerSideControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::ReadingLightPassgenerSideReply>> PrepareAsyncReadingLightPassgenerSideControl(::grpc::ClientContext* context, const ::UnityAPI::ReadingLightPassgenerSideRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::ReadingLightPassgenerSideReply>>(PrepareAsyncReadingLightPassgenerSideControlRaw(context, request, cq));
    }
    virtual ::grpc::Status FrontRightPowerWindowsSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightPowerWindowsSwitchRequest& request, ::UnityAPI::FrontRightPowerWindowsSwitchReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontRightPowerWindowsSwitchReply>> AsyncFrontRightPowerWindowsSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightPowerWindowsSwitchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontRightPowerWindowsSwitchReply>>(AsyncFrontRightPowerWindowsSwitchControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontRightPowerWindowsSwitchReply>> PrepareAsyncFrontRightPowerWindowsSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightPowerWindowsSwitchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontRightPowerWindowsSwitchReply>>(PrepareAsyncFrontRightPowerWindowsSwitchControlRaw(context, request, cq));
    }
    virtual ::grpc::Status FrontLeftPowerWindowsSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftPowerWindowsSwitchRequest& request, ::UnityAPI::FrontLeftPowerWindowsSwitchReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontLeftPowerWindowsSwitchReply>> AsyncFrontLeftPowerWindowsSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftPowerWindowsSwitchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontLeftPowerWindowsSwitchReply>>(AsyncFrontLeftPowerWindowsSwitchControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontLeftPowerWindowsSwitchReply>> PrepareAsyncFrontLeftPowerWindowsSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftPowerWindowsSwitchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontLeftPowerWindowsSwitchReply>>(PrepareAsyncFrontLeftPowerWindowsSwitchControlRaw(context, request, cq));
    }
    virtual ::grpc::Status RearRightPowerWindowsSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightPowerWindowsSwitchRequest& request, ::UnityAPI::RearRightPowerWindowsSwitchReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearRightPowerWindowsSwitchReply>> AsyncRearRightPowerWindowsSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightPowerWindowsSwitchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearRightPowerWindowsSwitchReply>>(AsyncRearRightPowerWindowsSwitchControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearRightPowerWindowsSwitchReply>> PrepareAsyncRearRightPowerWindowsSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightPowerWindowsSwitchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearRightPowerWindowsSwitchReply>>(PrepareAsyncRearRightPowerWindowsSwitchControlRaw(context, request, cq));
    }
    virtual ::grpc::Status RearLeftPowerWindowsSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftPowerWindowsSwitchRequest& request, ::UnityAPI::RearLeftPowerWindowsSwitchReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearLeftPowerWindowsSwitchReply>> AsyncRearLeftPowerWindowsSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftPowerWindowsSwitchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearLeftPowerWindowsSwitchReply>>(AsyncRearLeftPowerWindowsSwitchControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearLeftPowerWindowsSwitchReply>> PrepareAsyncRearLeftPowerWindowsSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftPowerWindowsSwitchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearLeftPowerWindowsSwitchReply>>(PrepareAsyncRearLeftPowerWindowsSwitchControlRaw(context, request, cq));
    }
    virtual ::grpc::Status HornControl(::grpc::ClientContext* context, const ::UnityAPI::HornRequest& request, ::UnityAPI::HornReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::HornReply>> AsyncHornControl(::grpc::ClientContext* context, const ::UnityAPI::HornRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::HornReply>>(AsyncHornControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::HornReply>> PrepareAsyncHornControl(::grpc::ClientContext* context, const ::UnityAPI::HornRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::HornReply>>(PrepareAsyncHornControlRaw(context, request, cq));
    }
    virtual ::grpc::Status BuzzerControl(::grpc::ClientContext* context, const ::UnityAPI::BuzzerRequest& request, ::UnityAPI::BuzzerReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::BuzzerReply>> AsyncBuzzerControl(::grpc::ClientContext* context, const ::UnityAPI::BuzzerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::BuzzerReply>>(AsyncBuzzerControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::BuzzerReply>> PrepareAsyncBuzzerControl(::grpc::ClientContext* context, const ::UnityAPI::BuzzerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::BuzzerReply>>(PrepareAsyncBuzzerControlRaw(context, request, cq));
    }
    virtual ::grpc::Status AirConditionerControl(::grpc::ClientContext* context, const ::UnityAPI::AirConditionerRequest& request, ::UnityAPI::AirConditionerReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::AirConditionerReply>> AsyncAirConditionerControl(::grpc::ClientContext* context, const ::UnityAPI::AirConditionerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::AirConditionerReply>>(AsyncAirConditionerControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::AirConditionerReply>> PrepareAsyncAirConditionerControl(::grpc::ClientContext* context, const ::UnityAPI::AirConditionerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::AirConditionerReply>>(PrepareAsyncAirConditionerControlRaw(context, request, cq));
    }
    virtual ::grpc::Status AirConditionerTemperatureControl(::grpc::ClientContext* context, const ::UnityAPI::AirCondTemperatureRequest& request, ::UnityAPI::AirCondTemperatureReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::AirCondTemperatureReply>> AsyncAirConditionerTemperatureControl(::grpc::ClientContext* context, const ::UnityAPI::AirCondTemperatureRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::AirCondTemperatureReply>>(AsyncAirConditionerTemperatureControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::AirCondTemperatureReply>> PrepareAsyncAirConditionerTemperatureControl(::grpc::ClientContext* context, const ::UnityAPI::AirCondTemperatureRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::AirCondTemperatureReply>>(PrepareAsyncAirConditionerTemperatureControlRaw(context, request, cq));
    }
    virtual ::grpc::Status AirConditionerFanSpeedControl(::grpc::ClientContext* context, const ::UnityAPI::AirConditionerFanSpeedRequest& request, ::UnityAPI::AirConditionerFanSpeedReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::AirConditionerFanSpeedReply>> AsyncAirConditionerFanSpeedControl(::grpc::ClientContext* context, const ::UnityAPI::AirConditionerFanSpeedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::AirConditionerFanSpeedReply>>(AsyncAirConditionerFanSpeedControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::AirConditionerFanSpeedReply>> PrepareAsyncAirConditionerFanSpeedControl(::grpc::ClientContext* context, const ::UnityAPI::AirConditionerFanSpeedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::AirConditionerFanSpeedReply>>(PrepareAsyncAirConditionerFanSpeedControlRaw(context, request, cq));
    }
    virtual ::grpc::Status HandlingControl(::grpc::ClientContext* context, const ::UnityAPI::HandlingRequest& request, ::UnityAPI::HandlingReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::HandlingReply>> AsyncHandlingControl(::grpc::ClientContext* context, const ::UnityAPI::HandlingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::HandlingReply>>(AsyncHandlingControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::HandlingReply>> PrepareAsyncHandlingControl(::grpc::ClientContext* context, const ::UnityAPI::HandlingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::HandlingReply>>(PrepareAsyncHandlingControlRaw(context, request, cq));
    }
    virtual ::grpc::Status CentralDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::CentralDoorLockSwitchRequest& request, ::UnityAPI::CentralDoorLockSwitchReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::CentralDoorLockSwitchReply>> AsyncCentralDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::CentralDoorLockSwitchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::CentralDoorLockSwitchReply>>(AsyncCentralDoorLockSwitchControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::CentralDoorLockSwitchReply>> PrepareAsyncCentralDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::CentralDoorLockSwitchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::CentralDoorLockSwitchReply>>(PrepareAsyncCentralDoorLockSwitchControlRaw(context, request, cq));
    }
    virtual ::grpc::Status FrontRightDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightDoorLockSwitchRequest& request, ::UnityAPI::FrontRightDoorLockSwitchReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontRightDoorLockSwitchReply>> AsyncFrontRightDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightDoorLockSwitchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontRightDoorLockSwitchReply>>(AsyncFrontRightDoorLockSwitchControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontRightDoorLockSwitchReply>> PrepareAsyncFrontRightDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightDoorLockSwitchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontRightDoorLockSwitchReply>>(PrepareAsyncFrontRightDoorLockSwitchControlRaw(context, request, cq));
    }
    virtual ::grpc::Status FrontLeftDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftDoorLockSwitchRequest& request, ::UnityAPI::FrontLeftDoorLockSwitchReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontLeftDoorLockSwitchReply>> AsyncFrontLeftDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftDoorLockSwitchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontLeftDoorLockSwitchReply>>(AsyncFrontLeftDoorLockSwitchControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontLeftDoorLockSwitchReply>> PrepareAsyncFrontLeftDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftDoorLockSwitchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontLeftDoorLockSwitchReply>>(PrepareAsyncFrontLeftDoorLockSwitchControlRaw(context, request, cq));
    }
    virtual ::grpc::Status RearRightDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightDoorLockSwitchRequest& request, ::UnityAPI::RearRightDoorLockSwitchReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearRightDoorLockSwitchReply>> AsyncRearRightDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightDoorLockSwitchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearRightDoorLockSwitchReply>>(AsyncRearRightDoorLockSwitchControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearRightDoorLockSwitchReply>> PrepareAsyncRearRightDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightDoorLockSwitchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearRightDoorLockSwitchReply>>(PrepareAsyncRearRightDoorLockSwitchControlRaw(context, request, cq));
    }
    virtual ::grpc::Status RearLeftDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftDoorLockSwitchRequest& request, ::UnityAPI::RearLeftDoorLockSwitchReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearLeftDoorLockSwitchReply>> AsyncRearLeftDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftDoorLockSwitchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearLeftDoorLockSwitchReply>>(AsyncRearLeftDoorLockSwitchControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearLeftDoorLockSwitchReply>> PrepareAsyncRearLeftDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftDoorLockSwitchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearLeftDoorLockSwitchReply>>(PrepareAsyncRearLeftDoorLockSwitchControlRaw(context, request, cq));
    }
    virtual ::grpc::Status get_database(::grpc::ClientContext* context, const ::UnityAPI::getDBRequest& request, ::UnityAPI::getDBReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::getDBReply>> Asyncget_database(::grpc::ClientContext* context, const ::UnityAPI::getDBRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::getDBReply>>(Asyncget_databaseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::getDBReply>> PrepareAsyncget_database(::grpc::ClientContext* context, const ::UnityAPI::getDBRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::getDBReply>>(PrepareAsyncget_databaseRaw(context, request, cq));
    }
    virtual ::grpc::Status send_update_database(::grpc::ClientContext* context, const ::UnityAPI::setDBRequest& request, ::UnityAPI::setDBReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::setDBReply>> Asyncsend_update_database(::grpc::ClientContext* context, const ::UnityAPI::setDBRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::setDBReply>>(Asyncsend_update_databaseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::setDBReply>> PrepareAsyncsend_update_database(::grpc::ClientContext* context, const ::UnityAPI::setDBRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::setDBReply>>(PrepareAsyncsend_update_databaseRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void FrontLowLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLowLightRequest* request, ::UnityAPI::FrontLowLightReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void FrontLowLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLowLightRequest* request, ::UnityAPI::FrontLowLightReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void FrontLowLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLowLightRequest* request, ::UnityAPI::FrontLowLightReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void FrontHighLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontHighLightRequest* request, ::UnityAPI::FrontHighLightReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void FrontHighLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontHighLightRequest* request, ::UnityAPI::FrontHighLightReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void FrontHighLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontHighLightRequest* request, ::UnityAPI::FrontHighLightReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void RearLightControl(::grpc::ClientContext* context, const ::UnityAPI::RearLightRequest* request, ::UnityAPI::RearLightReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void RearLightControl(::grpc::ClientContext* context, const ::UnityAPI::RearLightRequest* request, ::UnityAPI::RearLightReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void RearLightControl(::grpc::ClientContext* context, const ::UnityAPI::RearLightRequest* request, ::UnityAPI::RearLightReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void FrontDaytimeLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontDaytimeLightRequest* request, ::UnityAPI::FrontDaytimeLightReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void FrontDaytimeLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontDaytimeLightRequest* request, ::UnityAPI::FrontDaytimeLightReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void FrontDaytimeLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontDaytimeLightRequest* request, ::UnityAPI::FrontDaytimeLightReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void BrakeLightControl(::grpc::ClientContext* context, const ::UnityAPI::BrakeLightRequest* request, ::UnityAPI::BrakeLightReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void BrakeLightControl(::grpc::ClientContext* context, const ::UnityAPI::BrakeLightRequest* request, ::UnityAPI::BrakeLightReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void BrakeLightControl(::grpc::ClientContext* context, const ::UnityAPI::BrakeLightRequest* request, ::UnityAPI::BrakeLightReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void ReverseLightControl(::grpc::ClientContext* context, const ::UnityAPI::ReverseLightRequest* request, ::UnityAPI::ReverseLightReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ReverseLightControl(::grpc::ClientContext* context, const ::UnityAPI::ReverseLightRequest* request, ::UnityAPI::ReverseLightReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ReverseLightControl(::grpc::ClientContext* context, const ::UnityAPI::ReverseLightRequest* request, ::UnityAPI::ReverseLightReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void FrontFogLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontFogLightRequest* request, ::UnityAPI::FrontFogLightReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void FrontFogLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontFogLightRequest* request, ::UnityAPI::FrontFogLightReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void FrontFogLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontFogLightRequest* request, ::UnityAPI::FrontFogLightReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void RearFogLightControl(::grpc::ClientContext* context, const ::UnityAPI::RearFogLightRequest* request, ::UnityAPI::RearFogLightReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void RearFogLightControl(::grpc::ClientContext* context, const ::UnityAPI::RearFogLightRequest* request, ::UnityAPI::RearFogLightReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void RearFogLightControl(::grpc::ClientContext* context, const ::UnityAPI::RearFogLightRequest* request, ::UnityAPI::RearFogLightReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void ClearanceLampControl(::grpc::ClientContext* context, const ::UnityAPI::ClearanceLampRequest* request, ::UnityAPI::ClearanceLampReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ClearanceLampControl(::grpc::ClientContext* context, const ::UnityAPI::ClearanceLampRequest* request, ::UnityAPI::ClearanceLampReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ClearanceLampControl(::grpc::ClientContext* context, const ::UnityAPI::ClearanceLampRequest* request, ::UnityAPI::ClearanceLampReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void FrontLeftBlinkerLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftBlinkerLightRequest* request, ::UnityAPI::FrontLeftBlinkerLightReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void FrontLeftBlinkerLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftBlinkerLightRequest* request, ::UnityAPI::FrontLeftBlinkerLightReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void FrontLeftBlinkerLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftBlinkerLightRequest* request, ::UnityAPI::FrontLeftBlinkerLightReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void FrontRightBlinkerLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightBlinkerLightRequest* request, ::UnityAPI::FrontRightBlinkerLightReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void FrontRightBlinkerLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightBlinkerLightRequest* request, ::UnityAPI::FrontRightBlinkerLightReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void FrontRightBlinkerLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightBlinkerLightRequest* request, ::UnityAPI::FrontRightBlinkerLightReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void RearLeftBlinkerLightControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftBlinkerLightRequest* request, ::UnityAPI::RearLeftBlinkerLightReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void RearLeftBlinkerLightControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftBlinkerLightRequest* request, ::UnityAPI::RearLeftBlinkerLightReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void RearLeftBlinkerLightControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftBlinkerLightRequest* request, ::UnityAPI::RearLeftBlinkerLightReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void RearRightBlinkerLightControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightBlinkerLightRequest* request, ::UnityAPI::RearRightBlinkerLightReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void RearRightBlinkerLightControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightBlinkerLightRequest* request, ::UnityAPI::RearRightBlinkerLightReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void RearRightBlinkerLightControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightBlinkerLightRequest* request, ::UnityAPI::RearRightBlinkerLightReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void FrontWiperControl(::grpc::ClientContext* context, const ::UnityAPI::FrontWiperRequest* request, ::UnityAPI::FrontWiperReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void FrontWiperControl(::grpc::ClientContext* context, const ::UnityAPI::FrontWiperRequest* request, ::UnityAPI::FrontWiperReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void FrontWiperControl(::grpc::ClientContext* context, const ::UnityAPI::FrontWiperRequest* request, ::UnityAPI::FrontWiperReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void RearWiperControl(::grpc::ClientContext* context, const ::UnityAPI::RearWiperRequest* request, ::UnityAPI::RearWiperReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void RearWiperControl(::grpc::ClientContext* context, const ::UnityAPI::RearWiperRequest* request, ::UnityAPI::RearWiperReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void RearWiperControl(::grpc::ClientContext* context, const ::UnityAPI::RearWiperRequest* request, ::UnityAPI::RearWiperReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void LeftSideMirrorControl(::grpc::ClientContext* context, const ::UnityAPI::LeftSideMirrorRequest* request, ::UnityAPI::LeftSideMirrorReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void LeftSideMirrorControl(::grpc::ClientContext* context, const ::UnityAPI::LeftSideMirrorRequest* request, ::UnityAPI::LeftSideMirrorReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void LeftSideMirrorControl(::grpc::ClientContext* context, const ::UnityAPI::LeftSideMirrorRequest* request, ::UnityAPI::LeftSideMirrorReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void RightSideMirrorControl(::grpc::ClientContext* context, const ::UnityAPI::RightSideMirrorRequest* request, ::UnityAPI::RightSideMirrorReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void RightSideMirrorControl(::grpc::ClientContext* context, const ::UnityAPI::RightSideMirrorRequest* request, ::UnityAPI::RightSideMirrorReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void RightSideMirrorControl(::grpc::ClientContext* context, const ::UnityAPI::RightSideMirrorRequest* request, ::UnityAPI::RightSideMirrorReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void FrontRightDoorControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightDoorRequest* request, ::UnityAPI::FrontRightDoorReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void FrontRightDoorControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightDoorRequest* request, ::UnityAPI::FrontRightDoorReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void FrontRightDoorControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightDoorRequest* request, ::UnityAPI::FrontRightDoorReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void FrontLeftDoorControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftDoorRequest* request, ::UnityAPI::FrontLeftDoorReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void FrontLeftDoorControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftDoorRequest* request, ::UnityAPI::FrontLeftDoorReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void FrontLeftDoorControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftDoorRequest* request, ::UnityAPI::FrontLeftDoorReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void RearRightDoorControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightDoorRequest* request, ::UnityAPI::RearRightDoorReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void RearRightDoorControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightDoorRequest* request, ::UnityAPI::RearRightDoorReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void RearRightDoorControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightDoorRequest* request, ::UnityAPI::RearRightDoorReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void RearLeftDoorControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftDoorRequest* request, ::UnityAPI::RearLeftDoorReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void RearLeftDoorControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftDoorRequest* request, ::UnityAPI::RearLeftDoorReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void RearLeftDoorControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftDoorRequest* request, ::UnityAPI::RearLeftDoorReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void TrunkControl(::grpc::ClientContext* context, const ::UnityAPI::TrunkRequest* request, ::UnityAPI::TrunkReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void TrunkControl(::grpc::ClientContext* context, const ::UnityAPI::TrunkRequest* request, ::UnityAPI::TrunkReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void TrunkControl(::grpc::ClientContext* context, const ::UnityAPI::TrunkRequest* request, ::UnityAPI::TrunkReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void SunRoofControl(::grpc::ClientContext* context, const ::UnityAPI::SunRoofRequest* request, ::UnityAPI::SunRoofReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SunRoofControl(::grpc::ClientContext* context, const ::UnityAPI::SunRoofRequest* request, ::UnityAPI::SunRoofReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SunRoofControl(::grpc::ClientContext* context, const ::UnityAPI::SunRoofRequest* request, ::UnityAPI::SunRoofReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void FrontRightPowerWindowsControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightPowerWindowsRequest* request, ::UnityAPI::FrontRightPowerWindowsReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void FrontRightPowerWindowsControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightPowerWindowsRequest* request, ::UnityAPI::FrontRightPowerWindowsReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void FrontRightPowerWindowsControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightPowerWindowsRequest* request, ::UnityAPI::FrontRightPowerWindowsReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void FrontLeftPowerWindowsControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftPowerWindowsRequest* request, ::UnityAPI::FrontLeftPowerWindowsReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void FrontLeftPowerWindowsControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftPowerWindowsRequest* request, ::UnityAPI::FrontLeftPowerWindowsReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void FrontLeftPowerWindowsControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftPowerWindowsRequest* request, ::UnityAPI::FrontLeftPowerWindowsReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void RearRightPowerWindowsControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightPowerWindowsRequest* request, ::UnityAPI::RearRightPowerWindowsReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void RearRightPowerWindowsControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightPowerWindowsRequest* request, ::UnityAPI::RearRightPowerWindowsReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void RearRightPowerWindowsControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightPowerWindowsRequest* request, ::UnityAPI::RearRightPowerWindowsReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void RearLeftPowerWindowsControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftPowerWindowsRequest* request, ::UnityAPI::RearLeftPowerWindowsReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void RearLeftPowerWindowsControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftPowerWindowsRequest* request, ::UnityAPI::RearLeftPowerWindowsReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void RearLeftPowerWindowsControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftPowerWindowsRequest* request, ::UnityAPI::RearLeftPowerWindowsReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void SideMirrorSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::SideMirrorSwitchRequest* request, ::UnityAPI::SideMirrorSwitchReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SideMirrorSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::SideMirrorSwitchRequest* request, ::UnityAPI::SideMirrorSwitchReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SideMirrorSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::SideMirrorSwitchRequest* request, ::UnityAPI::SideMirrorSwitchReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void InstrumentLightControl(::grpc::ClientContext* context, const ::UnityAPI::InstrumentLightRequest* request, ::UnityAPI::InstrumentLightReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void InstrumentLightControl(::grpc::ClientContext* context, const ::UnityAPI::InstrumentLightRequest* request, ::UnityAPI::InstrumentLightReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void InstrumentLightControl(::grpc::ClientContext* context, const ::UnityAPI::InstrumentLightRequest* request, ::UnityAPI::InstrumentLightReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void PassgenerRoomDomeLightControl(::grpc::ClientContext* context, const ::UnityAPI::PassgenerRoomDomeLightRequest* request, ::UnityAPI::PassgenerRoomDomeLightReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PassgenerRoomDomeLightControl(::grpc::ClientContext* context, const ::UnityAPI::PassgenerRoomDomeLightRequest* request, ::UnityAPI::PassgenerRoomDomeLightReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PassgenerRoomDomeLightControl(::grpc::ClientContext* context, const ::UnityAPI::PassgenerRoomDomeLightRequest* request, ::UnityAPI::PassgenerRoomDomeLightReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void ReadingLightDriverSideControl(::grpc::ClientContext* context, const ::UnityAPI::ReadingLightDriverSideRequest* request, ::UnityAPI::ReadingLightDriverSideReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ReadingLightDriverSideControl(::grpc::ClientContext* context, const ::UnityAPI::ReadingLightDriverSideRequest* request, ::UnityAPI::ReadingLightDriverSideReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ReadingLightDriverSideControl(::grpc::ClientContext* context, const ::UnityAPI::ReadingLightDriverSideRequest* request, ::UnityAPI::ReadingLightDriverSideReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void ReadingLightPassgenerSideControl(::grpc::ClientContext* context, const ::UnityAPI::ReadingLightPassgenerSideRequest* request, ::UnityAPI::ReadingLightPassgenerSideReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ReadingLightPassgenerSideControl(::grpc::ClientContext* context, const ::UnityAPI::ReadingLightPassgenerSideRequest* request, ::UnityAPI::ReadingLightPassgenerSideReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ReadingLightPassgenerSideControl(::grpc::ClientContext* context, const ::UnityAPI::ReadingLightPassgenerSideRequest* request, ::UnityAPI::ReadingLightPassgenerSideReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void FrontRightPowerWindowsSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightPowerWindowsSwitchRequest* request, ::UnityAPI::FrontRightPowerWindowsSwitchReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void FrontRightPowerWindowsSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightPowerWindowsSwitchRequest* request, ::UnityAPI::FrontRightPowerWindowsSwitchReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void FrontRightPowerWindowsSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightPowerWindowsSwitchRequest* request, ::UnityAPI::FrontRightPowerWindowsSwitchReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void FrontLeftPowerWindowsSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftPowerWindowsSwitchRequest* request, ::UnityAPI::FrontLeftPowerWindowsSwitchReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void FrontLeftPowerWindowsSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftPowerWindowsSwitchRequest* request, ::UnityAPI::FrontLeftPowerWindowsSwitchReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void FrontLeftPowerWindowsSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftPowerWindowsSwitchRequest* request, ::UnityAPI::FrontLeftPowerWindowsSwitchReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void RearRightPowerWindowsSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightPowerWindowsSwitchRequest* request, ::UnityAPI::RearRightPowerWindowsSwitchReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void RearRightPowerWindowsSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightPowerWindowsSwitchRequest* request, ::UnityAPI::RearRightPowerWindowsSwitchReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void RearRightPowerWindowsSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightPowerWindowsSwitchRequest* request, ::UnityAPI::RearRightPowerWindowsSwitchReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void RearLeftPowerWindowsSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftPowerWindowsSwitchRequest* request, ::UnityAPI::RearLeftPowerWindowsSwitchReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void RearLeftPowerWindowsSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftPowerWindowsSwitchRequest* request, ::UnityAPI::RearLeftPowerWindowsSwitchReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void RearLeftPowerWindowsSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftPowerWindowsSwitchRequest* request, ::UnityAPI::RearLeftPowerWindowsSwitchReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void HornControl(::grpc::ClientContext* context, const ::UnityAPI::HornRequest* request, ::UnityAPI::HornReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void HornControl(::grpc::ClientContext* context, const ::UnityAPI::HornRequest* request, ::UnityAPI::HornReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void HornControl(::grpc::ClientContext* context, const ::UnityAPI::HornRequest* request, ::UnityAPI::HornReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void BuzzerControl(::grpc::ClientContext* context, const ::UnityAPI::BuzzerRequest* request, ::UnityAPI::BuzzerReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void BuzzerControl(::grpc::ClientContext* context, const ::UnityAPI::BuzzerRequest* request, ::UnityAPI::BuzzerReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void BuzzerControl(::grpc::ClientContext* context, const ::UnityAPI::BuzzerRequest* request, ::UnityAPI::BuzzerReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void AirConditionerControl(::grpc::ClientContext* context, const ::UnityAPI::AirConditionerRequest* request, ::UnityAPI::AirConditionerReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void AirConditionerControl(::grpc::ClientContext* context, const ::UnityAPI::AirConditionerRequest* request, ::UnityAPI::AirConditionerReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void AirConditionerControl(::grpc::ClientContext* context, const ::UnityAPI::AirConditionerRequest* request, ::UnityAPI::AirConditionerReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void AirConditionerTemperatureControl(::grpc::ClientContext* context, const ::UnityAPI::AirCondTemperatureRequest* request, ::UnityAPI::AirCondTemperatureReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void AirConditionerTemperatureControl(::grpc::ClientContext* context, const ::UnityAPI::AirCondTemperatureRequest* request, ::UnityAPI::AirCondTemperatureReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void AirConditionerTemperatureControl(::grpc::ClientContext* context, const ::UnityAPI::AirCondTemperatureRequest* request, ::UnityAPI::AirCondTemperatureReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void AirConditionerFanSpeedControl(::grpc::ClientContext* context, const ::UnityAPI::AirConditionerFanSpeedRequest* request, ::UnityAPI::AirConditionerFanSpeedReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void AirConditionerFanSpeedControl(::grpc::ClientContext* context, const ::UnityAPI::AirConditionerFanSpeedRequest* request, ::UnityAPI::AirConditionerFanSpeedReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void AirConditionerFanSpeedControl(::grpc::ClientContext* context, const ::UnityAPI::AirConditionerFanSpeedRequest* request, ::UnityAPI::AirConditionerFanSpeedReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void HandlingControl(::grpc::ClientContext* context, const ::UnityAPI::HandlingRequest* request, ::UnityAPI::HandlingReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void HandlingControl(::grpc::ClientContext* context, const ::UnityAPI::HandlingRequest* request, ::UnityAPI::HandlingReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void HandlingControl(::grpc::ClientContext* context, const ::UnityAPI::HandlingRequest* request, ::UnityAPI::HandlingReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void CentralDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::CentralDoorLockSwitchRequest* request, ::UnityAPI::CentralDoorLockSwitchReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void CentralDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::CentralDoorLockSwitchRequest* request, ::UnityAPI::CentralDoorLockSwitchReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void CentralDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::CentralDoorLockSwitchRequest* request, ::UnityAPI::CentralDoorLockSwitchReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void FrontRightDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightDoorLockSwitchRequest* request, ::UnityAPI::FrontRightDoorLockSwitchReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void FrontRightDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightDoorLockSwitchRequest* request, ::UnityAPI::FrontRightDoorLockSwitchReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void FrontRightDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightDoorLockSwitchRequest* request, ::UnityAPI::FrontRightDoorLockSwitchReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void FrontLeftDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftDoorLockSwitchRequest* request, ::UnityAPI::FrontLeftDoorLockSwitchReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void FrontLeftDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftDoorLockSwitchRequest* request, ::UnityAPI::FrontLeftDoorLockSwitchReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void FrontLeftDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftDoorLockSwitchRequest* request, ::UnityAPI::FrontLeftDoorLockSwitchReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void RearRightDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightDoorLockSwitchRequest* request, ::UnityAPI::RearRightDoorLockSwitchReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void RearRightDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightDoorLockSwitchRequest* request, ::UnityAPI::RearRightDoorLockSwitchReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void RearRightDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightDoorLockSwitchRequest* request, ::UnityAPI::RearRightDoorLockSwitchReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void RearLeftDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftDoorLockSwitchRequest* request, ::UnityAPI::RearLeftDoorLockSwitchReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void RearLeftDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftDoorLockSwitchRequest* request, ::UnityAPI::RearLeftDoorLockSwitchReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void RearLeftDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftDoorLockSwitchRequest* request, ::UnityAPI::RearLeftDoorLockSwitchReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void get_database(::grpc::ClientContext* context, const ::UnityAPI::getDBRequest* request, ::UnityAPI::getDBReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void get_database(::grpc::ClientContext* context, const ::UnityAPI::getDBRequest* request, ::UnityAPI::getDBReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void get_database(::grpc::ClientContext* context, const ::UnityAPI::getDBRequest* request, ::UnityAPI::getDBReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void send_update_database(::grpc::ClientContext* context, const ::UnityAPI::setDBRequest* request, ::UnityAPI::setDBReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void send_update_database(::grpc::ClientContext* context, const ::UnityAPI::setDBRequest* request, ::UnityAPI::setDBReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void send_update_database(::grpc::ClientContext* context, const ::UnityAPI::setDBRequest* request, ::UnityAPI::setDBReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontLowLightReply>* AsyncFrontLowLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontLowLightRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontLowLightReply>* PrepareAsyncFrontLowLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontLowLightRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontHighLightReply>* AsyncFrontHighLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontHighLightRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontHighLightReply>* PrepareAsyncFrontHighLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontHighLightRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearLightReply>* AsyncRearLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RearLightRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearLightReply>* PrepareAsyncRearLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RearLightRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontDaytimeLightReply>* AsyncFrontDaytimeLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontDaytimeLightRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontDaytimeLightReply>* PrepareAsyncFrontDaytimeLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontDaytimeLightRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::BrakeLightReply>* AsyncBrakeLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::BrakeLightRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::BrakeLightReply>* PrepareAsyncBrakeLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::BrakeLightRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::ReverseLightReply>* AsyncReverseLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::ReverseLightRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::ReverseLightReply>* PrepareAsyncReverseLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::ReverseLightRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontFogLightReply>* AsyncFrontFogLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontFogLightRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontFogLightReply>* PrepareAsyncFrontFogLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontFogLightRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearFogLightReply>* AsyncRearFogLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RearFogLightRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearFogLightReply>* PrepareAsyncRearFogLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RearFogLightRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::ClearanceLampReply>* AsyncClearanceLampControlRaw(::grpc::ClientContext* context, const ::UnityAPI::ClearanceLampRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::ClearanceLampReply>* PrepareAsyncClearanceLampControlRaw(::grpc::ClientContext* context, const ::UnityAPI::ClearanceLampRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontLeftBlinkerLightReply>* AsyncFrontLeftBlinkerLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftBlinkerLightRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontLeftBlinkerLightReply>* PrepareAsyncFrontLeftBlinkerLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftBlinkerLightRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontRightBlinkerLightReply>* AsyncFrontRightBlinkerLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontRightBlinkerLightRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontRightBlinkerLightReply>* PrepareAsyncFrontRightBlinkerLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontRightBlinkerLightRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearLeftBlinkerLightReply>* AsyncRearLeftBlinkerLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RearLeftBlinkerLightRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearLeftBlinkerLightReply>* PrepareAsyncRearLeftBlinkerLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RearLeftBlinkerLightRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearRightBlinkerLightReply>* AsyncRearRightBlinkerLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RearRightBlinkerLightRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearRightBlinkerLightReply>* PrepareAsyncRearRightBlinkerLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RearRightBlinkerLightRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontWiperReply>* AsyncFrontWiperControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontWiperRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontWiperReply>* PrepareAsyncFrontWiperControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontWiperRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearWiperReply>* AsyncRearWiperControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RearWiperRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearWiperReply>* PrepareAsyncRearWiperControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RearWiperRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::LeftSideMirrorReply>* AsyncLeftSideMirrorControlRaw(::grpc::ClientContext* context, const ::UnityAPI::LeftSideMirrorRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::LeftSideMirrorReply>* PrepareAsyncLeftSideMirrorControlRaw(::grpc::ClientContext* context, const ::UnityAPI::LeftSideMirrorRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RightSideMirrorReply>* AsyncRightSideMirrorControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RightSideMirrorRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RightSideMirrorReply>* PrepareAsyncRightSideMirrorControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RightSideMirrorRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontRightDoorReply>* AsyncFrontRightDoorControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontRightDoorRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontRightDoorReply>* PrepareAsyncFrontRightDoorControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontRightDoorRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontLeftDoorReply>* AsyncFrontLeftDoorControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftDoorRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontLeftDoorReply>* PrepareAsyncFrontLeftDoorControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftDoorRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearRightDoorReply>* AsyncRearRightDoorControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RearRightDoorRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearRightDoorReply>* PrepareAsyncRearRightDoorControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RearRightDoorRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearLeftDoorReply>* AsyncRearLeftDoorControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RearLeftDoorRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearLeftDoorReply>* PrepareAsyncRearLeftDoorControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RearLeftDoorRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::TrunkReply>* AsyncTrunkControlRaw(::grpc::ClientContext* context, const ::UnityAPI::TrunkRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::TrunkReply>* PrepareAsyncTrunkControlRaw(::grpc::ClientContext* context, const ::UnityAPI::TrunkRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::SunRoofReply>* AsyncSunRoofControlRaw(::grpc::ClientContext* context, const ::UnityAPI::SunRoofRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::SunRoofReply>* PrepareAsyncSunRoofControlRaw(::grpc::ClientContext* context, const ::UnityAPI::SunRoofRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontRightPowerWindowsReply>* AsyncFrontRightPowerWindowsControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontRightPowerWindowsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontRightPowerWindowsReply>* PrepareAsyncFrontRightPowerWindowsControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontRightPowerWindowsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontLeftPowerWindowsReply>* AsyncFrontLeftPowerWindowsControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftPowerWindowsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontLeftPowerWindowsReply>* PrepareAsyncFrontLeftPowerWindowsControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftPowerWindowsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearRightPowerWindowsReply>* AsyncRearRightPowerWindowsControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RearRightPowerWindowsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearRightPowerWindowsReply>* PrepareAsyncRearRightPowerWindowsControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RearRightPowerWindowsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearLeftPowerWindowsReply>* AsyncRearLeftPowerWindowsControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RearLeftPowerWindowsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearLeftPowerWindowsReply>* PrepareAsyncRearLeftPowerWindowsControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RearLeftPowerWindowsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::SideMirrorSwitchReply>* AsyncSideMirrorSwitchControlRaw(::grpc::ClientContext* context, const ::UnityAPI::SideMirrorSwitchRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::SideMirrorSwitchReply>* PrepareAsyncSideMirrorSwitchControlRaw(::grpc::ClientContext* context, const ::UnityAPI::SideMirrorSwitchRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::InstrumentLightReply>* AsyncInstrumentLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::InstrumentLightRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::InstrumentLightReply>* PrepareAsyncInstrumentLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::InstrumentLightRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::PassgenerRoomDomeLightReply>* AsyncPassgenerRoomDomeLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::PassgenerRoomDomeLightRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::PassgenerRoomDomeLightReply>* PrepareAsyncPassgenerRoomDomeLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::PassgenerRoomDomeLightRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::ReadingLightDriverSideReply>* AsyncReadingLightDriverSideControlRaw(::grpc::ClientContext* context, const ::UnityAPI::ReadingLightDriverSideRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::ReadingLightDriverSideReply>* PrepareAsyncReadingLightDriverSideControlRaw(::grpc::ClientContext* context, const ::UnityAPI::ReadingLightDriverSideRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::ReadingLightPassgenerSideReply>* AsyncReadingLightPassgenerSideControlRaw(::grpc::ClientContext* context, const ::UnityAPI::ReadingLightPassgenerSideRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::ReadingLightPassgenerSideReply>* PrepareAsyncReadingLightPassgenerSideControlRaw(::grpc::ClientContext* context, const ::UnityAPI::ReadingLightPassgenerSideRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontRightPowerWindowsSwitchReply>* AsyncFrontRightPowerWindowsSwitchControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontRightPowerWindowsSwitchRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontRightPowerWindowsSwitchReply>* PrepareAsyncFrontRightPowerWindowsSwitchControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontRightPowerWindowsSwitchRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontLeftPowerWindowsSwitchReply>* AsyncFrontLeftPowerWindowsSwitchControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftPowerWindowsSwitchRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontLeftPowerWindowsSwitchReply>* PrepareAsyncFrontLeftPowerWindowsSwitchControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftPowerWindowsSwitchRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearRightPowerWindowsSwitchReply>* AsyncRearRightPowerWindowsSwitchControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RearRightPowerWindowsSwitchRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearRightPowerWindowsSwitchReply>* PrepareAsyncRearRightPowerWindowsSwitchControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RearRightPowerWindowsSwitchRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearLeftPowerWindowsSwitchReply>* AsyncRearLeftPowerWindowsSwitchControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RearLeftPowerWindowsSwitchRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearLeftPowerWindowsSwitchReply>* PrepareAsyncRearLeftPowerWindowsSwitchControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RearLeftPowerWindowsSwitchRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::HornReply>* AsyncHornControlRaw(::grpc::ClientContext* context, const ::UnityAPI::HornRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::HornReply>* PrepareAsyncHornControlRaw(::grpc::ClientContext* context, const ::UnityAPI::HornRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::BuzzerReply>* AsyncBuzzerControlRaw(::grpc::ClientContext* context, const ::UnityAPI::BuzzerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::BuzzerReply>* PrepareAsyncBuzzerControlRaw(::grpc::ClientContext* context, const ::UnityAPI::BuzzerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::AirConditionerReply>* AsyncAirConditionerControlRaw(::grpc::ClientContext* context, const ::UnityAPI::AirConditionerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::AirConditionerReply>* PrepareAsyncAirConditionerControlRaw(::grpc::ClientContext* context, const ::UnityAPI::AirConditionerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::AirCondTemperatureReply>* AsyncAirConditionerTemperatureControlRaw(::grpc::ClientContext* context, const ::UnityAPI::AirCondTemperatureRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::AirCondTemperatureReply>* PrepareAsyncAirConditionerTemperatureControlRaw(::grpc::ClientContext* context, const ::UnityAPI::AirCondTemperatureRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::AirConditionerFanSpeedReply>* AsyncAirConditionerFanSpeedControlRaw(::grpc::ClientContext* context, const ::UnityAPI::AirConditionerFanSpeedRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::AirConditionerFanSpeedReply>* PrepareAsyncAirConditionerFanSpeedControlRaw(::grpc::ClientContext* context, const ::UnityAPI::AirConditionerFanSpeedRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::HandlingReply>* AsyncHandlingControlRaw(::grpc::ClientContext* context, const ::UnityAPI::HandlingRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::HandlingReply>* PrepareAsyncHandlingControlRaw(::grpc::ClientContext* context, const ::UnityAPI::HandlingRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::CentralDoorLockSwitchReply>* AsyncCentralDoorLockSwitchControlRaw(::grpc::ClientContext* context, const ::UnityAPI::CentralDoorLockSwitchRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::CentralDoorLockSwitchReply>* PrepareAsyncCentralDoorLockSwitchControlRaw(::grpc::ClientContext* context, const ::UnityAPI::CentralDoorLockSwitchRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontRightDoorLockSwitchReply>* AsyncFrontRightDoorLockSwitchControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontRightDoorLockSwitchRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontRightDoorLockSwitchReply>* PrepareAsyncFrontRightDoorLockSwitchControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontRightDoorLockSwitchRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontLeftDoorLockSwitchReply>* AsyncFrontLeftDoorLockSwitchControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftDoorLockSwitchRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::FrontLeftDoorLockSwitchReply>* PrepareAsyncFrontLeftDoorLockSwitchControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftDoorLockSwitchRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearRightDoorLockSwitchReply>* AsyncRearRightDoorLockSwitchControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RearRightDoorLockSwitchRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearRightDoorLockSwitchReply>* PrepareAsyncRearRightDoorLockSwitchControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RearRightDoorLockSwitchRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearLeftDoorLockSwitchReply>* AsyncRearLeftDoorLockSwitchControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RearLeftDoorLockSwitchRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::RearLeftDoorLockSwitchReply>* PrepareAsyncRearLeftDoorLockSwitchControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RearLeftDoorLockSwitchRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::getDBReply>* Asyncget_databaseRaw(::grpc::ClientContext* context, const ::UnityAPI::getDBRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::getDBReply>* PrepareAsyncget_databaseRaw(::grpc::ClientContext* context, const ::UnityAPI::getDBRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::setDBReply>* Asyncsend_update_databaseRaw(::grpc::ClientContext* context, const ::UnityAPI::setDBRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UnityAPI::setDBReply>* PrepareAsyncsend_update_databaseRaw(::grpc::ClientContext* context, const ::UnityAPI::setDBRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status FrontLowLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLowLightRequest& request, ::UnityAPI::FrontLowLightReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontLowLightReply>> AsyncFrontLowLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLowLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontLowLightReply>>(AsyncFrontLowLightControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontLowLightReply>> PrepareAsyncFrontLowLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLowLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontLowLightReply>>(PrepareAsyncFrontLowLightControlRaw(context, request, cq));
    }
    ::grpc::Status FrontHighLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontHighLightRequest& request, ::UnityAPI::FrontHighLightReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontHighLightReply>> AsyncFrontHighLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontHighLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontHighLightReply>>(AsyncFrontHighLightControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontHighLightReply>> PrepareAsyncFrontHighLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontHighLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontHighLightReply>>(PrepareAsyncFrontHighLightControlRaw(context, request, cq));
    }
    ::grpc::Status RearLightControl(::grpc::ClientContext* context, const ::UnityAPI::RearLightRequest& request, ::UnityAPI::RearLightReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearLightReply>> AsyncRearLightControl(::grpc::ClientContext* context, const ::UnityAPI::RearLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearLightReply>>(AsyncRearLightControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearLightReply>> PrepareAsyncRearLightControl(::grpc::ClientContext* context, const ::UnityAPI::RearLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearLightReply>>(PrepareAsyncRearLightControlRaw(context, request, cq));
    }
    ::grpc::Status FrontDaytimeLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontDaytimeLightRequest& request, ::UnityAPI::FrontDaytimeLightReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontDaytimeLightReply>> AsyncFrontDaytimeLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontDaytimeLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontDaytimeLightReply>>(AsyncFrontDaytimeLightControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontDaytimeLightReply>> PrepareAsyncFrontDaytimeLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontDaytimeLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontDaytimeLightReply>>(PrepareAsyncFrontDaytimeLightControlRaw(context, request, cq));
    }
    ::grpc::Status BrakeLightControl(::grpc::ClientContext* context, const ::UnityAPI::BrakeLightRequest& request, ::UnityAPI::BrakeLightReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::BrakeLightReply>> AsyncBrakeLightControl(::grpc::ClientContext* context, const ::UnityAPI::BrakeLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::BrakeLightReply>>(AsyncBrakeLightControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::BrakeLightReply>> PrepareAsyncBrakeLightControl(::grpc::ClientContext* context, const ::UnityAPI::BrakeLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::BrakeLightReply>>(PrepareAsyncBrakeLightControlRaw(context, request, cq));
    }
    ::grpc::Status ReverseLightControl(::grpc::ClientContext* context, const ::UnityAPI::ReverseLightRequest& request, ::UnityAPI::ReverseLightReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::ReverseLightReply>> AsyncReverseLightControl(::grpc::ClientContext* context, const ::UnityAPI::ReverseLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::ReverseLightReply>>(AsyncReverseLightControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::ReverseLightReply>> PrepareAsyncReverseLightControl(::grpc::ClientContext* context, const ::UnityAPI::ReverseLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::ReverseLightReply>>(PrepareAsyncReverseLightControlRaw(context, request, cq));
    }
    ::grpc::Status FrontFogLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontFogLightRequest& request, ::UnityAPI::FrontFogLightReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontFogLightReply>> AsyncFrontFogLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontFogLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontFogLightReply>>(AsyncFrontFogLightControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontFogLightReply>> PrepareAsyncFrontFogLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontFogLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontFogLightReply>>(PrepareAsyncFrontFogLightControlRaw(context, request, cq));
    }
    ::grpc::Status RearFogLightControl(::grpc::ClientContext* context, const ::UnityAPI::RearFogLightRequest& request, ::UnityAPI::RearFogLightReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearFogLightReply>> AsyncRearFogLightControl(::grpc::ClientContext* context, const ::UnityAPI::RearFogLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearFogLightReply>>(AsyncRearFogLightControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearFogLightReply>> PrepareAsyncRearFogLightControl(::grpc::ClientContext* context, const ::UnityAPI::RearFogLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearFogLightReply>>(PrepareAsyncRearFogLightControlRaw(context, request, cq));
    }
    ::grpc::Status ClearanceLampControl(::grpc::ClientContext* context, const ::UnityAPI::ClearanceLampRequest& request, ::UnityAPI::ClearanceLampReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::ClearanceLampReply>> AsyncClearanceLampControl(::grpc::ClientContext* context, const ::UnityAPI::ClearanceLampRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::ClearanceLampReply>>(AsyncClearanceLampControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::ClearanceLampReply>> PrepareAsyncClearanceLampControl(::grpc::ClientContext* context, const ::UnityAPI::ClearanceLampRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::ClearanceLampReply>>(PrepareAsyncClearanceLampControlRaw(context, request, cq));
    }
    ::grpc::Status FrontLeftBlinkerLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftBlinkerLightRequest& request, ::UnityAPI::FrontLeftBlinkerLightReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontLeftBlinkerLightReply>> AsyncFrontLeftBlinkerLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftBlinkerLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontLeftBlinkerLightReply>>(AsyncFrontLeftBlinkerLightControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontLeftBlinkerLightReply>> PrepareAsyncFrontLeftBlinkerLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftBlinkerLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontLeftBlinkerLightReply>>(PrepareAsyncFrontLeftBlinkerLightControlRaw(context, request, cq));
    }
    ::grpc::Status FrontRightBlinkerLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightBlinkerLightRequest& request, ::UnityAPI::FrontRightBlinkerLightReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontRightBlinkerLightReply>> AsyncFrontRightBlinkerLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightBlinkerLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontRightBlinkerLightReply>>(AsyncFrontRightBlinkerLightControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontRightBlinkerLightReply>> PrepareAsyncFrontRightBlinkerLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightBlinkerLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontRightBlinkerLightReply>>(PrepareAsyncFrontRightBlinkerLightControlRaw(context, request, cq));
    }
    ::grpc::Status RearLeftBlinkerLightControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftBlinkerLightRequest& request, ::UnityAPI::RearLeftBlinkerLightReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearLeftBlinkerLightReply>> AsyncRearLeftBlinkerLightControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftBlinkerLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearLeftBlinkerLightReply>>(AsyncRearLeftBlinkerLightControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearLeftBlinkerLightReply>> PrepareAsyncRearLeftBlinkerLightControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftBlinkerLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearLeftBlinkerLightReply>>(PrepareAsyncRearLeftBlinkerLightControlRaw(context, request, cq));
    }
    ::grpc::Status RearRightBlinkerLightControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightBlinkerLightRequest& request, ::UnityAPI::RearRightBlinkerLightReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearRightBlinkerLightReply>> AsyncRearRightBlinkerLightControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightBlinkerLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearRightBlinkerLightReply>>(AsyncRearRightBlinkerLightControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearRightBlinkerLightReply>> PrepareAsyncRearRightBlinkerLightControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightBlinkerLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearRightBlinkerLightReply>>(PrepareAsyncRearRightBlinkerLightControlRaw(context, request, cq));
    }
    ::grpc::Status FrontWiperControl(::grpc::ClientContext* context, const ::UnityAPI::FrontWiperRequest& request, ::UnityAPI::FrontWiperReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontWiperReply>> AsyncFrontWiperControl(::grpc::ClientContext* context, const ::UnityAPI::FrontWiperRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontWiperReply>>(AsyncFrontWiperControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontWiperReply>> PrepareAsyncFrontWiperControl(::grpc::ClientContext* context, const ::UnityAPI::FrontWiperRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontWiperReply>>(PrepareAsyncFrontWiperControlRaw(context, request, cq));
    }
    ::grpc::Status RearWiperControl(::grpc::ClientContext* context, const ::UnityAPI::RearWiperRequest& request, ::UnityAPI::RearWiperReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearWiperReply>> AsyncRearWiperControl(::grpc::ClientContext* context, const ::UnityAPI::RearWiperRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearWiperReply>>(AsyncRearWiperControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearWiperReply>> PrepareAsyncRearWiperControl(::grpc::ClientContext* context, const ::UnityAPI::RearWiperRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearWiperReply>>(PrepareAsyncRearWiperControlRaw(context, request, cq));
    }
    ::grpc::Status LeftSideMirrorControl(::grpc::ClientContext* context, const ::UnityAPI::LeftSideMirrorRequest& request, ::UnityAPI::LeftSideMirrorReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::LeftSideMirrorReply>> AsyncLeftSideMirrorControl(::grpc::ClientContext* context, const ::UnityAPI::LeftSideMirrorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::LeftSideMirrorReply>>(AsyncLeftSideMirrorControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::LeftSideMirrorReply>> PrepareAsyncLeftSideMirrorControl(::grpc::ClientContext* context, const ::UnityAPI::LeftSideMirrorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::LeftSideMirrorReply>>(PrepareAsyncLeftSideMirrorControlRaw(context, request, cq));
    }
    ::grpc::Status RightSideMirrorControl(::grpc::ClientContext* context, const ::UnityAPI::RightSideMirrorRequest& request, ::UnityAPI::RightSideMirrorReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RightSideMirrorReply>> AsyncRightSideMirrorControl(::grpc::ClientContext* context, const ::UnityAPI::RightSideMirrorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RightSideMirrorReply>>(AsyncRightSideMirrorControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RightSideMirrorReply>> PrepareAsyncRightSideMirrorControl(::grpc::ClientContext* context, const ::UnityAPI::RightSideMirrorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RightSideMirrorReply>>(PrepareAsyncRightSideMirrorControlRaw(context, request, cq));
    }
    ::grpc::Status FrontRightDoorControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightDoorRequest& request, ::UnityAPI::FrontRightDoorReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontRightDoorReply>> AsyncFrontRightDoorControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightDoorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontRightDoorReply>>(AsyncFrontRightDoorControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontRightDoorReply>> PrepareAsyncFrontRightDoorControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightDoorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontRightDoorReply>>(PrepareAsyncFrontRightDoorControlRaw(context, request, cq));
    }
    ::grpc::Status FrontLeftDoorControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftDoorRequest& request, ::UnityAPI::FrontLeftDoorReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontLeftDoorReply>> AsyncFrontLeftDoorControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftDoorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontLeftDoorReply>>(AsyncFrontLeftDoorControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontLeftDoorReply>> PrepareAsyncFrontLeftDoorControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftDoorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontLeftDoorReply>>(PrepareAsyncFrontLeftDoorControlRaw(context, request, cq));
    }
    ::grpc::Status RearRightDoorControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightDoorRequest& request, ::UnityAPI::RearRightDoorReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearRightDoorReply>> AsyncRearRightDoorControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightDoorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearRightDoorReply>>(AsyncRearRightDoorControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearRightDoorReply>> PrepareAsyncRearRightDoorControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightDoorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearRightDoorReply>>(PrepareAsyncRearRightDoorControlRaw(context, request, cq));
    }
    ::grpc::Status RearLeftDoorControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftDoorRequest& request, ::UnityAPI::RearLeftDoorReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearLeftDoorReply>> AsyncRearLeftDoorControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftDoorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearLeftDoorReply>>(AsyncRearLeftDoorControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearLeftDoorReply>> PrepareAsyncRearLeftDoorControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftDoorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearLeftDoorReply>>(PrepareAsyncRearLeftDoorControlRaw(context, request, cq));
    }
    ::grpc::Status TrunkControl(::grpc::ClientContext* context, const ::UnityAPI::TrunkRequest& request, ::UnityAPI::TrunkReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::TrunkReply>> AsyncTrunkControl(::grpc::ClientContext* context, const ::UnityAPI::TrunkRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::TrunkReply>>(AsyncTrunkControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::TrunkReply>> PrepareAsyncTrunkControl(::grpc::ClientContext* context, const ::UnityAPI::TrunkRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::TrunkReply>>(PrepareAsyncTrunkControlRaw(context, request, cq));
    }
    ::grpc::Status SunRoofControl(::grpc::ClientContext* context, const ::UnityAPI::SunRoofRequest& request, ::UnityAPI::SunRoofReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::SunRoofReply>> AsyncSunRoofControl(::grpc::ClientContext* context, const ::UnityAPI::SunRoofRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::SunRoofReply>>(AsyncSunRoofControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::SunRoofReply>> PrepareAsyncSunRoofControl(::grpc::ClientContext* context, const ::UnityAPI::SunRoofRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::SunRoofReply>>(PrepareAsyncSunRoofControlRaw(context, request, cq));
    }
    ::grpc::Status FrontRightPowerWindowsControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightPowerWindowsRequest& request, ::UnityAPI::FrontRightPowerWindowsReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontRightPowerWindowsReply>> AsyncFrontRightPowerWindowsControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightPowerWindowsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontRightPowerWindowsReply>>(AsyncFrontRightPowerWindowsControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontRightPowerWindowsReply>> PrepareAsyncFrontRightPowerWindowsControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightPowerWindowsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontRightPowerWindowsReply>>(PrepareAsyncFrontRightPowerWindowsControlRaw(context, request, cq));
    }
    ::grpc::Status FrontLeftPowerWindowsControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftPowerWindowsRequest& request, ::UnityAPI::FrontLeftPowerWindowsReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontLeftPowerWindowsReply>> AsyncFrontLeftPowerWindowsControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftPowerWindowsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontLeftPowerWindowsReply>>(AsyncFrontLeftPowerWindowsControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontLeftPowerWindowsReply>> PrepareAsyncFrontLeftPowerWindowsControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftPowerWindowsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontLeftPowerWindowsReply>>(PrepareAsyncFrontLeftPowerWindowsControlRaw(context, request, cq));
    }
    ::grpc::Status RearRightPowerWindowsControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightPowerWindowsRequest& request, ::UnityAPI::RearRightPowerWindowsReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearRightPowerWindowsReply>> AsyncRearRightPowerWindowsControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightPowerWindowsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearRightPowerWindowsReply>>(AsyncRearRightPowerWindowsControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearRightPowerWindowsReply>> PrepareAsyncRearRightPowerWindowsControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightPowerWindowsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearRightPowerWindowsReply>>(PrepareAsyncRearRightPowerWindowsControlRaw(context, request, cq));
    }
    ::grpc::Status RearLeftPowerWindowsControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftPowerWindowsRequest& request, ::UnityAPI::RearLeftPowerWindowsReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearLeftPowerWindowsReply>> AsyncRearLeftPowerWindowsControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftPowerWindowsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearLeftPowerWindowsReply>>(AsyncRearLeftPowerWindowsControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearLeftPowerWindowsReply>> PrepareAsyncRearLeftPowerWindowsControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftPowerWindowsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearLeftPowerWindowsReply>>(PrepareAsyncRearLeftPowerWindowsControlRaw(context, request, cq));
    }
    ::grpc::Status SideMirrorSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::SideMirrorSwitchRequest& request, ::UnityAPI::SideMirrorSwitchReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::SideMirrorSwitchReply>> AsyncSideMirrorSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::SideMirrorSwitchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::SideMirrorSwitchReply>>(AsyncSideMirrorSwitchControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::SideMirrorSwitchReply>> PrepareAsyncSideMirrorSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::SideMirrorSwitchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::SideMirrorSwitchReply>>(PrepareAsyncSideMirrorSwitchControlRaw(context, request, cq));
    }
    ::grpc::Status InstrumentLightControl(::grpc::ClientContext* context, const ::UnityAPI::InstrumentLightRequest& request, ::UnityAPI::InstrumentLightReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::InstrumentLightReply>> AsyncInstrumentLightControl(::grpc::ClientContext* context, const ::UnityAPI::InstrumentLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::InstrumentLightReply>>(AsyncInstrumentLightControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::InstrumentLightReply>> PrepareAsyncInstrumentLightControl(::grpc::ClientContext* context, const ::UnityAPI::InstrumentLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::InstrumentLightReply>>(PrepareAsyncInstrumentLightControlRaw(context, request, cq));
    }
    ::grpc::Status PassgenerRoomDomeLightControl(::grpc::ClientContext* context, const ::UnityAPI::PassgenerRoomDomeLightRequest& request, ::UnityAPI::PassgenerRoomDomeLightReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::PassgenerRoomDomeLightReply>> AsyncPassgenerRoomDomeLightControl(::grpc::ClientContext* context, const ::UnityAPI::PassgenerRoomDomeLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::PassgenerRoomDomeLightReply>>(AsyncPassgenerRoomDomeLightControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::PassgenerRoomDomeLightReply>> PrepareAsyncPassgenerRoomDomeLightControl(::grpc::ClientContext* context, const ::UnityAPI::PassgenerRoomDomeLightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::PassgenerRoomDomeLightReply>>(PrepareAsyncPassgenerRoomDomeLightControlRaw(context, request, cq));
    }
    ::grpc::Status ReadingLightDriverSideControl(::grpc::ClientContext* context, const ::UnityAPI::ReadingLightDriverSideRequest& request, ::UnityAPI::ReadingLightDriverSideReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::ReadingLightDriverSideReply>> AsyncReadingLightDriverSideControl(::grpc::ClientContext* context, const ::UnityAPI::ReadingLightDriverSideRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::ReadingLightDriverSideReply>>(AsyncReadingLightDriverSideControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::ReadingLightDriverSideReply>> PrepareAsyncReadingLightDriverSideControl(::grpc::ClientContext* context, const ::UnityAPI::ReadingLightDriverSideRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::ReadingLightDriverSideReply>>(PrepareAsyncReadingLightDriverSideControlRaw(context, request, cq));
    }
    ::grpc::Status ReadingLightPassgenerSideControl(::grpc::ClientContext* context, const ::UnityAPI::ReadingLightPassgenerSideRequest& request, ::UnityAPI::ReadingLightPassgenerSideReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::ReadingLightPassgenerSideReply>> AsyncReadingLightPassgenerSideControl(::grpc::ClientContext* context, const ::UnityAPI::ReadingLightPassgenerSideRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::ReadingLightPassgenerSideReply>>(AsyncReadingLightPassgenerSideControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::ReadingLightPassgenerSideReply>> PrepareAsyncReadingLightPassgenerSideControl(::grpc::ClientContext* context, const ::UnityAPI::ReadingLightPassgenerSideRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::ReadingLightPassgenerSideReply>>(PrepareAsyncReadingLightPassgenerSideControlRaw(context, request, cq));
    }
    ::grpc::Status FrontRightPowerWindowsSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightPowerWindowsSwitchRequest& request, ::UnityAPI::FrontRightPowerWindowsSwitchReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontRightPowerWindowsSwitchReply>> AsyncFrontRightPowerWindowsSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightPowerWindowsSwitchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontRightPowerWindowsSwitchReply>>(AsyncFrontRightPowerWindowsSwitchControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontRightPowerWindowsSwitchReply>> PrepareAsyncFrontRightPowerWindowsSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightPowerWindowsSwitchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontRightPowerWindowsSwitchReply>>(PrepareAsyncFrontRightPowerWindowsSwitchControlRaw(context, request, cq));
    }
    ::grpc::Status FrontLeftPowerWindowsSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftPowerWindowsSwitchRequest& request, ::UnityAPI::FrontLeftPowerWindowsSwitchReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontLeftPowerWindowsSwitchReply>> AsyncFrontLeftPowerWindowsSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftPowerWindowsSwitchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontLeftPowerWindowsSwitchReply>>(AsyncFrontLeftPowerWindowsSwitchControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontLeftPowerWindowsSwitchReply>> PrepareAsyncFrontLeftPowerWindowsSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftPowerWindowsSwitchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontLeftPowerWindowsSwitchReply>>(PrepareAsyncFrontLeftPowerWindowsSwitchControlRaw(context, request, cq));
    }
    ::grpc::Status RearRightPowerWindowsSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightPowerWindowsSwitchRequest& request, ::UnityAPI::RearRightPowerWindowsSwitchReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearRightPowerWindowsSwitchReply>> AsyncRearRightPowerWindowsSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightPowerWindowsSwitchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearRightPowerWindowsSwitchReply>>(AsyncRearRightPowerWindowsSwitchControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearRightPowerWindowsSwitchReply>> PrepareAsyncRearRightPowerWindowsSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightPowerWindowsSwitchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearRightPowerWindowsSwitchReply>>(PrepareAsyncRearRightPowerWindowsSwitchControlRaw(context, request, cq));
    }
    ::grpc::Status RearLeftPowerWindowsSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftPowerWindowsSwitchRequest& request, ::UnityAPI::RearLeftPowerWindowsSwitchReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearLeftPowerWindowsSwitchReply>> AsyncRearLeftPowerWindowsSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftPowerWindowsSwitchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearLeftPowerWindowsSwitchReply>>(AsyncRearLeftPowerWindowsSwitchControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearLeftPowerWindowsSwitchReply>> PrepareAsyncRearLeftPowerWindowsSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftPowerWindowsSwitchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearLeftPowerWindowsSwitchReply>>(PrepareAsyncRearLeftPowerWindowsSwitchControlRaw(context, request, cq));
    }
    ::grpc::Status HornControl(::grpc::ClientContext* context, const ::UnityAPI::HornRequest& request, ::UnityAPI::HornReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::HornReply>> AsyncHornControl(::grpc::ClientContext* context, const ::UnityAPI::HornRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::HornReply>>(AsyncHornControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::HornReply>> PrepareAsyncHornControl(::grpc::ClientContext* context, const ::UnityAPI::HornRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::HornReply>>(PrepareAsyncHornControlRaw(context, request, cq));
    }
    ::grpc::Status BuzzerControl(::grpc::ClientContext* context, const ::UnityAPI::BuzzerRequest& request, ::UnityAPI::BuzzerReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::BuzzerReply>> AsyncBuzzerControl(::grpc::ClientContext* context, const ::UnityAPI::BuzzerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::BuzzerReply>>(AsyncBuzzerControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::BuzzerReply>> PrepareAsyncBuzzerControl(::grpc::ClientContext* context, const ::UnityAPI::BuzzerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::BuzzerReply>>(PrepareAsyncBuzzerControlRaw(context, request, cq));
    }
    ::grpc::Status AirConditionerControl(::grpc::ClientContext* context, const ::UnityAPI::AirConditionerRequest& request, ::UnityAPI::AirConditionerReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::AirConditionerReply>> AsyncAirConditionerControl(::grpc::ClientContext* context, const ::UnityAPI::AirConditionerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::AirConditionerReply>>(AsyncAirConditionerControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::AirConditionerReply>> PrepareAsyncAirConditionerControl(::grpc::ClientContext* context, const ::UnityAPI::AirConditionerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::AirConditionerReply>>(PrepareAsyncAirConditionerControlRaw(context, request, cq));
    }
    ::grpc::Status AirConditionerTemperatureControl(::grpc::ClientContext* context, const ::UnityAPI::AirCondTemperatureRequest& request, ::UnityAPI::AirCondTemperatureReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::AirCondTemperatureReply>> AsyncAirConditionerTemperatureControl(::grpc::ClientContext* context, const ::UnityAPI::AirCondTemperatureRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::AirCondTemperatureReply>>(AsyncAirConditionerTemperatureControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::AirCondTemperatureReply>> PrepareAsyncAirConditionerTemperatureControl(::grpc::ClientContext* context, const ::UnityAPI::AirCondTemperatureRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::AirCondTemperatureReply>>(PrepareAsyncAirConditionerTemperatureControlRaw(context, request, cq));
    }
    ::grpc::Status AirConditionerFanSpeedControl(::grpc::ClientContext* context, const ::UnityAPI::AirConditionerFanSpeedRequest& request, ::UnityAPI::AirConditionerFanSpeedReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::AirConditionerFanSpeedReply>> AsyncAirConditionerFanSpeedControl(::grpc::ClientContext* context, const ::UnityAPI::AirConditionerFanSpeedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::AirConditionerFanSpeedReply>>(AsyncAirConditionerFanSpeedControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::AirConditionerFanSpeedReply>> PrepareAsyncAirConditionerFanSpeedControl(::grpc::ClientContext* context, const ::UnityAPI::AirConditionerFanSpeedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::AirConditionerFanSpeedReply>>(PrepareAsyncAirConditionerFanSpeedControlRaw(context, request, cq));
    }
    ::grpc::Status HandlingControl(::grpc::ClientContext* context, const ::UnityAPI::HandlingRequest& request, ::UnityAPI::HandlingReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::HandlingReply>> AsyncHandlingControl(::grpc::ClientContext* context, const ::UnityAPI::HandlingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::HandlingReply>>(AsyncHandlingControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::HandlingReply>> PrepareAsyncHandlingControl(::grpc::ClientContext* context, const ::UnityAPI::HandlingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::HandlingReply>>(PrepareAsyncHandlingControlRaw(context, request, cq));
    }
    ::grpc::Status CentralDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::CentralDoorLockSwitchRequest& request, ::UnityAPI::CentralDoorLockSwitchReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::CentralDoorLockSwitchReply>> AsyncCentralDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::CentralDoorLockSwitchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::CentralDoorLockSwitchReply>>(AsyncCentralDoorLockSwitchControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::CentralDoorLockSwitchReply>> PrepareAsyncCentralDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::CentralDoorLockSwitchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::CentralDoorLockSwitchReply>>(PrepareAsyncCentralDoorLockSwitchControlRaw(context, request, cq));
    }
    ::grpc::Status FrontRightDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightDoorLockSwitchRequest& request, ::UnityAPI::FrontRightDoorLockSwitchReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontRightDoorLockSwitchReply>> AsyncFrontRightDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightDoorLockSwitchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontRightDoorLockSwitchReply>>(AsyncFrontRightDoorLockSwitchControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontRightDoorLockSwitchReply>> PrepareAsyncFrontRightDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightDoorLockSwitchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontRightDoorLockSwitchReply>>(PrepareAsyncFrontRightDoorLockSwitchControlRaw(context, request, cq));
    }
    ::grpc::Status FrontLeftDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftDoorLockSwitchRequest& request, ::UnityAPI::FrontLeftDoorLockSwitchReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontLeftDoorLockSwitchReply>> AsyncFrontLeftDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftDoorLockSwitchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontLeftDoorLockSwitchReply>>(AsyncFrontLeftDoorLockSwitchControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontLeftDoorLockSwitchReply>> PrepareAsyncFrontLeftDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftDoorLockSwitchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontLeftDoorLockSwitchReply>>(PrepareAsyncFrontLeftDoorLockSwitchControlRaw(context, request, cq));
    }
    ::grpc::Status RearRightDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightDoorLockSwitchRequest& request, ::UnityAPI::RearRightDoorLockSwitchReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearRightDoorLockSwitchReply>> AsyncRearRightDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightDoorLockSwitchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearRightDoorLockSwitchReply>>(AsyncRearRightDoorLockSwitchControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearRightDoorLockSwitchReply>> PrepareAsyncRearRightDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightDoorLockSwitchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearRightDoorLockSwitchReply>>(PrepareAsyncRearRightDoorLockSwitchControlRaw(context, request, cq));
    }
    ::grpc::Status RearLeftDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftDoorLockSwitchRequest& request, ::UnityAPI::RearLeftDoorLockSwitchReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearLeftDoorLockSwitchReply>> AsyncRearLeftDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftDoorLockSwitchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearLeftDoorLockSwitchReply>>(AsyncRearLeftDoorLockSwitchControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearLeftDoorLockSwitchReply>> PrepareAsyncRearLeftDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftDoorLockSwitchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearLeftDoorLockSwitchReply>>(PrepareAsyncRearLeftDoorLockSwitchControlRaw(context, request, cq));
    }
    ::grpc::Status get_database(::grpc::ClientContext* context, const ::UnityAPI::getDBRequest& request, ::UnityAPI::getDBReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::getDBReply>> Asyncget_database(::grpc::ClientContext* context, const ::UnityAPI::getDBRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::getDBReply>>(Asyncget_databaseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::getDBReply>> PrepareAsyncget_database(::grpc::ClientContext* context, const ::UnityAPI::getDBRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::getDBReply>>(PrepareAsyncget_databaseRaw(context, request, cq));
    }
    ::grpc::Status send_update_database(::grpc::ClientContext* context, const ::UnityAPI::setDBRequest& request, ::UnityAPI::setDBReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::setDBReply>> Asyncsend_update_database(::grpc::ClientContext* context, const ::UnityAPI::setDBRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::setDBReply>>(Asyncsend_update_databaseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::setDBReply>> PrepareAsyncsend_update_database(::grpc::ClientContext* context, const ::UnityAPI::setDBRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UnityAPI::setDBReply>>(PrepareAsyncsend_update_databaseRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void FrontLowLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLowLightRequest* request, ::UnityAPI::FrontLowLightReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void FrontLowLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLowLightRequest* request, ::UnityAPI::FrontLowLightReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void FrontLowLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLowLightRequest* request, ::UnityAPI::FrontLowLightReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void FrontHighLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontHighLightRequest* request, ::UnityAPI::FrontHighLightReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void FrontHighLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontHighLightRequest* request, ::UnityAPI::FrontHighLightReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void FrontHighLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontHighLightRequest* request, ::UnityAPI::FrontHighLightReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void RearLightControl(::grpc::ClientContext* context, const ::UnityAPI::RearLightRequest* request, ::UnityAPI::RearLightReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void RearLightControl(::grpc::ClientContext* context, const ::UnityAPI::RearLightRequest* request, ::UnityAPI::RearLightReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void RearLightControl(::grpc::ClientContext* context, const ::UnityAPI::RearLightRequest* request, ::UnityAPI::RearLightReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void FrontDaytimeLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontDaytimeLightRequest* request, ::UnityAPI::FrontDaytimeLightReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void FrontDaytimeLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontDaytimeLightRequest* request, ::UnityAPI::FrontDaytimeLightReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void FrontDaytimeLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontDaytimeLightRequest* request, ::UnityAPI::FrontDaytimeLightReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void BrakeLightControl(::grpc::ClientContext* context, const ::UnityAPI::BrakeLightRequest* request, ::UnityAPI::BrakeLightReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void BrakeLightControl(::grpc::ClientContext* context, const ::UnityAPI::BrakeLightRequest* request, ::UnityAPI::BrakeLightReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void BrakeLightControl(::grpc::ClientContext* context, const ::UnityAPI::BrakeLightRequest* request, ::UnityAPI::BrakeLightReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ReverseLightControl(::grpc::ClientContext* context, const ::UnityAPI::ReverseLightRequest* request, ::UnityAPI::ReverseLightReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ReverseLightControl(::grpc::ClientContext* context, const ::UnityAPI::ReverseLightRequest* request, ::UnityAPI::ReverseLightReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ReverseLightControl(::grpc::ClientContext* context, const ::UnityAPI::ReverseLightRequest* request, ::UnityAPI::ReverseLightReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void FrontFogLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontFogLightRequest* request, ::UnityAPI::FrontFogLightReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void FrontFogLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontFogLightRequest* request, ::UnityAPI::FrontFogLightReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void FrontFogLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontFogLightRequest* request, ::UnityAPI::FrontFogLightReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void RearFogLightControl(::grpc::ClientContext* context, const ::UnityAPI::RearFogLightRequest* request, ::UnityAPI::RearFogLightReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void RearFogLightControl(::grpc::ClientContext* context, const ::UnityAPI::RearFogLightRequest* request, ::UnityAPI::RearFogLightReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void RearFogLightControl(::grpc::ClientContext* context, const ::UnityAPI::RearFogLightRequest* request, ::UnityAPI::RearFogLightReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ClearanceLampControl(::grpc::ClientContext* context, const ::UnityAPI::ClearanceLampRequest* request, ::UnityAPI::ClearanceLampReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ClearanceLampControl(::grpc::ClientContext* context, const ::UnityAPI::ClearanceLampRequest* request, ::UnityAPI::ClearanceLampReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ClearanceLampControl(::grpc::ClientContext* context, const ::UnityAPI::ClearanceLampRequest* request, ::UnityAPI::ClearanceLampReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void FrontLeftBlinkerLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftBlinkerLightRequest* request, ::UnityAPI::FrontLeftBlinkerLightReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void FrontLeftBlinkerLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftBlinkerLightRequest* request, ::UnityAPI::FrontLeftBlinkerLightReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void FrontLeftBlinkerLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftBlinkerLightRequest* request, ::UnityAPI::FrontLeftBlinkerLightReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void FrontRightBlinkerLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightBlinkerLightRequest* request, ::UnityAPI::FrontRightBlinkerLightReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void FrontRightBlinkerLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightBlinkerLightRequest* request, ::UnityAPI::FrontRightBlinkerLightReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void FrontRightBlinkerLightControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightBlinkerLightRequest* request, ::UnityAPI::FrontRightBlinkerLightReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void RearLeftBlinkerLightControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftBlinkerLightRequest* request, ::UnityAPI::RearLeftBlinkerLightReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void RearLeftBlinkerLightControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftBlinkerLightRequest* request, ::UnityAPI::RearLeftBlinkerLightReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void RearLeftBlinkerLightControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftBlinkerLightRequest* request, ::UnityAPI::RearLeftBlinkerLightReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void RearRightBlinkerLightControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightBlinkerLightRequest* request, ::UnityAPI::RearRightBlinkerLightReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void RearRightBlinkerLightControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightBlinkerLightRequest* request, ::UnityAPI::RearRightBlinkerLightReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void RearRightBlinkerLightControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightBlinkerLightRequest* request, ::UnityAPI::RearRightBlinkerLightReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void FrontWiperControl(::grpc::ClientContext* context, const ::UnityAPI::FrontWiperRequest* request, ::UnityAPI::FrontWiperReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void FrontWiperControl(::grpc::ClientContext* context, const ::UnityAPI::FrontWiperRequest* request, ::UnityAPI::FrontWiperReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void FrontWiperControl(::grpc::ClientContext* context, const ::UnityAPI::FrontWiperRequest* request, ::UnityAPI::FrontWiperReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void RearWiperControl(::grpc::ClientContext* context, const ::UnityAPI::RearWiperRequest* request, ::UnityAPI::RearWiperReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void RearWiperControl(::grpc::ClientContext* context, const ::UnityAPI::RearWiperRequest* request, ::UnityAPI::RearWiperReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void RearWiperControl(::grpc::ClientContext* context, const ::UnityAPI::RearWiperRequest* request, ::UnityAPI::RearWiperReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void LeftSideMirrorControl(::grpc::ClientContext* context, const ::UnityAPI::LeftSideMirrorRequest* request, ::UnityAPI::LeftSideMirrorReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void LeftSideMirrorControl(::grpc::ClientContext* context, const ::UnityAPI::LeftSideMirrorRequest* request, ::UnityAPI::LeftSideMirrorReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void LeftSideMirrorControl(::grpc::ClientContext* context, const ::UnityAPI::LeftSideMirrorRequest* request, ::UnityAPI::LeftSideMirrorReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void RightSideMirrorControl(::grpc::ClientContext* context, const ::UnityAPI::RightSideMirrorRequest* request, ::UnityAPI::RightSideMirrorReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void RightSideMirrorControl(::grpc::ClientContext* context, const ::UnityAPI::RightSideMirrorRequest* request, ::UnityAPI::RightSideMirrorReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void RightSideMirrorControl(::grpc::ClientContext* context, const ::UnityAPI::RightSideMirrorRequest* request, ::UnityAPI::RightSideMirrorReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void FrontRightDoorControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightDoorRequest* request, ::UnityAPI::FrontRightDoorReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void FrontRightDoorControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightDoorRequest* request, ::UnityAPI::FrontRightDoorReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void FrontRightDoorControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightDoorRequest* request, ::UnityAPI::FrontRightDoorReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void FrontLeftDoorControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftDoorRequest* request, ::UnityAPI::FrontLeftDoorReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void FrontLeftDoorControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftDoorRequest* request, ::UnityAPI::FrontLeftDoorReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void FrontLeftDoorControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftDoorRequest* request, ::UnityAPI::FrontLeftDoorReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void RearRightDoorControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightDoorRequest* request, ::UnityAPI::RearRightDoorReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void RearRightDoorControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightDoorRequest* request, ::UnityAPI::RearRightDoorReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void RearRightDoorControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightDoorRequest* request, ::UnityAPI::RearRightDoorReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void RearLeftDoorControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftDoorRequest* request, ::UnityAPI::RearLeftDoorReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void RearLeftDoorControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftDoorRequest* request, ::UnityAPI::RearLeftDoorReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void RearLeftDoorControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftDoorRequest* request, ::UnityAPI::RearLeftDoorReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void TrunkControl(::grpc::ClientContext* context, const ::UnityAPI::TrunkRequest* request, ::UnityAPI::TrunkReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void TrunkControl(::grpc::ClientContext* context, const ::UnityAPI::TrunkRequest* request, ::UnityAPI::TrunkReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void TrunkControl(::grpc::ClientContext* context, const ::UnityAPI::TrunkRequest* request, ::UnityAPI::TrunkReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void SunRoofControl(::grpc::ClientContext* context, const ::UnityAPI::SunRoofRequest* request, ::UnityAPI::SunRoofReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SunRoofControl(::grpc::ClientContext* context, const ::UnityAPI::SunRoofRequest* request, ::UnityAPI::SunRoofReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SunRoofControl(::grpc::ClientContext* context, const ::UnityAPI::SunRoofRequest* request, ::UnityAPI::SunRoofReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void FrontRightPowerWindowsControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightPowerWindowsRequest* request, ::UnityAPI::FrontRightPowerWindowsReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void FrontRightPowerWindowsControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightPowerWindowsRequest* request, ::UnityAPI::FrontRightPowerWindowsReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void FrontRightPowerWindowsControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightPowerWindowsRequest* request, ::UnityAPI::FrontRightPowerWindowsReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void FrontLeftPowerWindowsControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftPowerWindowsRequest* request, ::UnityAPI::FrontLeftPowerWindowsReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void FrontLeftPowerWindowsControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftPowerWindowsRequest* request, ::UnityAPI::FrontLeftPowerWindowsReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void FrontLeftPowerWindowsControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftPowerWindowsRequest* request, ::UnityAPI::FrontLeftPowerWindowsReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void RearRightPowerWindowsControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightPowerWindowsRequest* request, ::UnityAPI::RearRightPowerWindowsReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void RearRightPowerWindowsControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightPowerWindowsRequest* request, ::UnityAPI::RearRightPowerWindowsReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void RearRightPowerWindowsControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightPowerWindowsRequest* request, ::UnityAPI::RearRightPowerWindowsReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void RearLeftPowerWindowsControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftPowerWindowsRequest* request, ::UnityAPI::RearLeftPowerWindowsReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void RearLeftPowerWindowsControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftPowerWindowsRequest* request, ::UnityAPI::RearLeftPowerWindowsReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void RearLeftPowerWindowsControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftPowerWindowsRequest* request, ::UnityAPI::RearLeftPowerWindowsReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void SideMirrorSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::SideMirrorSwitchRequest* request, ::UnityAPI::SideMirrorSwitchReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SideMirrorSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::SideMirrorSwitchRequest* request, ::UnityAPI::SideMirrorSwitchReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SideMirrorSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::SideMirrorSwitchRequest* request, ::UnityAPI::SideMirrorSwitchReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void InstrumentLightControl(::grpc::ClientContext* context, const ::UnityAPI::InstrumentLightRequest* request, ::UnityAPI::InstrumentLightReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void InstrumentLightControl(::grpc::ClientContext* context, const ::UnityAPI::InstrumentLightRequest* request, ::UnityAPI::InstrumentLightReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void InstrumentLightControl(::grpc::ClientContext* context, const ::UnityAPI::InstrumentLightRequest* request, ::UnityAPI::InstrumentLightReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PassgenerRoomDomeLightControl(::grpc::ClientContext* context, const ::UnityAPI::PassgenerRoomDomeLightRequest* request, ::UnityAPI::PassgenerRoomDomeLightReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PassgenerRoomDomeLightControl(::grpc::ClientContext* context, const ::UnityAPI::PassgenerRoomDomeLightRequest* request, ::UnityAPI::PassgenerRoomDomeLightReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PassgenerRoomDomeLightControl(::grpc::ClientContext* context, const ::UnityAPI::PassgenerRoomDomeLightRequest* request, ::UnityAPI::PassgenerRoomDomeLightReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ReadingLightDriverSideControl(::grpc::ClientContext* context, const ::UnityAPI::ReadingLightDriverSideRequest* request, ::UnityAPI::ReadingLightDriverSideReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ReadingLightDriverSideControl(::grpc::ClientContext* context, const ::UnityAPI::ReadingLightDriverSideRequest* request, ::UnityAPI::ReadingLightDriverSideReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ReadingLightDriverSideControl(::grpc::ClientContext* context, const ::UnityAPI::ReadingLightDriverSideRequest* request, ::UnityAPI::ReadingLightDriverSideReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ReadingLightPassgenerSideControl(::grpc::ClientContext* context, const ::UnityAPI::ReadingLightPassgenerSideRequest* request, ::UnityAPI::ReadingLightPassgenerSideReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ReadingLightPassgenerSideControl(::grpc::ClientContext* context, const ::UnityAPI::ReadingLightPassgenerSideRequest* request, ::UnityAPI::ReadingLightPassgenerSideReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ReadingLightPassgenerSideControl(::grpc::ClientContext* context, const ::UnityAPI::ReadingLightPassgenerSideRequest* request, ::UnityAPI::ReadingLightPassgenerSideReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void FrontRightPowerWindowsSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightPowerWindowsSwitchRequest* request, ::UnityAPI::FrontRightPowerWindowsSwitchReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void FrontRightPowerWindowsSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightPowerWindowsSwitchRequest* request, ::UnityAPI::FrontRightPowerWindowsSwitchReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void FrontRightPowerWindowsSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightPowerWindowsSwitchRequest* request, ::UnityAPI::FrontRightPowerWindowsSwitchReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void FrontLeftPowerWindowsSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftPowerWindowsSwitchRequest* request, ::UnityAPI::FrontLeftPowerWindowsSwitchReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void FrontLeftPowerWindowsSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftPowerWindowsSwitchRequest* request, ::UnityAPI::FrontLeftPowerWindowsSwitchReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void FrontLeftPowerWindowsSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftPowerWindowsSwitchRequest* request, ::UnityAPI::FrontLeftPowerWindowsSwitchReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void RearRightPowerWindowsSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightPowerWindowsSwitchRequest* request, ::UnityAPI::RearRightPowerWindowsSwitchReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void RearRightPowerWindowsSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightPowerWindowsSwitchRequest* request, ::UnityAPI::RearRightPowerWindowsSwitchReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void RearRightPowerWindowsSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightPowerWindowsSwitchRequest* request, ::UnityAPI::RearRightPowerWindowsSwitchReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void RearLeftPowerWindowsSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftPowerWindowsSwitchRequest* request, ::UnityAPI::RearLeftPowerWindowsSwitchReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void RearLeftPowerWindowsSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftPowerWindowsSwitchRequest* request, ::UnityAPI::RearLeftPowerWindowsSwitchReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void RearLeftPowerWindowsSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftPowerWindowsSwitchRequest* request, ::UnityAPI::RearLeftPowerWindowsSwitchReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void HornControl(::grpc::ClientContext* context, const ::UnityAPI::HornRequest* request, ::UnityAPI::HornReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void HornControl(::grpc::ClientContext* context, const ::UnityAPI::HornRequest* request, ::UnityAPI::HornReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void HornControl(::grpc::ClientContext* context, const ::UnityAPI::HornRequest* request, ::UnityAPI::HornReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void BuzzerControl(::grpc::ClientContext* context, const ::UnityAPI::BuzzerRequest* request, ::UnityAPI::BuzzerReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void BuzzerControl(::grpc::ClientContext* context, const ::UnityAPI::BuzzerRequest* request, ::UnityAPI::BuzzerReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void BuzzerControl(::grpc::ClientContext* context, const ::UnityAPI::BuzzerRequest* request, ::UnityAPI::BuzzerReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void AirConditionerControl(::grpc::ClientContext* context, const ::UnityAPI::AirConditionerRequest* request, ::UnityAPI::AirConditionerReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void AirConditionerControl(::grpc::ClientContext* context, const ::UnityAPI::AirConditionerRequest* request, ::UnityAPI::AirConditionerReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void AirConditionerControl(::grpc::ClientContext* context, const ::UnityAPI::AirConditionerRequest* request, ::UnityAPI::AirConditionerReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void AirConditionerTemperatureControl(::grpc::ClientContext* context, const ::UnityAPI::AirCondTemperatureRequest* request, ::UnityAPI::AirCondTemperatureReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void AirConditionerTemperatureControl(::grpc::ClientContext* context, const ::UnityAPI::AirCondTemperatureRequest* request, ::UnityAPI::AirCondTemperatureReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void AirConditionerTemperatureControl(::grpc::ClientContext* context, const ::UnityAPI::AirCondTemperatureRequest* request, ::UnityAPI::AirCondTemperatureReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void AirConditionerFanSpeedControl(::grpc::ClientContext* context, const ::UnityAPI::AirConditionerFanSpeedRequest* request, ::UnityAPI::AirConditionerFanSpeedReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void AirConditionerFanSpeedControl(::grpc::ClientContext* context, const ::UnityAPI::AirConditionerFanSpeedRequest* request, ::UnityAPI::AirConditionerFanSpeedReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void AirConditionerFanSpeedControl(::grpc::ClientContext* context, const ::UnityAPI::AirConditionerFanSpeedRequest* request, ::UnityAPI::AirConditionerFanSpeedReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void HandlingControl(::grpc::ClientContext* context, const ::UnityAPI::HandlingRequest* request, ::UnityAPI::HandlingReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void HandlingControl(::grpc::ClientContext* context, const ::UnityAPI::HandlingRequest* request, ::UnityAPI::HandlingReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void HandlingControl(::grpc::ClientContext* context, const ::UnityAPI::HandlingRequest* request, ::UnityAPI::HandlingReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void CentralDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::CentralDoorLockSwitchRequest* request, ::UnityAPI::CentralDoorLockSwitchReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void CentralDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::CentralDoorLockSwitchRequest* request, ::UnityAPI::CentralDoorLockSwitchReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void CentralDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::CentralDoorLockSwitchRequest* request, ::UnityAPI::CentralDoorLockSwitchReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void FrontRightDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightDoorLockSwitchRequest* request, ::UnityAPI::FrontRightDoorLockSwitchReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void FrontRightDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightDoorLockSwitchRequest* request, ::UnityAPI::FrontRightDoorLockSwitchReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void FrontRightDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::FrontRightDoorLockSwitchRequest* request, ::UnityAPI::FrontRightDoorLockSwitchReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void FrontLeftDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftDoorLockSwitchRequest* request, ::UnityAPI::FrontLeftDoorLockSwitchReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void FrontLeftDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftDoorLockSwitchRequest* request, ::UnityAPI::FrontLeftDoorLockSwitchReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void FrontLeftDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftDoorLockSwitchRequest* request, ::UnityAPI::FrontLeftDoorLockSwitchReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void RearRightDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightDoorLockSwitchRequest* request, ::UnityAPI::RearRightDoorLockSwitchReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void RearRightDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightDoorLockSwitchRequest* request, ::UnityAPI::RearRightDoorLockSwitchReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void RearRightDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::RearRightDoorLockSwitchRequest* request, ::UnityAPI::RearRightDoorLockSwitchReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void RearLeftDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftDoorLockSwitchRequest* request, ::UnityAPI::RearLeftDoorLockSwitchReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void RearLeftDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftDoorLockSwitchRequest* request, ::UnityAPI::RearLeftDoorLockSwitchReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void RearLeftDoorLockSwitchControl(::grpc::ClientContext* context, const ::UnityAPI::RearLeftDoorLockSwitchRequest* request, ::UnityAPI::RearLeftDoorLockSwitchReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void get_database(::grpc::ClientContext* context, const ::UnityAPI::getDBRequest* request, ::UnityAPI::getDBReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void get_database(::grpc::ClientContext* context, const ::UnityAPI::getDBRequest* request, ::UnityAPI::getDBReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void get_database(::grpc::ClientContext* context, const ::UnityAPI::getDBRequest* request, ::UnityAPI::getDBReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void send_update_database(::grpc::ClientContext* context, const ::UnityAPI::setDBRequest* request, ::UnityAPI::setDBReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void send_update_database(::grpc::ClientContext* context, const ::UnityAPI::setDBRequest* request, ::UnityAPI::setDBReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void send_update_database(::grpc::ClientContext* context, const ::UnityAPI::setDBRequest* request, ::UnityAPI::setDBReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontLowLightReply>* AsyncFrontLowLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontLowLightRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontLowLightReply>* PrepareAsyncFrontLowLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontLowLightRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontHighLightReply>* AsyncFrontHighLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontHighLightRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontHighLightReply>* PrepareAsyncFrontHighLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontHighLightRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearLightReply>* AsyncRearLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RearLightRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearLightReply>* PrepareAsyncRearLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RearLightRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontDaytimeLightReply>* AsyncFrontDaytimeLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontDaytimeLightRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontDaytimeLightReply>* PrepareAsyncFrontDaytimeLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontDaytimeLightRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::BrakeLightReply>* AsyncBrakeLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::BrakeLightRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::BrakeLightReply>* PrepareAsyncBrakeLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::BrakeLightRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::ReverseLightReply>* AsyncReverseLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::ReverseLightRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::ReverseLightReply>* PrepareAsyncReverseLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::ReverseLightRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontFogLightReply>* AsyncFrontFogLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontFogLightRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontFogLightReply>* PrepareAsyncFrontFogLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontFogLightRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearFogLightReply>* AsyncRearFogLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RearFogLightRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearFogLightReply>* PrepareAsyncRearFogLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RearFogLightRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::ClearanceLampReply>* AsyncClearanceLampControlRaw(::grpc::ClientContext* context, const ::UnityAPI::ClearanceLampRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::ClearanceLampReply>* PrepareAsyncClearanceLampControlRaw(::grpc::ClientContext* context, const ::UnityAPI::ClearanceLampRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontLeftBlinkerLightReply>* AsyncFrontLeftBlinkerLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftBlinkerLightRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontLeftBlinkerLightReply>* PrepareAsyncFrontLeftBlinkerLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftBlinkerLightRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontRightBlinkerLightReply>* AsyncFrontRightBlinkerLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontRightBlinkerLightRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontRightBlinkerLightReply>* PrepareAsyncFrontRightBlinkerLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontRightBlinkerLightRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearLeftBlinkerLightReply>* AsyncRearLeftBlinkerLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RearLeftBlinkerLightRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearLeftBlinkerLightReply>* PrepareAsyncRearLeftBlinkerLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RearLeftBlinkerLightRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearRightBlinkerLightReply>* AsyncRearRightBlinkerLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RearRightBlinkerLightRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearRightBlinkerLightReply>* PrepareAsyncRearRightBlinkerLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RearRightBlinkerLightRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontWiperReply>* AsyncFrontWiperControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontWiperRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontWiperReply>* PrepareAsyncFrontWiperControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontWiperRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearWiperReply>* AsyncRearWiperControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RearWiperRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearWiperReply>* PrepareAsyncRearWiperControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RearWiperRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::LeftSideMirrorReply>* AsyncLeftSideMirrorControlRaw(::grpc::ClientContext* context, const ::UnityAPI::LeftSideMirrorRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::LeftSideMirrorReply>* PrepareAsyncLeftSideMirrorControlRaw(::grpc::ClientContext* context, const ::UnityAPI::LeftSideMirrorRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::RightSideMirrorReply>* AsyncRightSideMirrorControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RightSideMirrorRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::RightSideMirrorReply>* PrepareAsyncRightSideMirrorControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RightSideMirrorRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontRightDoorReply>* AsyncFrontRightDoorControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontRightDoorRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontRightDoorReply>* PrepareAsyncFrontRightDoorControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontRightDoorRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontLeftDoorReply>* AsyncFrontLeftDoorControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftDoorRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontLeftDoorReply>* PrepareAsyncFrontLeftDoorControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftDoorRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearRightDoorReply>* AsyncRearRightDoorControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RearRightDoorRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearRightDoorReply>* PrepareAsyncRearRightDoorControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RearRightDoorRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearLeftDoorReply>* AsyncRearLeftDoorControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RearLeftDoorRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearLeftDoorReply>* PrepareAsyncRearLeftDoorControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RearLeftDoorRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::TrunkReply>* AsyncTrunkControlRaw(::grpc::ClientContext* context, const ::UnityAPI::TrunkRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::TrunkReply>* PrepareAsyncTrunkControlRaw(::grpc::ClientContext* context, const ::UnityAPI::TrunkRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::SunRoofReply>* AsyncSunRoofControlRaw(::grpc::ClientContext* context, const ::UnityAPI::SunRoofRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::SunRoofReply>* PrepareAsyncSunRoofControlRaw(::grpc::ClientContext* context, const ::UnityAPI::SunRoofRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontRightPowerWindowsReply>* AsyncFrontRightPowerWindowsControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontRightPowerWindowsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontRightPowerWindowsReply>* PrepareAsyncFrontRightPowerWindowsControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontRightPowerWindowsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontLeftPowerWindowsReply>* AsyncFrontLeftPowerWindowsControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftPowerWindowsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontLeftPowerWindowsReply>* PrepareAsyncFrontLeftPowerWindowsControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftPowerWindowsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearRightPowerWindowsReply>* AsyncRearRightPowerWindowsControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RearRightPowerWindowsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearRightPowerWindowsReply>* PrepareAsyncRearRightPowerWindowsControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RearRightPowerWindowsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearLeftPowerWindowsReply>* AsyncRearLeftPowerWindowsControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RearLeftPowerWindowsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearLeftPowerWindowsReply>* PrepareAsyncRearLeftPowerWindowsControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RearLeftPowerWindowsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::SideMirrorSwitchReply>* AsyncSideMirrorSwitchControlRaw(::grpc::ClientContext* context, const ::UnityAPI::SideMirrorSwitchRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::SideMirrorSwitchReply>* PrepareAsyncSideMirrorSwitchControlRaw(::grpc::ClientContext* context, const ::UnityAPI::SideMirrorSwitchRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::InstrumentLightReply>* AsyncInstrumentLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::InstrumentLightRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::InstrumentLightReply>* PrepareAsyncInstrumentLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::InstrumentLightRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::PassgenerRoomDomeLightReply>* AsyncPassgenerRoomDomeLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::PassgenerRoomDomeLightRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::PassgenerRoomDomeLightReply>* PrepareAsyncPassgenerRoomDomeLightControlRaw(::grpc::ClientContext* context, const ::UnityAPI::PassgenerRoomDomeLightRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::ReadingLightDriverSideReply>* AsyncReadingLightDriverSideControlRaw(::grpc::ClientContext* context, const ::UnityAPI::ReadingLightDriverSideRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::ReadingLightDriverSideReply>* PrepareAsyncReadingLightDriverSideControlRaw(::grpc::ClientContext* context, const ::UnityAPI::ReadingLightDriverSideRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::ReadingLightPassgenerSideReply>* AsyncReadingLightPassgenerSideControlRaw(::grpc::ClientContext* context, const ::UnityAPI::ReadingLightPassgenerSideRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::ReadingLightPassgenerSideReply>* PrepareAsyncReadingLightPassgenerSideControlRaw(::grpc::ClientContext* context, const ::UnityAPI::ReadingLightPassgenerSideRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontRightPowerWindowsSwitchReply>* AsyncFrontRightPowerWindowsSwitchControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontRightPowerWindowsSwitchRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontRightPowerWindowsSwitchReply>* PrepareAsyncFrontRightPowerWindowsSwitchControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontRightPowerWindowsSwitchRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontLeftPowerWindowsSwitchReply>* AsyncFrontLeftPowerWindowsSwitchControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftPowerWindowsSwitchRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontLeftPowerWindowsSwitchReply>* PrepareAsyncFrontLeftPowerWindowsSwitchControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftPowerWindowsSwitchRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearRightPowerWindowsSwitchReply>* AsyncRearRightPowerWindowsSwitchControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RearRightPowerWindowsSwitchRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearRightPowerWindowsSwitchReply>* PrepareAsyncRearRightPowerWindowsSwitchControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RearRightPowerWindowsSwitchRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearLeftPowerWindowsSwitchReply>* AsyncRearLeftPowerWindowsSwitchControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RearLeftPowerWindowsSwitchRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearLeftPowerWindowsSwitchReply>* PrepareAsyncRearLeftPowerWindowsSwitchControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RearLeftPowerWindowsSwitchRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::HornReply>* AsyncHornControlRaw(::grpc::ClientContext* context, const ::UnityAPI::HornRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::HornReply>* PrepareAsyncHornControlRaw(::grpc::ClientContext* context, const ::UnityAPI::HornRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::BuzzerReply>* AsyncBuzzerControlRaw(::grpc::ClientContext* context, const ::UnityAPI::BuzzerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::BuzzerReply>* PrepareAsyncBuzzerControlRaw(::grpc::ClientContext* context, const ::UnityAPI::BuzzerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::AirConditionerReply>* AsyncAirConditionerControlRaw(::grpc::ClientContext* context, const ::UnityAPI::AirConditionerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::AirConditionerReply>* PrepareAsyncAirConditionerControlRaw(::grpc::ClientContext* context, const ::UnityAPI::AirConditionerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::AirCondTemperatureReply>* AsyncAirConditionerTemperatureControlRaw(::grpc::ClientContext* context, const ::UnityAPI::AirCondTemperatureRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::AirCondTemperatureReply>* PrepareAsyncAirConditionerTemperatureControlRaw(::grpc::ClientContext* context, const ::UnityAPI::AirCondTemperatureRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::AirConditionerFanSpeedReply>* AsyncAirConditionerFanSpeedControlRaw(::grpc::ClientContext* context, const ::UnityAPI::AirConditionerFanSpeedRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::AirConditionerFanSpeedReply>* PrepareAsyncAirConditionerFanSpeedControlRaw(::grpc::ClientContext* context, const ::UnityAPI::AirConditionerFanSpeedRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::HandlingReply>* AsyncHandlingControlRaw(::grpc::ClientContext* context, const ::UnityAPI::HandlingRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::HandlingReply>* PrepareAsyncHandlingControlRaw(::grpc::ClientContext* context, const ::UnityAPI::HandlingRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::CentralDoorLockSwitchReply>* AsyncCentralDoorLockSwitchControlRaw(::grpc::ClientContext* context, const ::UnityAPI::CentralDoorLockSwitchRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::CentralDoorLockSwitchReply>* PrepareAsyncCentralDoorLockSwitchControlRaw(::grpc::ClientContext* context, const ::UnityAPI::CentralDoorLockSwitchRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontRightDoorLockSwitchReply>* AsyncFrontRightDoorLockSwitchControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontRightDoorLockSwitchRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontRightDoorLockSwitchReply>* PrepareAsyncFrontRightDoorLockSwitchControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontRightDoorLockSwitchRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontLeftDoorLockSwitchReply>* AsyncFrontLeftDoorLockSwitchControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftDoorLockSwitchRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::FrontLeftDoorLockSwitchReply>* PrepareAsyncFrontLeftDoorLockSwitchControlRaw(::grpc::ClientContext* context, const ::UnityAPI::FrontLeftDoorLockSwitchRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearRightDoorLockSwitchReply>* AsyncRearRightDoorLockSwitchControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RearRightDoorLockSwitchRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearRightDoorLockSwitchReply>* PrepareAsyncRearRightDoorLockSwitchControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RearRightDoorLockSwitchRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearLeftDoorLockSwitchReply>* AsyncRearLeftDoorLockSwitchControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RearLeftDoorLockSwitchRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::RearLeftDoorLockSwitchReply>* PrepareAsyncRearLeftDoorLockSwitchControlRaw(::grpc::ClientContext* context, const ::UnityAPI::RearLeftDoorLockSwitchRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::getDBReply>* Asyncget_databaseRaw(::grpc::ClientContext* context, const ::UnityAPI::getDBRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::getDBReply>* PrepareAsyncget_databaseRaw(::grpc::ClientContext* context, const ::UnityAPI::getDBRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::setDBReply>* Asyncsend_update_databaseRaw(::grpc::ClientContext* context, const ::UnityAPI::setDBRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UnityAPI::setDBReply>* PrepareAsyncsend_update_databaseRaw(::grpc::ClientContext* context, const ::UnityAPI::setDBRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_FrontLowLightControl_;
    const ::grpc::internal::RpcMethod rpcmethod_FrontHighLightControl_;
    const ::grpc::internal::RpcMethod rpcmethod_RearLightControl_;
    const ::grpc::internal::RpcMethod rpcmethod_FrontDaytimeLightControl_;
    const ::grpc::internal::RpcMethod rpcmethod_BrakeLightControl_;
    const ::grpc::internal::RpcMethod rpcmethod_ReverseLightControl_;
    const ::grpc::internal::RpcMethod rpcmethod_FrontFogLightControl_;
    const ::grpc::internal::RpcMethod rpcmethod_RearFogLightControl_;
    const ::grpc::internal::RpcMethod rpcmethod_ClearanceLampControl_;
    const ::grpc::internal::RpcMethod rpcmethod_FrontLeftBlinkerLightControl_;
    const ::grpc::internal::RpcMethod rpcmethod_FrontRightBlinkerLightControl_;
    const ::grpc::internal::RpcMethod rpcmethod_RearLeftBlinkerLightControl_;
    const ::grpc::internal::RpcMethod rpcmethod_RearRightBlinkerLightControl_;
    const ::grpc::internal::RpcMethod rpcmethod_FrontWiperControl_;
    const ::grpc::internal::RpcMethod rpcmethod_RearWiperControl_;
    const ::grpc::internal::RpcMethod rpcmethod_LeftSideMirrorControl_;
    const ::grpc::internal::RpcMethod rpcmethod_RightSideMirrorControl_;
    const ::grpc::internal::RpcMethod rpcmethod_FrontRightDoorControl_;
    const ::grpc::internal::RpcMethod rpcmethod_FrontLeftDoorControl_;
    const ::grpc::internal::RpcMethod rpcmethod_RearRightDoorControl_;
    const ::grpc::internal::RpcMethod rpcmethod_RearLeftDoorControl_;
    const ::grpc::internal::RpcMethod rpcmethod_TrunkControl_;
    const ::grpc::internal::RpcMethod rpcmethod_SunRoofControl_;
    const ::grpc::internal::RpcMethod rpcmethod_FrontRightPowerWindowsControl_;
    const ::grpc::internal::RpcMethod rpcmethod_FrontLeftPowerWindowsControl_;
    const ::grpc::internal::RpcMethod rpcmethod_RearRightPowerWindowsControl_;
    const ::grpc::internal::RpcMethod rpcmethod_RearLeftPowerWindowsControl_;
    const ::grpc::internal::RpcMethod rpcmethod_SideMirrorSwitchControl_;
    const ::grpc::internal::RpcMethod rpcmethod_InstrumentLightControl_;
    const ::grpc::internal::RpcMethod rpcmethod_PassgenerRoomDomeLightControl_;
    const ::grpc::internal::RpcMethod rpcmethod_ReadingLightDriverSideControl_;
    const ::grpc::internal::RpcMethod rpcmethod_ReadingLightPassgenerSideControl_;
    const ::grpc::internal::RpcMethod rpcmethod_FrontRightPowerWindowsSwitchControl_;
    const ::grpc::internal::RpcMethod rpcmethod_FrontLeftPowerWindowsSwitchControl_;
    const ::grpc::internal::RpcMethod rpcmethod_RearRightPowerWindowsSwitchControl_;
    const ::grpc::internal::RpcMethod rpcmethod_RearLeftPowerWindowsSwitchControl_;
    const ::grpc::internal::RpcMethod rpcmethod_HornControl_;
    const ::grpc::internal::RpcMethod rpcmethod_BuzzerControl_;
    const ::grpc::internal::RpcMethod rpcmethod_AirConditionerControl_;
    const ::grpc::internal::RpcMethod rpcmethod_AirConditionerTemperatureControl_;
    const ::grpc::internal::RpcMethod rpcmethod_AirConditionerFanSpeedControl_;
    const ::grpc::internal::RpcMethod rpcmethod_HandlingControl_;
    const ::grpc::internal::RpcMethod rpcmethod_CentralDoorLockSwitchControl_;
    const ::grpc::internal::RpcMethod rpcmethod_FrontRightDoorLockSwitchControl_;
    const ::grpc::internal::RpcMethod rpcmethod_FrontLeftDoorLockSwitchControl_;
    const ::grpc::internal::RpcMethod rpcmethod_RearRightDoorLockSwitchControl_;
    const ::grpc::internal::RpcMethod rpcmethod_RearLeftDoorLockSwitchControl_;
    const ::grpc::internal::RpcMethod rpcmethod_get_database_;
    const ::grpc::internal::RpcMethod rpcmethod_send_update_database_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status FrontLowLightControl(::grpc::ServerContext* context, const ::UnityAPI::FrontLowLightRequest* request, ::UnityAPI::FrontLowLightReply* response);
    virtual ::grpc::Status FrontHighLightControl(::grpc::ServerContext* context, const ::UnityAPI::FrontHighLightRequest* request, ::UnityAPI::FrontHighLightReply* response);
    virtual ::grpc::Status RearLightControl(::grpc::ServerContext* context, const ::UnityAPI::RearLightRequest* request, ::UnityAPI::RearLightReply* response);
    virtual ::grpc::Status FrontDaytimeLightControl(::grpc::ServerContext* context, const ::UnityAPI::FrontDaytimeLightRequest* request, ::UnityAPI::FrontDaytimeLightReply* response);
    virtual ::grpc::Status BrakeLightControl(::grpc::ServerContext* context, const ::UnityAPI::BrakeLightRequest* request, ::UnityAPI::BrakeLightReply* response);
    virtual ::grpc::Status ReverseLightControl(::grpc::ServerContext* context, const ::UnityAPI::ReverseLightRequest* request, ::UnityAPI::ReverseLightReply* response);
    virtual ::grpc::Status FrontFogLightControl(::grpc::ServerContext* context, const ::UnityAPI::FrontFogLightRequest* request, ::UnityAPI::FrontFogLightReply* response);
    virtual ::grpc::Status RearFogLightControl(::grpc::ServerContext* context, const ::UnityAPI::RearFogLightRequest* request, ::UnityAPI::RearFogLightReply* response);
    virtual ::grpc::Status ClearanceLampControl(::grpc::ServerContext* context, const ::UnityAPI::ClearanceLampRequest* request, ::UnityAPI::ClearanceLampReply* response);
    virtual ::grpc::Status FrontLeftBlinkerLightControl(::grpc::ServerContext* context, const ::UnityAPI::FrontLeftBlinkerLightRequest* request, ::UnityAPI::FrontLeftBlinkerLightReply* response);
    virtual ::grpc::Status FrontRightBlinkerLightControl(::grpc::ServerContext* context, const ::UnityAPI::FrontRightBlinkerLightRequest* request, ::UnityAPI::FrontRightBlinkerLightReply* response);
    virtual ::grpc::Status RearLeftBlinkerLightControl(::grpc::ServerContext* context, const ::UnityAPI::RearLeftBlinkerLightRequest* request, ::UnityAPI::RearLeftBlinkerLightReply* response);
    virtual ::grpc::Status RearRightBlinkerLightControl(::grpc::ServerContext* context, const ::UnityAPI::RearRightBlinkerLightRequest* request, ::UnityAPI::RearRightBlinkerLightReply* response);
    virtual ::grpc::Status FrontWiperControl(::grpc::ServerContext* context, const ::UnityAPI::FrontWiperRequest* request, ::UnityAPI::FrontWiperReply* response);
    virtual ::grpc::Status RearWiperControl(::grpc::ServerContext* context, const ::UnityAPI::RearWiperRequest* request, ::UnityAPI::RearWiperReply* response);
    virtual ::grpc::Status LeftSideMirrorControl(::grpc::ServerContext* context, const ::UnityAPI::LeftSideMirrorRequest* request, ::UnityAPI::LeftSideMirrorReply* response);
    virtual ::grpc::Status RightSideMirrorControl(::grpc::ServerContext* context, const ::UnityAPI::RightSideMirrorRequest* request, ::UnityAPI::RightSideMirrorReply* response);
    virtual ::grpc::Status FrontRightDoorControl(::grpc::ServerContext* context, const ::UnityAPI::FrontRightDoorRequest* request, ::UnityAPI::FrontRightDoorReply* response);
    virtual ::grpc::Status FrontLeftDoorControl(::grpc::ServerContext* context, const ::UnityAPI::FrontLeftDoorRequest* request, ::UnityAPI::FrontLeftDoorReply* response);
    virtual ::grpc::Status RearRightDoorControl(::grpc::ServerContext* context, const ::UnityAPI::RearRightDoorRequest* request, ::UnityAPI::RearRightDoorReply* response);
    virtual ::grpc::Status RearLeftDoorControl(::grpc::ServerContext* context, const ::UnityAPI::RearLeftDoorRequest* request, ::UnityAPI::RearLeftDoorReply* response);
    virtual ::grpc::Status TrunkControl(::grpc::ServerContext* context, const ::UnityAPI::TrunkRequest* request, ::UnityAPI::TrunkReply* response);
    virtual ::grpc::Status SunRoofControl(::grpc::ServerContext* context, const ::UnityAPI::SunRoofRequest* request, ::UnityAPI::SunRoofReply* response);
    virtual ::grpc::Status FrontRightPowerWindowsControl(::grpc::ServerContext* context, const ::UnityAPI::FrontRightPowerWindowsRequest* request, ::UnityAPI::FrontRightPowerWindowsReply* response);
    virtual ::grpc::Status FrontLeftPowerWindowsControl(::grpc::ServerContext* context, const ::UnityAPI::FrontLeftPowerWindowsRequest* request, ::UnityAPI::FrontLeftPowerWindowsReply* response);
    virtual ::grpc::Status RearRightPowerWindowsControl(::grpc::ServerContext* context, const ::UnityAPI::RearRightPowerWindowsRequest* request, ::UnityAPI::RearRightPowerWindowsReply* response);
    virtual ::grpc::Status RearLeftPowerWindowsControl(::grpc::ServerContext* context, const ::UnityAPI::RearLeftPowerWindowsRequest* request, ::UnityAPI::RearLeftPowerWindowsReply* response);
    virtual ::grpc::Status SideMirrorSwitchControl(::grpc::ServerContext* context, const ::UnityAPI::SideMirrorSwitchRequest* request, ::UnityAPI::SideMirrorSwitchReply* response);
    virtual ::grpc::Status InstrumentLightControl(::grpc::ServerContext* context, const ::UnityAPI::InstrumentLightRequest* request, ::UnityAPI::InstrumentLightReply* response);
    virtual ::grpc::Status PassgenerRoomDomeLightControl(::grpc::ServerContext* context, const ::UnityAPI::PassgenerRoomDomeLightRequest* request, ::UnityAPI::PassgenerRoomDomeLightReply* response);
    virtual ::grpc::Status ReadingLightDriverSideControl(::grpc::ServerContext* context, const ::UnityAPI::ReadingLightDriverSideRequest* request, ::UnityAPI::ReadingLightDriverSideReply* response);
    virtual ::grpc::Status ReadingLightPassgenerSideControl(::grpc::ServerContext* context, const ::UnityAPI::ReadingLightPassgenerSideRequest* request, ::UnityAPI::ReadingLightPassgenerSideReply* response);
    virtual ::grpc::Status FrontRightPowerWindowsSwitchControl(::grpc::ServerContext* context, const ::UnityAPI::FrontRightPowerWindowsSwitchRequest* request, ::UnityAPI::FrontRightPowerWindowsSwitchReply* response);
    virtual ::grpc::Status FrontLeftPowerWindowsSwitchControl(::grpc::ServerContext* context, const ::UnityAPI::FrontLeftPowerWindowsSwitchRequest* request, ::UnityAPI::FrontLeftPowerWindowsSwitchReply* response);
    virtual ::grpc::Status RearRightPowerWindowsSwitchControl(::grpc::ServerContext* context, const ::UnityAPI::RearRightPowerWindowsSwitchRequest* request, ::UnityAPI::RearRightPowerWindowsSwitchReply* response);
    virtual ::grpc::Status RearLeftPowerWindowsSwitchControl(::grpc::ServerContext* context, const ::UnityAPI::RearLeftPowerWindowsSwitchRequest* request, ::UnityAPI::RearLeftPowerWindowsSwitchReply* response);
    virtual ::grpc::Status HornControl(::grpc::ServerContext* context, const ::UnityAPI::HornRequest* request, ::UnityAPI::HornReply* response);
    virtual ::grpc::Status BuzzerControl(::grpc::ServerContext* context, const ::UnityAPI::BuzzerRequest* request, ::UnityAPI::BuzzerReply* response);
    virtual ::grpc::Status AirConditionerControl(::grpc::ServerContext* context, const ::UnityAPI::AirConditionerRequest* request, ::UnityAPI::AirConditionerReply* response);
    virtual ::grpc::Status AirConditionerTemperatureControl(::grpc::ServerContext* context, const ::UnityAPI::AirCondTemperatureRequest* request, ::UnityAPI::AirCondTemperatureReply* response);
    virtual ::grpc::Status AirConditionerFanSpeedControl(::grpc::ServerContext* context, const ::UnityAPI::AirConditionerFanSpeedRequest* request, ::UnityAPI::AirConditionerFanSpeedReply* response);
    virtual ::grpc::Status HandlingControl(::grpc::ServerContext* context, const ::UnityAPI::HandlingRequest* request, ::UnityAPI::HandlingReply* response);
    virtual ::grpc::Status CentralDoorLockSwitchControl(::grpc::ServerContext* context, const ::UnityAPI::CentralDoorLockSwitchRequest* request, ::UnityAPI::CentralDoorLockSwitchReply* response);
    virtual ::grpc::Status FrontRightDoorLockSwitchControl(::grpc::ServerContext* context, const ::UnityAPI::FrontRightDoorLockSwitchRequest* request, ::UnityAPI::FrontRightDoorLockSwitchReply* response);
    virtual ::grpc::Status FrontLeftDoorLockSwitchControl(::grpc::ServerContext* context, const ::UnityAPI::FrontLeftDoorLockSwitchRequest* request, ::UnityAPI::FrontLeftDoorLockSwitchReply* response);
    virtual ::grpc::Status RearRightDoorLockSwitchControl(::grpc::ServerContext* context, const ::UnityAPI::RearRightDoorLockSwitchRequest* request, ::UnityAPI::RearRightDoorLockSwitchReply* response);
    virtual ::grpc::Status RearLeftDoorLockSwitchControl(::grpc::ServerContext* context, const ::UnityAPI::RearLeftDoorLockSwitchRequest* request, ::UnityAPI::RearLeftDoorLockSwitchReply* response);
    virtual ::grpc::Status get_database(::grpc::ServerContext* context, const ::UnityAPI::getDBRequest* request, ::UnityAPI::getDBReply* response);
    virtual ::grpc::Status send_update_database(::grpc::ServerContext* context, const ::UnityAPI::setDBRequest* request, ::UnityAPI::setDBReply* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_FrontLowLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_FrontLowLightControl() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_FrontLowLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontLowLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontLowLightRequest* /*request*/, ::UnityAPI::FrontLowLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFrontLowLightControl(::grpc::ServerContext* context, ::UnityAPI::FrontLowLightRequest* request, ::grpc::ServerAsyncResponseWriter< ::UnityAPI::FrontLowLightReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_FrontHighLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_FrontHighLightControl() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_FrontHighLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontHighLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontHighLightRequest* /*request*/, ::UnityAPI::FrontHighLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFrontHighLightControl(::grpc::ServerContext* context, ::UnityAPI::FrontHighLightRequest* request, ::grpc::ServerAsyncResponseWriter< ::UnityAPI::FrontHighLightReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RearLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RearLightControl() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_RearLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearLightRequest* /*request*/, ::UnityAPI::RearLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRearLightControl(::grpc::ServerContext* context, ::UnityAPI::RearLightRequest* request, ::grpc::ServerAsyncResponseWriter< ::UnityAPI::RearLightReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_FrontDaytimeLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_FrontDaytimeLightControl() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_FrontDaytimeLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontDaytimeLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontDaytimeLightRequest* /*request*/, ::UnityAPI::FrontDaytimeLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFrontDaytimeLightControl(::grpc::ServerContext* context, ::UnityAPI::FrontDaytimeLightRequest* request, ::grpc::ServerAsyncResponseWriter< ::UnityAPI::FrontDaytimeLightReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_BrakeLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_BrakeLightControl() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_BrakeLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BrakeLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::BrakeLightRequest* /*request*/, ::UnityAPI::BrakeLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBrakeLightControl(::grpc::ServerContext* context, ::UnityAPI::BrakeLightRequest* request, ::grpc::ServerAsyncResponseWriter< ::UnityAPI::BrakeLightReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ReverseLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ReverseLightControl() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_ReverseLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReverseLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::ReverseLightRequest* /*request*/, ::UnityAPI::ReverseLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReverseLightControl(::grpc::ServerContext* context, ::UnityAPI::ReverseLightRequest* request, ::grpc::ServerAsyncResponseWriter< ::UnityAPI::ReverseLightReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_FrontFogLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_FrontFogLightControl() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_FrontFogLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontFogLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontFogLightRequest* /*request*/, ::UnityAPI::FrontFogLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFrontFogLightControl(::grpc::ServerContext* context, ::UnityAPI::FrontFogLightRequest* request, ::grpc::ServerAsyncResponseWriter< ::UnityAPI::FrontFogLightReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RearFogLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RearFogLightControl() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_RearFogLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearFogLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearFogLightRequest* /*request*/, ::UnityAPI::RearFogLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRearFogLightControl(::grpc::ServerContext* context, ::UnityAPI::RearFogLightRequest* request, ::grpc::ServerAsyncResponseWriter< ::UnityAPI::RearFogLightReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ClearanceLampControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ClearanceLampControl() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_ClearanceLampControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClearanceLampControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::ClearanceLampRequest* /*request*/, ::UnityAPI::ClearanceLampReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestClearanceLampControl(::grpc::ServerContext* context, ::UnityAPI::ClearanceLampRequest* request, ::grpc::ServerAsyncResponseWriter< ::UnityAPI::ClearanceLampReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_FrontLeftBlinkerLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_FrontLeftBlinkerLightControl() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_FrontLeftBlinkerLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontLeftBlinkerLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontLeftBlinkerLightRequest* /*request*/, ::UnityAPI::FrontLeftBlinkerLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFrontLeftBlinkerLightControl(::grpc::ServerContext* context, ::UnityAPI::FrontLeftBlinkerLightRequest* request, ::grpc::ServerAsyncResponseWriter< ::UnityAPI::FrontLeftBlinkerLightReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_FrontRightBlinkerLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_FrontRightBlinkerLightControl() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_FrontRightBlinkerLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontRightBlinkerLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontRightBlinkerLightRequest* /*request*/, ::UnityAPI::FrontRightBlinkerLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFrontRightBlinkerLightControl(::grpc::ServerContext* context, ::UnityAPI::FrontRightBlinkerLightRequest* request, ::grpc::ServerAsyncResponseWriter< ::UnityAPI::FrontRightBlinkerLightReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RearLeftBlinkerLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RearLeftBlinkerLightControl() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_RearLeftBlinkerLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearLeftBlinkerLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearLeftBlinkerLightRequest* /*request*/, ::UnityAPI::RearLeftBlinkerLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRearLeftBlinkerLightControl(::grpc::ServerContext* context, ::UnityAPI::RearLeftBlinkerLightRequest* request, ::grpc::ServerAsyncResponseWriter< ::UnityAPI::RearLeftBlinkerLightReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RearRightBlinkerLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RearRightBlinkerLightControl() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_RearRightBlinkerLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearRightBlinkerLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearRightBlinkerLightRequest* /*request*/, ::UnityAPI::RearRightBlinkerLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRearRightBlinkerLightControl(::grpc::ServerContext* context, ::UnityAPI::RearRightBlinkerLightRequest* request, ::grpc::ServerAsyncResponseWriter< ::UnityAPI::RearRightBlinkerLightReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_FrontWiperControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_FrontWiperControl() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_FrontWiperControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontWiperControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontWiperRequest* /*request*/, ::UnityAPI::FrontWiperReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFrontWiperControl(::grpc::ServerContext* context, ::UnityAPI::FrontWiperRequest* request, ::grpc::ServerAsyncResponseWriter< ::UnityAPI::FrontWiperReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RearWiperControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RearWiperControl() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_RearWiperControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearWiperControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearWiperRequest* /*request*/, ::UnityAPI::RearWiperReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRearWiperControl(::grpc::ServerContext* context, ::UnityAPI::RearWiperRequest* request, ::grpc::ServerAsyncResponseWriter< ::UnityAPI::RearWiperReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LeftSideMirrorControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LeftSideMirrorControl() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_LeftSideMirrorControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeftSideMirrorControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::LeftSideMirrorRequest* /*request*/, ::UnityAPI::LeftSideMirrorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLeftSideMirrorControl(::grpc::ServerContext* context, ::UnityAPI::LeftSideMirrorRequest* request, ::grpc::ServerAsyncResponseWriter< ::UnityAPI::LeftSideMirrorReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RightSideMirrorControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RightSideMirrorControl() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_RightSideMirrorControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RightSideMirrorControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RightSideMirrorRequest* /*request*/, ::UnityAPI::RightSideMirrorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRightSideMirrorControl(::grpc::ServerContext* context, ::UnityAPI::RightSideMirrorRequest* request, ::grpc::ServerAsyncResponseWriter< ::UnityAPI::RightSideMirrorReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_FrontRightDoorControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_FrontRightDoorControl() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_FrontRightDoorControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontRightDoorControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontRightDoorRequest* /*request*/, ::UnityAPI::FrontRightDoorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFrontRightDoorControl(::grpc::ServerContext* context, ::UnityAPI::FrontRightDoorRequest* request, ::grpc::ServerAsyncResponseWriter< ::UnityAPI::FrontRightDoorReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_FrontLeftDoorControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_FrontLeftDoorControl() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_FrontLeftDoorControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontLeftDoorControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontLeftDoorRequest* /*request*/, ::UnityAPI::FrontLeftDoorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFrontLeftDoorControl(::grpc::ServerContext* context, ::UnityAPI::FrontLeftDoorRequest* request, ::grpc::ServerAsyncResponseWriter< ::UnityAPI::FrontLeftDoorReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RearRightDoorControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RearRightDoorControl() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_RearRightDoorControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearRightDoorControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearRightDoorRequest* /*request*/, ::UnityAPI::RearRightDoorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRearRightDoorControl(::grpc::ServerContext* context, ::UnityAPI::RearRightDoorRequest* request, ::grpc::ServerAsyncResponseWriter< ::UnityAPI::RearRightDoorReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RearLeftDoorControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RearLeftDoorControl() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_RearLeftDoorControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearLeftDoorControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearLeftDoorRequest* /*request*/, ::UnityAPI::RearLeftDoorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRearLeftDoorControl(::grpc::ServerContext* context, ::UnityAPI::RearLeftDoorRequest* request, ::grpc::ServerAsyncResponseWriter< ::UnityAPI::RearLeftDoorReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_TrunkControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_TrunkControl() {
      ::grpc::Service::MarkMethodAsync(21);
    }
    ~WithAsyncMethod_TrunkControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TrunkControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::TrunkRequest* /*request*/, ::UnityAPI::TrunkReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTrunkControl(::grpc::ServerContext* context, ::UnityAPI::TrunkRequest* request, ::grpc::ServerAsyncResponseWriter< ::UnityAPI::TrunkReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SunRoofControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SunRoofControl() {
      ::grpc::Service::MarkMethodAsync(22);
    }
    ~WithAsyncMethod_SunRoofControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SunRoofControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::SunRoofRequest* /*request*/, ::UnityAPI::SunRoofReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSunRoofControl(::grpc::ServerContext* context, ::UnityAPI::SunRoofRequest* request, ::grpc::ServerAsyncResponseWriter< ::UnityAPI::SunRoofReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_FrontRightPowerWindowsControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_FrontRightPowerWindowsControl() {
      ::grpc::Service::MarkMethodAsync(23);
    }
    ~WithAsyncMethod_FrontRightPowerWindowsControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontRightPowerWindowsControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontRightPowerWindowsRequest* /*request*/, ::UnityAPI::FrontRightPowerWindowsReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFrontRightPowerWindowsControl(::grpc::ServerContext* context, ::UnityAPI::FrontRightPowerWindowsRequest* request, ::grpc::ServerAsyncResponseWriter< ::UnityAPI::FrontRightPowerWindowsReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_FrontLeftPowerWindowsControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_FrontLeftPowerWindowsControl() {
      ::grpc::Service::MarkMethodAsync(24);
    }
    ~WithAsyncMethod_FrontLeftPowerWindowsControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontLeftPowerWindowsControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontLeftPowerWindowsRequest* /*request*/, ::UnityAPI::FrontLeftPowerWindowsReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFrontLeftPowerWindowsControl(::grpc::ServerContext* context, ::UnityAPI::FrontLeftPowerWindowsRequest* request, ::grpc::ServerAsyncResponseWriter< ::UnityAPI::FrontLeftPowerWindowsReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RearRightPowerWindowsControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RearRightPowerWindowsControl() {
      ::grpc::Service::MarkMethodAsync(25);
    }
    ~WithAsyncMethod_RearRightPowerWindowsControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearRightPowerWindowsControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearRightPowerWindowsRequest* /*request*/, ::UnityAPI::RearRightPowerWindowsReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRearRightPowerWindowsControl(::grpc::ServerContext* context, ::UnityAPI::RearRightPowerWindowsRequest* request, ::grpc::ServerAsyncResponseWriter< ::UnityAPI::RearRightPowerWindowsReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RearLeftPowerWindowsControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RearLeftPowerWindowsControl() {
      ::grpc::Service::MarkMethodAsync(26);
    }
    ~WithAsyncMethod_RearLeftPowerWindowsControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearLeftPowerWindowsControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearLeftPowerWindowsRequest* /*request*/, ::UnityAPI::RearLeftPowerWindowsReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRearLeftPowerWindowsControl(::grpc::ServerContext* context, ::UnityAPI::RearLeftPowerWindowsRequest* request, ::grpc::ServerAsyncResponseWriter< ::UnityAPI::RearLeftPowerWindowsReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SideMirrorSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SideMirrorSwitchControl() {
      ::grpc::Service::MarkMethodAsync(27);
    }
    ~WithAsyncMethod_SideMirrorSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SideMirrorSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::SideMirrorSwitchRequest* /*request*/, ::UnityAPI::SideMirrorSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSideMirrorSwitchControl(::grpc::ServerContext* context, ::UnityAPI::SideMirrorSwitchRequest* request, ::grpc::ServerAsyncResponseWriter< ::UnityAPI::SideMirrorSwitchReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_InstrumentLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_InstrumentLightControl() {
      ::grpc::Service::MarkMethodAsync(28);
    }
    ~WithAsyncMethod_InstrumentLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InstrumentLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::InstrumentLightRequest* /*request*/, ::UnityAPI::InstrumentLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestInstrumentLightControl(::grpc::ServerContext* context, ::UnityAPI::InstrumentLightRequest* request, ::grpc::ServerAsyncResponseWriter< ::UnityAPI::InstrumentLightReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PassgenerRoomDomeLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PassgenerRoomDomeLightControl() {
      ::grpc::Service::MarkMethodAsync(29);
    }
    ~WithAsyncMethod_PassgenerRoomDomeLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PassgenerRoomDomeLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::PassgenerRoomDomeLightRequest* /*request*/, ::UnityAPI::PassgenerRoomDomeLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPassgenerRoomDomeLightControl(::grpc::ServerContext* context, ::UnityAPI::PassgenerRoomDomeLightRequest* request, ::grpc::ServerAsyncResponseWriter< ::UnityAPI::PassgenerRoomDomeLightReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(29, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ReadingLightDriverSideControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ReadingLightDriverSideControl() {
      ::grpc::Service::MarkMethodAsync(30);
    }
    ~WithAsyncMethod_ReadingLightDriverSideControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadingLightDriverSideControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::ReadingLightDriverSideRequest* /*request*/, ::UnityAPI::ReadingLightDriverSideReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReadingLightDriverSideControl(::grpc::ServerContext* context, ::UnityAPI::ReadingLightDriverSideRequest* request, ::grpc::ServerAsyncResponseWriter< ::UnityAPI::ReadingLightDriverSideReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(30, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ReadingLightPassgenerSideControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ReadingLightPassgenerSideControl() {
      ::grpc::Service::MarkMethodAsync(31);
    }
    ~WithAsyncMethod_ReadingLightPassgenerSideControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadingLightPassgenerSideControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::ReadingLightPassgenerSideRequest* /*request*/, ::UnityAPI::ReadingLightPassgenerSideReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReadingLightPassgenerSideControl(::grpc::ServerContext* context, ::UnityAPI::ReadingLightPassgenerSideRequest* request, ::grpc::ServerAsyncResponseWriter< ::UnityAPI::ReadingLightPassgenerSideReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(31, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_FrontRightPowerWindowsSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_FrontRightPowerWindowsSwitchControl() {
      ::grpc::Service::MarkMethodAsync(32);
    }
    ~WithAsyncMethod_FrontRightPowerWindowsSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontRightPowerWindowsSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontRightPowerWindowsSwitchRequest* /*request*/, ::UnityAPI::FrontRightPowerWindowsSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFrontRightPowerWindowsSwitchControl(::grpc::ServerContext* context, ::UnityAPI::FrontRightPowerWindowsSwitchRequest* request, ::grpc::ServerAsyncResponseWriter< ::UnityAPI::FrontRightPowerWindowsSwitchReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(32, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_FrontLeftPowerWindowsSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_FrontLeftPowerWindowsSwitchControl() {
      ::grpc::Service::MarkMethodAsync(33);
    }
    ~WithAsyncMethod_FrontLeftPowerWindowsSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontLeftPowerWindowsSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontLeftPowerWindowsSwitchRequest* /*request*/, ::UnityAPI::FrontLeftPowerWindowsSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFrontLeftPowerWindowsSwitchControl(::grpc::ServerContext* context, ::UnityAPI::FrontLeftPowerWindowsSwitchRequest* request, ::grpc::ServerAsyncResponseWriter< ::UnityAPI::FrontLeftPowerWindowsSwitchReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(33, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RearRightPowerWindowsSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RearRightPowerWindowsSwitchControl() {
      ::grpc::Service::MarkMethodAsync(34);
    }
    ~WithAsyncMethod_RearRightPowerWindowsSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearRightPowerWindowsSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearRightPowerWindowsSwitchRequest* /*request*/, ::UnityAPI::RearRightPowerWindowsSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRearRightPowerWindowsSwitchControl(::grpc::ServerContext* context, ::UnityAPI::RearRightPowerWindowsSwitchRequest* request, ::grpc::ServerAsyncResponseWriter< ::UnityAPI::RearRightPowerWindowsSwitchReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(34, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RearLeftPowerWindowsSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RearLeftPowerWindowsSwitchControl() {
      ::grpc::Service::MarkMethodAsync(35);
    }
    ~WithAsyncMethod_RearLeftPowerWindowsSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearLeftPowerWindowsSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearLeftPowerWindowsSwitchRequest* /*request*/, ::UnityAPI::RearLeftPowerWindowsSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRearLeftPowerWindowsSwitchControl(::grpc::ServerContext* context, ::UnityAPI::RearLeftPowerWindowsSwitchRequest* request, ::grpc::ServerAsyncResponseWriter< ::UnityAPI::RearLeftPowerWindowsSwitchReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(35, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_HornControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_HornControl() {
      ::grpc::Service::MarkMethodAsync(36);
    }
    ~WithAsyncMethod_HornControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HornControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::HornRequest* /*request*/, ::UnityAPI::HornReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHornControl(::grpc::ServerContext* context, ::UnityAPI::HornRequest* request, ::grpc::ServerAsyncResponseWriter< ::UnityAPI::HornReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(36, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_BuzzerControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_BuzzerControl() {
      ::grpc::Service::MarkMethodAsync(37);
    }
    ~WithAsyncMethod_BuzzerControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BuzzerControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::BuzzerRequest* /*request*/, ::UnityAPI::BuzzerReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBuzzerControl(::grpc::ServerContext* context, ::UnityAPI::BuzzerRequest* request, ::grpc::ServerAsyncResponseWriter< ::UnityAPI::BuzzerReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(37, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AirConditionerControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AirConditionerControl() {
      ::grpc::Service::MarkMethodAsync(38);
    }
    ~WithAsyncMethod_AirConditionerControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AirConditionerControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::AirConditionerRequest* /*request*/, ::UnityAPI::AirConditionerReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAirConditionerControl(::grpc::ServerContext* context, ::UnityAPI::AirConditionerRequest* request, ::grpc::ServerAsyncResponseWriter< ::UnityAPI::AirConditionerReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(38, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AirConditionerTemperatureControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AirConditionerTemperatureControl() {
      ::grpc::Service::MarkMethodAsync(39);
    }
    ~WithAsyncMethod_AirConditionerTemperatureControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AirConditionerTemperatureControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::AirCondTemperatureRequest* /*request*/, ::UnityAPI::AirCondTemperatureReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAirConditionerTemperatureControl(::grpc::ServerContext* context, ::UnityAPI::AirCondTemperatureRequest* request, ::grpc::ServerAsyncResponseWriter< ::UnityAPI::AirCondTemperatureReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(39, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AirConditionerFanSpeedControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AirConditionerFanSpeedControl() {
      ::grpc::Service::MarkMethodAsync(40);
    }
    ~WithAsyncMethod_AirConditionerFanSpeedControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AirConditionerFanSpeedControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::AirConditionerFanSpeedRequest* /*request*/, ::UnityAPI::AirConditionerFanSpeedReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAirConditionerFanSpeedControl(::grpc::ServerContext* context, ::UnityAPI::AirConditionerFanSpeedRequest* request, ::grpc::ServerAsyncResponseWriter< ::UnityAPI::AirConditionerFanSpeedReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(40, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_HandlingControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_HandlingControl() {
      ::grpc::Service::MarkMethodAsync(41);
    }
    ~WithAsyncMethod_HandlingControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HandlingControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::HandlingRequest* /*request*/, ::UnityAPI::HandlingReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHandlingControl(::grpc::ServerContext* context, ::UnityAPI::HandlingRequest* request, ::grpc::ServerAsyncResponseWriter< ::UnityAPI::HandlingReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(41, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CentralDoorLockSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CentralDoorLockSwitchControl() {
      ::grpc::Service::MarkMethodAsync(42);
    }
    ~WithAsyncMethod_CentralDoorLockSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CentralDoorLockSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::CentralDoorLockSwitchRequest* /*request*/, ::UnityAPI::CentralDoorLockSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCentralDoorLockSwitchControl(::grpc::ServerContext* context, ::UnityAPI::CentralDoorLockSwitchRequest* request, ::grpc::ServerAsyncResponseWriter< ::UnityAPI::CentralDoorLockSwitchReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(42, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_FrontRightDoorLockSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_FrontRightDoorLockSwitchControl() {
      ::grpc::Service::MarkMethodAsync(43);
    }
    ~WithAsyncMethod_FrontRightDoorLockSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontRightDoorLockSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontRightDoorLockSwitchRequest* /*request*/, ::UnityAPI::FrontRightDoorLockSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFrontRightDoorLockSwitchControl(::grpc::ServerContext* context, ::UnityAPI::FrontRightDoorLockSwitchRequest* request, ::grpc::ServerAsyncResponseWriter< ::UnityAPI::FrontRightDoorLockSwitchReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(43, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_FrontLeftDoorLockSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_FrontLeftDoorLockSwitchControl() {
      ::grpc::Service::MarkMethodAsync(44);
    }
    ~WithAsyncMethod_FrontLeftDoorLockSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontLeftDoorLockSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontLeftDoorLockSwitchRequest* /*request*/, ::UnityAPI::FrontLeftDoorLockSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFrontLeftDoorLockSwitchControl(::grpc::ServerContext* context, ::UnityAPI::FrontLeftDoorLockSwitchRequest* request, ::grpc::ServerAsyncResponseWriter< ::UnityAPI::FrontLeftDoorLockSwitchReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(44, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RearRightDoorLockSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RearRightDoorLockSwitchControl() {
      ::grpc::Service::MarkMethodAsync(45);
    }
    ~WithAsyncMethod_RearRightDoorLockSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearRightDoorLockSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearRightDoorLockSwitchRequest* /*request*/, ::UnityAPI::RearRightDoorLockSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRearRightDoorLockSwitchControl(::grpc::ServerContext* context, ::UnityAPI::RearRightDoorLockSwitchRequest* request, ::grpc::ServerAsyncResponseWriter< ::UnityAPI::RearRightDoorLockSwitchReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(45, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RearLeftDoorLockSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RearLeftDoorLockSwitchControl() {
      ::grpc::Service::MarkMethodAsync(46);
    }
    ~WithAsyncMethod_RearLeftDoorLockSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearLeftDoorLockSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearLeftDoorLockSwitchRequest* /*request*/, ::UnityAPI::RearLeftDoorLockSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRearLeftDoorLockSwitchControl(::grpc::ServerContext* context, ::UnityAPI::RearLeftDoorLockSwitchRequest* request, ::grpc::ServerAsyncResponseWriter< ::UnityAPI::RearLeftDoorLockSwitchReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(46, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_database : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_database() {
      ::grpc::Service::MarkMethodAsync(47);
    }
    ~WithAsyncMethod_get_database() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_database(::grpc::ServerContext* /*context*/, const ::UnityAPI::getDBRequest* /*request*/, ::UnityAPI::getDBReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_database(::grpc::ServerContext* context, ::UnityAPI::getDBRequest* request, ::grpc::ServerAsyncResponseWriter< ::UnityAPI::getDBReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(47, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_send_update_database : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_send_update_database() {
      ::grpc::Service::MarkMethodAsync(48);
    }
    ~WithAsyncMethod_send_update_database() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status send_update_database(::grpc::ServerContext* /*context*/, const ::UnityAPI::setDBRequest* /*request*/, ::UnityAPI::setDBReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestsend_update_database(::grpc::ServerContext* context, ::UnityAPI::setDBRequest* request, ::grpc::ServerAsyncResponseWriter< ::UnityAPI::setDBReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(48, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_FrontLowLightControl<WithAsyncMethod_FrontHighLightControl<WithAsyncMethod_RearLightControl<WithAsyncMethod_FrontDaytimeLightControl<WithAsyncMethod_BrakeLightControl<WithAsyncMethod_ReverseLightControl<WithAsyncMethod_FrontFogLightControl<WithAsyncMethod_RearFogLightControl<WithAsyncMethod_ClearanceLampControl<WithAsyncMethod_FrontLeftBlinkerLightControl<WithAsyncMethod_FrontRightBlinkerLightControl<WithAsyncMethod_RearLeftBlinkerLightControl<WithAsyncMethod_RearRightBlinkerLightControl<WithAsyncMethod_FrontWiperControl<WithAsyncMethod_RearWiperControl<WithAsyncMethod_LeftSideMirrorControl<WithAsyncMethod_RightSideMirrorControl<WithAsyncMethod_FrontRightDoorControl<WithAsyncMethod_FrontLeftDoorControl<WithAsyncMethod_RearRightDoorControl<WithAsyncMethod_RearLeftDoorControl<WithAsyncMethod_TrunkControl<WithAsyncMethod_SunRoofControl<WithAsyncMethod_FrontRightPowerWindowsControl<WithAsyncMethod_FrontLeftPowerWindowsControl<WithAsyncMethod_RearRightPowerWindowsControl<WithAsyncMethod_RearLeftPowerWindowsControl<WithAsyncMethod_SideMirrorSwitchControl<WithAsyncMethod_InstrumentLightControl<WithAsyncMethod_PassgenerRoomDomeLightControl<WithAsyncMethod_ReadingLightDriverSideControl<WithAsyncMethod_ReadingLightPassgenerSideControl<WithAsyncMethod_FrontRightPowerWindowsSwitchControl<WithAsyncMethod_FrontLeftPowerWindowsSwitchControl<WithAsyncMethod_RearRightPowerWindowsSwitchControl<WithAsyncMethod_RearLeftPowerWindowsSwitchControl<WithAsyncMethod_HornControl<WithAsyncMethod_BuzzerControl<WithAsyncMethod_AirConditionerControl<WithAsyncMethod_AirConditionerTemperatureControl<WithAsyncMethod_AirConditionerFanSpeedControl<WithAsyncMethod_HandlingControl<WithAsyncMethod_CentralDoorLockSwitchControl<WithAsyncMethod_FrontRightDoorLockSwitchControl<WithAsyncMethod_FrontLeftDoorLockSwitchControl<WithAsyncMethod_RearRightDoorLockSwitchControl<WithAsyncMethod_RearLeftDoorLockSwitchControl<WithAsyncMethod_get_database<WithAsyncMethod_send_update_database<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_FrontLowLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_FrontLowLightControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::UnityAPI::FrontLowLightRequest, ::UnityAPI::FrontLowLightReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::UnityAPI::FrontLowLightRequest* request, ::UnityAPI::FrontLowLightReply* response) { return this->FrontLowLightControl(context, request, response); }));}
    void SetMessageAllocatorFor_FrontLowLightControl(
        ::grpc::experimental::MessageAllocator< ::UnityAPI::FrontLowLightRequest, ::UnityAPI::FrontLowLightReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::UnityAPI::FrontLowLightRequest, ::UnityAPI::FrontLowLightReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_FrontLowLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontLowLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontLowLightRequest* /*request*/, ::UnityAPI::FrontLowLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FrontLowLightControl(
      ::grpc::CallbackServerContext* /*context*/, const ::UnityAPI::FrontLowLightRequest* /*request*/, ::UnityAPI::FrontLowLightReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FrontLowLightControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::UnityAPI::FrontLowLightRequest* /*request*/, ::UnityAPI::FrontLowLightReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_FrontHighLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_FrontHighLightControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::UnityAPI::FrontHighLightRequest, ::UnityAPI::FrontHighLightReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::UnityAPI::FrontHighLightRequest* request, ::UnityAPI::FrontHighLightReply* response) { return this->FrontHighLightControl(context, request, response); }));}
    void SetMessageAllocatorFor_FrontHighLightControl(
        ::grpc::experimental::MessageAllocator< ::UnityAPI::FrontHighLightRequest, ::UnityAPI::FrontHighLightReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::UnityAPI::FrontHighLightRequest, ::UnityAPI::FrontHighLightReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_FrontHighLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontHighLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontHighLightRequest* /*request*/, ::UnityAPI::FrontHighLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FrontHighLightControl(
      ::grpc::CallbackServerContext* /*context*/, const ::UnityAPI::FrontHighLightRequest* /*request*/, ::UnityAPI::FrontHighLightReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FrontHighLightControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::UnityAPI::FrontHighLightRequest* /*request*/, ::UnityAPI::FrontHighLightReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RearLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_RearLightControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::UnityAPI::RearLightRequest, ::UnityAPI::RearLightReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::UnityAPI::RearLightRequest* request, ::UnityAPI::RearLightReply* response) { return this->RearLightControl(context, request, response); }));}
    void SetMessageAllocatorFor_RearLightControl(
        ::grpc::experimental::MessageAllocator< ::UnityAPI::RearLightRequest, ::UnityAPI::RearLightReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::UnityAPI::RearLightRequest, ::UnityAPI::RearLightReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_RearLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearLightRequest* /*request*/, ::UnityAPI::RearLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RearLightControl(
      ::grpc::CallbackServerContext* /*context*/, const ::UnityAPI::RearLightRequest* /*request*/, ::UnityAPI::RearLightReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RearLightControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::UnityAPI::RearLightRequest* /*request*/, ::UnityAPI::RearLightReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_FrontDaytimeLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_FrontDaytimeLightControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::UnityAPI::FrontDaytimeLightRequest, ::UnityAPI::FrontDaytimeLightReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::UnityAPI::FrontDaytimeLightRequest* request, ::UnityAPI::FrontDaytimeLightReply* response) { return this->FrontDaytimeLightControl(context, request, response); }));}
    void SetMessageAllocatorFor_FrontDaytimeLightControl(
        ::grpc::experimental::MessageAllocator< ::UnityAPI::FrontDaytimeLightRequest, ::UnityAPI::FrontDaytimeLightReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::UnityAPI::FrontDaytimeLightRequest, ::UnityAPI::FrontDaytimeLightReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_FrontDaytimeLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontDaytimeLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontDaytimeLightRequest* /*request*/, ::UnityAPI::FrontDaytimeLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FrontDaytimeLightControl(
      ::grpc::CallbackServerContext* /*context*/, const ::UnityAPI::FrontDaytimeLightRequest* /*request*/, ::UnityAPI::FrontDaytimeLightReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FrontDaytimeLightControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::UnityAPI::FrontDaytimeLightRequest* /*request*/, ::UnityAPI::FrontDaytimeLightReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_BrakeLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_BrakeLightControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::UnityAPI::BrakeLightRequest, ::UnityAPI::BrakeLightReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::UnityAPI::BrakeLightRequest* request, ::UnityAPI::BrakeLightReply* response) { return this->BrakeLightControl(context, request, response); }));}
    void SetMessageAllocatorFor_BrakeLightControl(
        ::grpc::experimental::MessageAllocator< ::UnityAPI::BrakeLightRequest, ::UnityAPI::BrakeLightReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::UnityAPI::BrakeLightRequest, ::UnityAPI::BrakeLightReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_BrakeLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BrakeLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::BrakeLightRequest* /*request*/, ::UnityAPI::BrakeLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* BrakeLightControl(
      ::grpc::CallbackServerContext* /*context*/, const ::UnityAPI::BrakeLightRequest* /*request*/, ::UnityAPI::BrakeLightReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* BrakeLightControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::UnityAPI::BrakeLightRequest* /*request*/, ::UnityAPI::BrakeLightReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ReverseLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ReverseLightControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::UnityAPI::ReverseLightRequest, ::UnityAPI::ReverseLightReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::UnityAPI::ReverseLightRequest* request, ::UnityAPI::ReverseLightReply* response) { return this->ReverseLightControl(context, request, response); }));}
    void SetMessageAllocatorFor_ReverseLightControl(
        ::grpc::experimental::MessageAllocator< ::UnityAPI::ReverseLightRequest, ::UnityAPI::ReverseLightReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(5);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::UnityAPI::ReverseLightRequest, ::UnityAPI::ReverseLightReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ReverseLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReverseLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::ReverseLightRequest* /*request*/, ::UnityAPI::ReverseLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ReverseLightControl(
      ::grpc::CallbackServerContext* /*context*/, const ::UnityAPI::ReverseLightRequest* /*request*/, ::UnityAPI::ReverseLightReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ReverseLightControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::UnityAPI::ReverseLightRequest* /*request*/, ::UnityAPI::ReverseLightReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_FrontFogLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_FrontFogLightControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::UnityAPI::FrontFogLightRequest, ::UnityAPI::FrontFogLightReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::UnityAPI::FrontFogLightRequest* request, ::UnityAPI::FrontFogLightReply* response) { return this->FrontFogLightControl(context, request, response); }));}
    void SetMessageAllocatorFor_FrontFogLightControl(
        ::grpc::experimental::MessageAllocator< ::UnityAPI::FrontFogLightRequest, ::UnityAPI::FrontFogLightReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(6);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::UnityAPI::FrontFogLightRequest, ::UnityAPI::FrontFogLightReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_FrontFogLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontFogLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontFogLightRequest* /*request*/, ::UnityAPI::FrontFogLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FrontFogLightControl(
      ::grpc::CallbackServerContext* /*context*/, const ::UnityAPI::FrontFogLightRequest* /*request*/, ::UnityAPI::FrontFogLightReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FrontFogLightControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::UnityAPI::FrontFogLightRequest* /*request*/, ::UnityAPI::FrontFogLightReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RearFogLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_RearFogLightControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::UnityAPI::RearFogLightRequest, ::UnityAPI::RearFogLightReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::UnityAPI::RearFogLightRequest* request, ::UnityAPI::RearFogLightReply* response) { return this->RearFogLightControl(context, request, response); }));}
    void SetMessageAllocatorFor_RearFogLightControl(
        ::grpc::experimental::MessageAllocator< ::UnityAPI::RearFogLightRequest, ::UnityAPI::RearFogLightReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(7);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::UnityAPI::RearFogLightRequest, ::UnityAPI::RearFogLightReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_RearFogLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearFogLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearFogLightRequest* /*request*/, ::UnityAPI::RearFogLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RearFogLightControl(
      ::grpc::CallbackServerContext* /*context*/, const ::UnityAPI::RearFogLightRequest* /*request*/, ::UnityAPI::RearFogLightReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RearFogLightControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::UnityAPI::RearFogLightRequest* /*request*/, ::UnityAPI::RearFogLightReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ClearanceLampControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ClearanceLampControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::UnityAPI::ClearanceLampRequest, ::UnityAPI::ClearanceLampReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::UnityAPI::ClearanceLampRequest* request, ::UnityAPI::ClearanceLampReply* response) { return this->ClearanceLampControl(context, request, response); }));}
    void SetMessageAllocatorFor_ClearanceLampControl(
        ::grpc::experimental::MessageAllocator< ::UnityAPI::ClearanceLampRequest, ::UnityAPI::ClearanceLampReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(8);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::UnityAPI::ClearanceLampRequest, ::UnityAPI::ClearanceLampReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ClearanceLampControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClearanceLampControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::ClearanceLampRequest* /*request*/, ::UnityAPI::ClearanceLampReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ClearanceLampControl(
      ::grpc::CallbackServerContext* /*context*/, const ::UnityAPI::ClearanceLampRequest* /*request*/, ::UnityAPI::ClearanceLampReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ClearanceLampControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::UnityAPI::ClearanceLampRequest* /*request*/, ::UnityAPI::ClearanceLampReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_FrontLeftBlinkerLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_FrontLeftBlinkerLightControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::UnityAPI::FrontLeftBlinkerLightRequest, ::UnityAPI::FrontLeftBlinkerLightReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::UnityAPI::FrontLeftBlinkerLightRequest* request, ::UnityAPI::FrontLeftBlinkerLightReply* response) { return this->FrontLeftBlinkerLightControl(context, request, response); }));}
    void SetMessageAllocatorFor_FrontLeftBlinkerLightControl(
        ::grpc::experimental::MessageAllocator< ::UnityAPI::FrontLeftBlinkerLightRequest, ::UnityAPI::FrontLeftBlinkerLightReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(9);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::UnityAPI::FrontLeftBlinkerLightRequest, ::UnityAPI::FrontLeftBlinkerLightReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_FrontLeftBlinkerLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontLeftBlinkerLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontLeftBlinkerLightRequest* /*request*/, ::UnityAPI::FrontLeftBlinkerLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FrontLeftBlinkerLightControl(
      ::grpc::CallbackServerContext* /*context*/, const ::UnityAPI::FrontLeftBlinkerLightRequest* /*request*/, ::UnityAPI::FrontLeftBlinkerLightReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FrontLeftBlinkerLightControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::UnityAPI::FrontLeftBlinkerLightRequest* /*request*/, ::UnityAPI::FrontLeftBlinkerLightReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_FrontRightBlinkerLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_FrontRightBlinkerLightControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::UnityAPI::FrontRightBlinkerLightRequest, ::UnityAPI::FrontRightBlinkerLightReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::UnityAPI::FrontRightBlinkerLightRequest* request, ::UnityAPI::FrontRightBlinkerLightReply* response) { return this->FrontRightBlinkerLightControl(context, request, response); }));}
    void SetMessageAllocatorFor_FrontRightBlinkerLightControl(
        ::grpc::experimental::MessageAllocator< ::UnityAPI::FrontRightBlinkerLightRequest, ::UnityAPI::FrontRightBlinkerLightReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(10);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::UnityAPI::FrontRightBlinkerLightRequest, ::UnityAPI::FrontRightBlinkerLightReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_FrontRightBlinkerLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontRightBlinkerLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontRightBlinkerLightRequest* /*request*/, ::UnityAPI::FrontRightBlinkerLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FrontRightBlinkerLightControl(
      ::grpc::CallbackServerContext* /*context*/, const ::UnityAPI::FrontRightBlinkerLightRequest* /*request*/, ::UnityAPI::FrontRightBlinkerLightReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FrontRightBlinkerLightControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::UnityAPI::FrontRightBlinkerLightRequest* /*request*/, ::UnityAPI::FrontRightBlinkerLightReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RearLeftBlinkerLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_RearLeftBlinkerLightControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::UnityAPI::RearLeftBlinkerLightRequest, ::UnityAPI::RearLeftBlinkerLightReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::UnityAPI::RearLeftBlinkerLightRequest* request, ::UnityAPI::RearLeftBlinkerLightReply* response) { return this->RearLeftBlinkerLightControl(context, request, response); }));}
    void SetMessageAllocatorFor_RearLeftBlinkerLightControl(
        ::grpc::experimental::MessageAllocator< ::UnityAPI::RearLeftBlinkerLightRequest, ::UnityAPI::RearLeftBlinkerLightReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(11);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::UnityAPI::RearLeftBlinkerLightRequest, ::UnityAPI::RearLeftBlinkerLightReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_RearLeftBlinkerLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearLeftBlinkerLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearLeftBlinkerLightRequest* /*request*/, ::UnityAPI::RearLeftBlinkerLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RearLeftBlinkerLightControl(
      ::grpc::CallbackServerContext* /*context*/, const ::UnityAPI::RearLeftBlinkerLightRequest* /*request*/, ::UnityAPI::RearLeftBlinkerLightReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RearLeftBlinkerLightControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::UnityAPI::RearLeftBlinkerLightRequest* /*request*/, ::UnityAPI::RearLeftBlinkerLightReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RearRightBlinkerLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_RearRightBlinkerLightControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::UnityAPI::RearRightBlinkerLightRequest, ::UnityAPI::RearRightBlinkerLightReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::UnityAPI::RearRightBlinkerLightRequest* request, ::UnityAPI::RearRightBlinkerLightReply* response) { return this->RearRightBlinkerLightControl(context, request, response); }));}
    void SetMessageAllocatorFor_RearRightBlinkerLightControl(
        ::grpc::experimental::MessageAllocator< ::UnityAPI::RearRightBlinkerLightRequest, ::UnityAPI::RearRightBlinkerLightReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(12);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::UnityAPI::RearRightBlinkerLightRequest, ::UnityAPI::RearRightBlinkerLightReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_RearRightBlinkerLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearRightBlinkerLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearRightBlinkerLightRequest* /*request*/, ::UnityAPI::RearRightBlinkerLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RearRightBlinkerLightControl(
      ::grpc::CallbackServerContext* /*context*/, const ::UnityAPI::RearRightBlinkerLightRequest* /*request*/, ::UnityAPI::RearRightBlinkerLightReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RearRightBlinkerLightControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::UnityAPI::RearRightBlinkerLightRequest* /*request*/, ::UnityAPI::RearRightBlinkerLightReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_FrontWiperControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_FrontWiperControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::UnityAPI::FrontWiperRequest, ::UnityAPI::FrontWiperReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::UnityAPI::FrontWiperRequest* request, ::UnityAPI::FrontWiperReply* response) { return this->FrontWiperControl(context, request, response); }));}
    void SetMessageAllocatorFor_FrontWiperControl(
        ::grpc::experimental::MessageAllocator< ::UnityAPI::FrontWiperRequest, ::UnityAPI::FrontWiperReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(13);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::UnityAPI::FrontWiperRequest, ::UnityAPI::FrontWiperReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_FrontWiperControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontWiperControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontWiperRequest* /*request*/, ::UnityAPI::FrontWiperReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FrontWiperControl(
      ::grpc::CallbackServerContext* /*context*/, const ::UnityAPI::FrontWiperRequest* /*request*/, ::UnityAPI::FrontWiperReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FrontWiperControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::UnityAPI::FrontWiperRequest* /*request*/, ::UnityAPI::FrontWiperReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RearWiperControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_RearWiperControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::UnityAPI::RearWiperRequest, ::UnityAPI::RearWiperReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::UnityAPI::RearWiperRequest* request, ::UnityAPI::RearWiperReply* response) { return this->RearWiperControl(context, request, response); }));}
    void SetMessageAllocatorFor_RearWiperControl(
        ::grpc::experimental::MessageAllocator< ::UnityAPI::RearWiperRequest, ::UnityAPI::RearWiperReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(14);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::UnityAPI::RearWiperRequest, ::UnityAPI::RearWiperReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_RearWiperControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearWiperControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearWiperRequest* /*request*/, ::UnityAPI::RearWiperReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RearWiperControl(
      ::grpc::CallbackServerContext* /*context*/, const ::UnityAPI::RearWiperRequest* /*request*/, ::UnityAPI::RearWiperReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RearWiperControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::UnityAPI::RearWiperRequest* /*request*/, ::UnityAPI::RearWiperReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_LeftSideMirrorControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_LeftSideMirrorControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::UnityAPI::LeftSideMirrorRequest, ::UnityAPI::LeftSideMirrorReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::UnityAPI::LeftSideMirrorRequest* request, ::UnityAPI::LeftSideMirrorReply* response) { return this->LeftSideMirrorControl(context, request, response); }));}
    void SetMessageAllocatorFor_LeftSideMirrorControl(
        ::grpc::experimental::MessageAllocator< ::UnityAPI::LeftSideMirrorRequest, ::UnityAPI::LeftSideMirrorReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(15);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::UnityAPI::LeftSideMirrorRequest, ::UnityAPI::LeftSideMirrorReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_LeftSideMirrorControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeftSideMirrorControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::LeftSideMirrorRequest* /*request*/, ::UnityAPI::LeftSideMirrorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LeftSideMirrorControl(
      ::grpc::CallbackServerContext* /*context*/, const ::UnityAPI::LeftSideMirrorRequest* /*request*/, ::UnityAPI::LeftSideMirrorReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LeftSideMirrorControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::UnityAPI::LeftSideMirrorRequest* /*request*/, ::UnityAPI::LeftSideMirrorReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RightSideMirrorControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_RightSideMirrorControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::UnityAPI::RightSideMirrorRequest, ::UnityAPI::RightSideMirrorReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::UnityAPI::RightSideMirrorRequest* request, ::UnityAPI::RightSideMirrorReply* response) { return this->RightSideMirrorControl(context, request, response); }));}
    void SetMessageAllocatorFor_RightSideMirrorControl(
        ::grpc::experimental::MessageAllocator< ::UnityAPI::RightSideMirrorRequest, ::UnityAPI::RightSideMirrorReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(16);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::UnityAPI::RightSideMirrorRequest, ::UnityAPI::RightSideMirrorReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_RightSideMirrorControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RightSideMirrorControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RightSideMirrorRequest* /*request*/, ::UnityAPI::RightSideMirrorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RightSideMirrorControl(
      ::grpc::CallbackServerContext* /*context*/, const ::UnityAPI::RightSideMirrorRequest* /*request*/, ::UnityAPI::RightSideMirrorReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RightSideMirrorControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::UnityAPI::RightSideMirrorRequest* /*request*/, ::UnityAPI::RightSideMirrorReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_FrontRightDoorControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_FrontRightDoorControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::UnityAPI::FrontRightDoorRequest, ::UnityAPI::FrontRightDoorReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::UnityAPI::FrontRightDoorRequest* request, ::UnityAPI::FrontRightDoorReply* response) { return this->FrontRightDoorControl(context, request, response); }));}
    void SetMessageAllocatorFor_FrontRightDoorControl(
        ::grpc::experimental::MessageAllocator< ::UnityAPI::FrontRightDoorRequest, ::UnityAPI::FrontRightDoorReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(17);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(17);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::UnityAPI::FrontRightDoorRequest, ::UnityAPI::FrontRightDoorReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_FrontRightDoorControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontRightDoorControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontRightDoorRequest* /*request*/, ::UnityAPI::FrontRightDoorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FrontRightDoorControl(
      ::grpc::CallbackServerContext* /*context*/, const ::UnityAPI::FrontRightDoorRequest* /*request*/, ::UnityAPI::FrontRightDoorReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FrontRightDoorControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::UnityAPI::FrontRightDoorRequest* /*request*/, ::UnityAPI::FrontRightDoorReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_FrontLeftDoorControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_FrontLeftDoorControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::UnityAPI::FrontLeftDoorRequest, ::UnityAPI::FrontLeftDoorReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::UnityAPI::FrontLeftDoorRequest* request, ::UnityAPI::FrontLeftDoorReply* response) { return this->FrontLeftDoorControl(context, request, response); }));}
    void SetMessageAllocatorFor_FrontLeftDoorControl(
        ::grpc::experimental::MessageAllocator< ::UnityAPI::FrontLeftDoorRequest, ::UnityAPI::FrontLeftDoorReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(18);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(18);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::UnityAPI::FrontLeftDoorRequest, ::UnityAPI::FrontLeftDoorReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_FrontLeftDoorControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontLeftDoorControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontLeftDoorRequest* /*request*/, ::UnityAPI::FrontLeftDoorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FrontLeftDoorControl(
      ::grpc::CallbackServerContext* /*context*/, const ::UnityAPI::FrontLeftDoorRequest* /*request*/, ::UnityAPI::FrontLeftDoorReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FrontLeftDoorControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::UnityAPI::FrontLeftDoorRequest* /*request*/, ::UnityAPI::FrontLeftDoorReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RearRightDoorControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_RearRightDoorControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::UnityAPI::RearRightDoorRequest, ::UnityAPI::RearRightDoorReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::UnityAPI::RearRightDoorRequest* request, ::UnityAPI::RearRightDoorReply* response) { return this->RearRightDoorControl(context, request, response); }));}
    void SetMessageAllocatorFor_RearRightDoorControl(
        ::grpc::experimental::MessageAllocator< ::UnityAPI::RearRightDoorRequest, ::UnityAPI::RearRightDoorReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(19);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(19);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::UnityAPI::RearRightDoorRequest, ::UnityAPI::RearRightDoorReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_RearRightDoorControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearRightDoorControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearRightDoorRequest* /*request*/, ::UnityAPI::RearRightDoorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RearRightDoorControl(
      ::grpc::CallbackServerContext* /*context*/, const ::UnityAPI::RearRightDoorRequest* /*request*/, ::UnityAPI::RearRightDoorReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RearRightDoorControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::UnityAPI::RearRightDoorRequest* /*request*/, ::UnityAPI::RearRightDoorReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RearLeftDoorControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_RearLeftDoorControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::UnityAPI::RearLeftDoorRequest, ::UnityAPI::RearLeftDoorReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::UnityAPI::RearLeftDoorRequest* request, ::UnityAPI::RearLeftDoorReply* response) { return this->RearLeftDoorControl(context, request, response); }));}
    void SetMessageAllocatorFor_RearLeftDoorControl(
        ::grpc::experimental::MessageAllocator< ::UnityAPI::RearLeftDoorRequest, ::UnityAPI::RearLeftDoorReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(20);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(20);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::UnityAPI::RearLeftDoorRequest, ::UnityAPI::RearLeftDoorReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_RearLeftDoorControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearLeftDoorControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearLeftDoorRequest* /*request*/, ::UnityAPI::RearLeftDoorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RearLeftDoorControl(
      ::grpc::CallbackServerContext* /*context*/, const ::UnityAPI::RearLeftDoorRequest* /*request*/, ::UnityAPI::RearLeftDoorReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RearLeftDoorControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::UnityAPI::RearLeftDoorRequest* /*request*/, ::UnityAPI::RearLeftDoorReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_TrunkControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_TrunkControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::UnityAPI::TrunkRequest, ::UnityAPI::TrunkReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::UnityAPI::TrunkRequest* request, ::UnityAPI::TrunkReply* response) { return this->TrunkControl(context, request, response); }));}
    void SetMessageAllocatorFor_TrunkControl(
        ::grpc::experimental::MessageAllocator< ::UnityAPI::TrunkRequest, ::UnityAPI::TrunkReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(21);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(21);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::UnityAPI::TrunkRequest, ::UnityAPI::TrunkReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_TrunkControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TrunkControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::TrunkRequest* /*request*/, ::UnityAPI::TrunkReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* TrunkControl(
      ::grpc::CallbackServerContext* /*context*/, const ::UnityAPI::TrunkRequest* /*request*/, ::UnityAPI::TrunkReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* TrunkControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::UnityAPI::TrunkRequest* /*request*/, ::UnityAPI::TrunkReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SunRoofControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SunRoofControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(22,
          new ::grpc::internal::CallbackUnaryHandler< ::UnityAPI::SunRoofRequest, ::UnityAPI::SunRoofReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::UnityAPI::SunRoofRequest* request, ::UnityAPI::SunRoofReply* response) { return this->SunRoofControl(context, request, response); }));}
    void SetMessageAllocatorFor_SunRoofControl(
        ::grpc::experimental::MessageAllocator< ::UnityAPI::SunRoofRequest, ::UnityAPI::SunRoofReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(22);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(22);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::UnityAPI::SunRoofRequest, ::UnityAPI::SunRoofReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SunRoofControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SunRoofControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::SunRoofRequest* /*request*/, ::UnityAPI::SunRoofReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SunRoofControl(
      ::grpc::CallbackServerContext* /*context*/, const ::UnityAPI::SunRoofRequest* /*request*/, ::UnityAPI::SunRoofReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SunRoofControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::UnityAPI::SunRoofRequest* /*request*/, ::UnityAPI::SunRoofReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_FrontRightPowerWindowsControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_FrontRightPowerWindowsControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(23,
          new ::grpc::internal::CallbackUnaryHandler< ::UnityAPI::FrontRightPowerWindowsRequest, ::UnityAPI::FrontRightPowerWindowsReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::UnityAPI::FrontRightPowerWindowsRequest* request, ::UnityAPI::FrontRightPowerWindowsReply* response) { return this->FrontRightPowerWindowsControl(context, request, response); }));}
    void SetMessageAllocatorFor_FrontRightPowerWindowsControl(
        ::grpc::experimental::MessageAllocator< ::UnityAPI::FrontRightPowerWindowsRequest, ::UnityAPI::FrontRightPowerWindowsReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(23);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(23);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::UnityAPI::FrontRightPowerWindowsRequest, ::UnityAPI::FrontRightPowerWindowsReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_FrontRightPowerWindowsControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontRightPowerWindowsControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontRightPowerWindowsRequest* /*request*/, ::UnityAPI::FrontRightPowerWindowsReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FrontRightPowerWindowsControl(
      ::grpc::CallbackServerContext* /*context*/, const ::UnityAPI::FrontRightPowerWindowsRequest* /*request*/, ::UnityAPI::FrontRightPowerWindowsReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FrontRightPowerWindowsControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::UnityAPI::FrontRightPowerWindowsRequest* /*request*/, ::UnityAPI::FrontRightPowerWindowsReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_FrontLeftPowerWindowsControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_FrontLeftPowerWindowsControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(24,
          new ::grpc::internal::CallbackUnaryHandler< ::UnityAPI::FrontLeftPowerWindowsRequest, ::UnityAPI::FrontLeftPowerWindowsReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::UnityAPI::FrontLeftPowerWindowsRequest* request, ::UnityAPI::FrontLeftPowerWindowsReply* response) { return this->FrontLeftPowerWindowsControl(context, request, response); }));}
    void SetMessageAllocatorFor_FrontLeftPowerWindowsControl(
        ::grpc::experimental::MessageAllocator< ::UnityAPI::FrontLeftPowerWindowsRequest, ::UnityAPI::FrontLeftPowerWindowsReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(24);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(24);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::UnityAPI::FrontLeftPowerWindowsRequest, ::UnityAPI::FrontLeftPowerWindowsReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_FrontLeftPowerWindowsControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontLeftPowerWindowsControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontLeftPowerWindowsRequest* /*request*/, ::UnityAPI::FrontLeftPowerWindowsReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FrontLeftPowerWindowsControl(
      ::grpc::CallbackServerContext* /*context*/, const ::UnityAPI::FrontLeftPowerWindowsRequest* /*request*/, ::UnityAPI::FrontLeftPowerWindowsReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FrontLeftPowerWindowsControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::UnityAPI::FrontLeftPowerWindowsRequest* /*request*/, ::UnityAPI::FrontLeftPowerWindowsReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RearRightPowerWindowsControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_RearRightPowerWindowsControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(25,
          new ::grpc::internal::CallbackUnaryHandler< ::UnityAPI::RearRightPowerWindowsRequest, ::UnityAPI::RearRightPowerWindowsReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::UnityAPI::RearRightPowerWindowsRequest* request, ::UnityAPI::RearRightPowerWindowsReply* response) { return this->RearRightPowerWindowsControl(context, request, response); }));}
    void SetMessageAllocatorFor_RearRightPowerWindowsControl(
        ::grpc::experimental::MessageAllocator< ::UnityAPI::RearRightPowerWindowsRequest, ::UnityAPI::RearRightPowerWindowsReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(25);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(25);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::UnityAPI::RearRightPowerWindowsRequest, ::UnityAPI::RearRightPowerWindowsReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_RearRightPowerWindowsControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearRightPowerWindowsControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearRightPowerWindowsRequest* /*request*/, ::UnityAPI::RearRightPowerWindowsReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RearRightPowerWindowsControl(
      ::grpc::CallbackServerContext* /*context*/, const ::UnityAPI::RearRightPowerWindowsRequest* /*request*/, ::UnityAPI::RearRightPowerWindowsReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RearRightPowerWindowsControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::UnityAPI::RearRightPowerWindowsRequest* /*request*/, ::UnityAPI::RearRightPowerWindowsReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RearLeftPowerWindowsControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_RearLeftPowerWindowsControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(26,
          new ::grpc::internal::CallbackUnaryHandler< ::UnityAPI::RearLeftPowerWindowsRequest, ::UnityAPI::RearLeftPowerWindowsReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::UnityAPI::RearLeftPowerWindowsRequest* request, ::UnityAPI::RearLeftPowerWindowsReply* response) { return this->RearLeftPowerWindowsControl(context, request, response); }));}
    void SetMessageAllocatorFor_RearLeftPowerWindowsControl(
        ::grpc::experimental::MessageAllocator< ::UnityAPI::RearLeftPowerWindowsRequest, ::UnityAPI::RearLeftPowerWindowsReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(26);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(26);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::UnityAPI::RearLeftPowerWindowsRequest, ::UnityAPI::RearLeftPowerWindowsReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_RearLeftPowerWindowsControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearLeftPowerWindowsControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearLeftPowerWindowsRequest* /*request*/, ::UnityAPI::RearLeftPowerWindowsReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RearLeftPowerWindowsControl(
      ::grpc::CallbackServerContext* /*context*/, const ::UnityAPI::RearLeftPowerWindowsRequest* /*request*/, ::UnityAPI::RearLeftPowerWindowsReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RearLeftPowerWindowsControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::UnityAPI::RearLeftPowerWindowsRequest* /*request*/, ::UnityAPI::RearLeftPowerWindowsReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SideMirrorSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SideMirrorSwitchControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(27,
          new ::grpc::internal::CallbackUnaryHandler< ::UnityAPI::SideMirrorSwitchRequest, ::UnityAPI::SideMirrorSwitchReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::UnityAPI::SideMirrorSwitchRequest* request, ::UnityAPI::SideMirrorSwitchReply* response) { return this->SideMirrorSwitchControl(context, request, response); }));}
    void SetMessageAllocatorFor_SideMirrorSwitchControl(
        ::grpc::experimental::MessageAllocator< ::UnityAPI::SideMirrorSwitchRequest, ::UnityAPI::SideMirrorSwitchReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(27);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(27);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::UnityAPI::SideMirrorSwitchRequest, ::UnityAPI::SideMirrorSwitchReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SideMirrorSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SideMirrorSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::SideMirrorSwitchRequest* /*request*/, ::UnityAPI::SideMirrorSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SideMirrorSwitchControl(
      ::grpc::CallbackServerContext* /*context*/, const ::UnityAPI::SideMirrorSwitchRequest* /*request*/, ::UnityAPI::SideMirrorSwitchReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SideMirrorSwitchControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::UnityAPI::SideMirrorSwitchRequest* /*request*/, ::UnityAPI::SideMirrorSwitchReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_InstrumentLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_InstrumentLightControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(28,
          new ::grpc::internal::CallbackUnaryHandler< ::UnityAPI::InstrumentLightRequest, ::UnityAPI::InstrumentLightReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::UnityAPI::InstrumentLightRequest* request, ::UnityAPI::InstrumentLightReply* response) { return this->InstrumentLightControl(context, request, response); }));}
    void SetMessageAllocatorFor_InstrumentLightControl(
        ::grpc::experimental::MessageAllocator< ::UnityAPI::InstrumentLightRequest, ::UnityAPI::InstrumentLightReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(28);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(28);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::UnityAPI::InstrumentLightRequest, ::UnityAPI::InstrumentLightReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_InstrumentLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InstrumentLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::InstrumentLightRequest* /*request*/, ::UnityAPI::InstrumentLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* InstrumentLightControl(
      ::grpc::CallbackServerContext* /*context*/, const ::UnityAPI::InstrumentLightRequest* /*request*/, ::UnityAPI::InstrumentLightReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* InstrumentLightControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::UnityAPI::InstrumentLightRequest* /*request*/, ::UnityAPI::InstrumentLightReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PassgenerRoomDomeLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PassgenerRoomDomeLightControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(29,
          new ::grpc::internal::CallbackUnaryHandler< ::UnityAPI::PassgenerRoomDomeLightRequest, ::UnityAPI::PassgenerRoomDomeLightReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::UnityAPI::PassgenerRoomDomeLightRequest* request, ::UnityAPI::PassgenerRoomDomeLightReply* response) { return this->PassgenerRoomDomeLightControl(context, request, response); }));}
    void SetMessageAllocatorFor_PassgenerRoomDomeLightControl(
        ::grpc::experimental::MessageAllocator< ::UnityAPI::PassgenerRoomDomeLightRequest, ::UnityAPI::PassgenerRoomDomeLightReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(29);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(29);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::UnityAPI::PassgenerRoomDomeLightRequest, ::UnityAPI::PassgenerRoomDomeLightReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PassgenerRoomDomeLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PassgenerRoomDomeLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::PassgenerRoomDomeLightRequest* /*request*/, ::UnityAPI::PassgenerRoomDomeLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PassgenerRoomDomeLightControl(
      ::grpc::CallbackServerContext* /*context*/, const ::UnityAPI::PassgenerRoomDomeLightRequest* /*request*/, ::UnityAPI::PassgenerRoomDomeLightReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PassgenerRoomDomeLightControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::UnityAPI::PassgenerRoomDomeLightRequest* /*request*/, ::UnityAPI::PassgenerRoomDomeLightReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ReadingLightDriverSideControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ReadingLightDriverSideControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(30,
          new ::grpc::internal::CallbackUnaryHandler< ::UnityAPI::ReadingLightDriverSideRequest, ::UnityAPI::ReadingLightDriverSideReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::UnityAPI::ReadingLightDriverSideRequest* request, ::UnityAPI::ReadingLightDriverSideReply* response) { return this->ReadingLightDriverSideControl(context, request, response); }));}
    void SetMessageAllocatorFor_ReadingLightDriverSideControl(
        ::grpc::experimental::MessageAllocator< ::UnityAPI::ReadingLightDriverSideRequest, ::UnityAPI::ReadingLightDriverSideReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(30);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(30);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::UnityAPI::ReadingLightDriverSideRequest, ::UnityAPI::ReadingLightDriverSideReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ReadingLightDriverSideControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadingLightDriverSideControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::ReadingLightDriverSideRequest* /*request*/, ::UnityAPI::ReadingLightDriverSideReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ReadingLightDriverSideControl(
      ::grpc::CallbackServerContext* /*context*/, const ::UnityAPI::ReadingLightDriverSideRequest* /*request*/, ::UnityAPI::ReadingLightDriverSideReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ReadingLightDriverSideControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::UnityAPI::ReadingLightDriverSideRequest* /*request*/, ::UnityAPI::ReadingLightDriverSideReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ReadingLightPassgenerSideControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ReadingLightPassgenerSideControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(31,
          new ::grpc::internal::CallbackUnaryHandler< ::UnityAPI::ReadingLightPassgenerSideRequest, ::UnityAPI::ReadingLightPassgenerSideReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::UnityAPI::ReadingLightPassgenerSideRequest* request, ::UnityAPI::ReadingLightPassgenerSideReply* response) { return this->ReadingLightPassgenerSideControl(context, request, response); }));}
    void SetMessageAllocatorFor_ReadingLightPassgenerSideControl(
        ::grpc::experimental::MessageAllocator< ::UnityAPI::ReadingLightPassgenerSideRequest, ::UnityAPI::ReadingLightPassgenerSideReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(31);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(31);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::UnityAPI::ReadingLightPassgenerSideRequest, ::UnityAPI::ReadingLightPassgenerSideReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ReadingLightPassgenerSideControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadingLightPassgenerSideControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::ReadingLightPassgenerSideRequest* /*request*/, ::UnityAPI::ReadingLightPassgenerSideReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ReadingLightPassgenerSideControl(
      ::grpc::CallbackServerContext* /*context*/, const ::UnityAPI::ReadingLightPassgenerSideRequest* /*request*/, ::UnityAPI::ReadingLightPassgenerSideReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ReadingLightPassgenerSideControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::UnityAPI::ReadingLightPassgenerSideRequest* /*request*/, ::UnityAPI::ReadingLightPassgenerSideReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_FrontRightPowerWindowsSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_FrontRightPowerWindowsSwitchControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(32,
          new ::grpc::internal::CallbackUnaryHandler< ::UnityAPI::FrontRightPowerWindowsSwitchRequest, ::UnityAPI::FrontRightPowerWindowsSwitchReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::UnityAPI::FrontRightPowerWindowsSwitchRequest* request, ::UnityAPI::FrontRightPowerWindowsSwitchReply* response) { return this->FrontRightPowerWindowsSwitchControl(context, request, response); }));}
    void SetMessageAllocatorFor_FrontRightPowerWindowsSwitchControl(
        ::grpc::experimental::MessageAllocator< ::UnityAPI::FrontRightPowerWindowsSwitchRequest, ::UnityAPI::FrontRightPowerWindowsSwitchReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(32);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(32);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::UnityAPI::FrontRightPowerWindowsSwitchRequest, ::UnityAPI::FrontRightPowerWindowsSwitchReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_FrontRightPowerWindowsSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontRightPowerWindowsSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontRightPowerWindowsSwitchRequest* /*request*/, ::UnityAPI::FrontRightPowerWindowsSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FrontRightPowerWindowsSwitchControl(
      ::grpc::CallbackServerContext* /*context*/, const ::UnityAPI::FrontRightPowerWindowsSwitchRequest* /*request*/, ::UnityAPI::FrontRightPowerWindowsSwitchReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FrontRightPowerWindowsSwitchControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::UnityAPI::FrontRightPowerWindowsSwitchRequest* /*request*/, ::UnityAPI::FrontRightPowerWindowsSwitchReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_FrontLeftPowerWindowsSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_FrontLeftPowerWindowsSwitchControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(33,
          new ::grpc::internal::CallbackUnaryHandler< ::UnityAPI::FrontLeftPowerWindowsSwitchRequest, ::UnityAPI::FrontLeftPowerWindowsSwitchReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::UnityAPI::FrontLeftPowerWindowsSwitchRequest* request, ::UnityAPI::FrontLeftPowerWindowsSwitchReply* response) { return this->FrontLeftPowerWindowsSwitchControl(context, request, response); }));}
    void SetMessageAllocatorFor_FrontLeftPowerWindowsSwitchControl(
        ::grpc::experimental::MessageAllocator< ::UnityAPI::FrontLeftPowerWindowsSwitchRequest, ::UnityAPI::FrontLeftPowerWindowsSwitchReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(33);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(33);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::UnityAPI::FrontLeftPowerWindowsSwitchRequest, ::UnityAPI::FrontLeftPowerWindowsSwitchReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_FrontLeftPowerWindowsSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontLeftPowerWindowsSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontLeftPowerWindowsSwitchRequest* /*request*/, ::UnityAPI::FrontLeftPowerWindowsSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FrontLeftPowerWindowsSwitchControl(
      ::grpc::CallbackServerContext* /*context*/, const ::UnityAPI::FrontLeftPowerWindowsSwitchRequest* /*request*/, ::UnityAPI::FrontLeftPowerWindowsSwitchReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FrontLeftPowerWindowsSwitchControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::UnityAPI::FrontLeftPowerWindowsSwitchRequest* /*request*/, ::UnityAPI::FrontLeftPowerWindowsSwitchReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RearRightPowerWindowsSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_RearRightPowerWindowsSwitchControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(34,
          new ::grpc::internal::CallbackUnaryHandler< ::UnityAPI::RearRightPowerWindowsSwitchRequest, ::UnityAPI::RearRightPowerWindowsSwitchReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::UnityAPI::RearRightPowerWindowsSwitchRequest* request, ::UnityAPI::RearRightPowerWindowsSwitchReply* response) { return this->RearRightPowerWindowsSwitchControl(context, request, response); }));}
    void SetMessageAllocatorFor_RearRightPowerWindowsSwitchControl(
        ::grpc::experimental::MessageAllocator< ::UnityAPI::RearRightPowerWindowsSwitchRequest, ::UnityAPI::RearRightPowerWindowsSwitchReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(34);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(34);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::UnityAPI::RearRightPowerWindowsSwitchRequest, ::UnityAPI::RearRightPowerWindowsSwitchReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_RearRightPowerWindowsSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearRightPowerWindowsSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearRightPowerWindowsSwitchRequest* /*request*/, ::UnityAPI::RearRightPowerWindowsSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RearRightPowerWindowsSwitchControl(
      ::grpc::CallbackServerContext* /*context*/, const ::UnityAPI::RearRightPowerWindowsSwitchRequest* /*request*/, ::UnityAPI::RearRightPowerWindowsSwitchReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RearRightPowerWindowsSwitchControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::UnityAPI::RearRightPowerWindowsSwitchRequest* /*request*/, ::UnityAPI::RearRightPowerWindowsSwitchReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RearLeftPowerWindowsSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_RearLeftPowerWindowsSwitchControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(35,
          new ::grpc::internal::CallbackUnaryHandler< ::UnityAPI::RearLeftPowerWindowsSwitchRequest, ::UnityAPI::RearLeftPowerWindowsSwitchReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::UnityAPI::RearLeftPowerWindowsSwitchRequest* request, ::UnityAPI::RearLeftPowerWindowsSwitchReply* response) { return this->RearLeftPowerWindowsSwitchControl(context, request, response); }));}
    void SetMessageAllocatorFor_RearLeftPowerWindowsSwitchControl(
        ::grpc::experimental::MessageAllocator< ::UnityAPI::RearLeftPowerWindowsSwitchRequest, ::UnityAPI::RearLeftPowerWindowsSwitchReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(35);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(35);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::UnityAPI::RearLeftPowerWindowsSwitchRequest, ::UnityAPI::RearLeftPowerWindowsSwitchReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_RearLeftPowerWindowsSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearLeftPowerWindowsSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearLeftPowerWindowsSwitchRequest* /*request*/, ::UnityAPI::RearLeftPowerWindowsSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RearLeftPowerWindowsSwitchControl(
      ::grpc::CallbackServerContext* /*context*/, const ::UnityAPI::RearLeftPowerWindowsSwitchRequest* /*request*/, ::UnityAPI::RearLeftPowerWindowsSwitchReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RearLeftPowerWindowsSwitchControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::UnityAPI::RearLeftPowerWindowsSwitchRequest* /*request*/, ::UnityAPI::RearLeftPowerWindowsSwitchReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_HornControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_HornControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(36,
          new ::grpc::internal::CallbackUnaryHandler< ::UnityAPI::HornRequest, ::UnityAPI::HornReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::UnityAPI::HornRequest* request, ::UnityAPI::HornReply* response) { return this->HornControl(context, request, response); }));}
    void SetMessageAllocatorFor_HornControl(
        ::grpc::experimental::MessageAllocator< ::UnityAPI::HornRequest, ::UnityAPI::HornReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(36);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(36);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::UnityAPI::HornRequest, ::UnityAPI::HornReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_HornControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HornControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::HornRequest* /*request*/, ::UnityAPI::HornReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* HornControl(
      ::grpc::CallbackServerContext* /*context*/, const ::UnityAPI::HornRequest* /*request*/, ::UnityAPI::HornReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* HornControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::UnityAPI::HornRequest* /*request*/, ::UnityAPI::HornReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_BuzzerControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_BuzzerControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(37,
          new ::grpc::internal::CallbackUnaryHandler< ::UnityAPI::BuzzerRequest, ::UnityAPI::BuzzerReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::UnityAPI::BuzzerRequest* request, ::UnityAPI::BuzzerReply* response) { return this->BuzzerControl(context, request, response); }));}
    void SetMessageAllocatorFor_BuzzerControl(
        ::grpc::experimental::MessageAllocator< ::UnityAPI::BuzzerRequest, ::UnityAPI::BuzzerReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(37);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(37);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::UnityAPI::BuzzerRequest, ::UnityAPI::BuzzerReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_BuzzerControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BuzzerControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::BuzzerRequest* /*request*/, ::UnityAPI::BuzzerReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* BuzzerControl(
      ::grpc::CallbackServerContext* /*context*/, const ::UnityAPI::BuzzerRequest* /*request*/, ::UnityAPI::BuzzerReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* BuzzerControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::UnityAPI::BuzzerRequest* /*request*/, ::UnityAPI::BuzzerReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AirConditionerControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AirConditionerControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(38,
          new ::grpc::internal::CallbackUnaryHandler< ::UnityAPI::AirConditionerRequest, ::UnityAPI::AirConditionerReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::UnityAPI::AirConditionerRequest* request, ::UnityAPI::AirConditionerReply* response) { return this->AirConditionerControl(context, request, response); }));}
    void SetMessageAllocatorFor_AirConditionerControl(
        ::grpc::experimental::MessageAllocator< ::UnityAPI::AirConditionerRequest, ::UnityAPI::AirConditionerReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(38);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(38);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::UnityAPI::AirConditionerRequest, ::UnityAPI::AirConditionerReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_AirConditionerControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AirConditionerControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::AirConditionerRequest* /*request*/, ::UnityAPI::AirConditionerReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AirConditionerControl(
      ::grpc::CallbackServerContext* /*context*/, const ::UnityAPI::AirConditionerRequest* /*request*/, ::UnityAPI::AirConditionerReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AirConditionerControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::UnityAPI::AirConditionerRequest* /*request*/, ::UnityAPI::AirConditionerReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AirConditionerTemperatureControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AirConditionerTemperatureControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(39,
          new ::grpc::internal::CallbackUnaryHandler< ::UnityAPI::AirCondTemperatureRequest, ::UnityAPI::AirCondTemperatureReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::UnityAPI::AirCondTemperatureRequest* request, ::UnityAPI::AirCondTemperatureReply* response) { return this->AirConditionerTemperatureControl(context, request, response); }));}
    void SetMessageAllocatorFor_AirConditionerTemperatureControl(
        ::grpc::experimental::MessageAllocator< ::UnityAPI::AirCondTemperatureRequest, ::UnityAPI::AirCondTemperatureReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(39);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(39);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::UnityAPI::AirCondTemperatureRequest, ::UnityAPI::AirCondTemperatureReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_AirConditionerTemperatureControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AirConditionerTemperatureControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::AirCondTemperatureRequest* /*request*/, ::UnityAPI::AirCondTemperatureReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AirConditionerTemperatureControl(
      ::grpc::CallbackServerContext* /*context*/, const ::UnityAPI::AirCondTemperatureRequest* /*request*/, ::UnityAPI::AirCondTemperatureReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AirConditionerTemperatureControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::UnityAPI::AirCondTemperatureRequest* /*request*/, ::UnityAPI::AirCondTemperatureReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AirConditionerFanSpeedControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AirConditionerFanSpeedControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(40,
          new ::grpc::internal::CallbackUnaryHandler< ::UnityAPI::AirConditionerFanSpeedRequest, ::UnityAPI::AirConditionerFanSpeedReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::UnityAPI::AirConditionerFanSpeedRequest* request, ::UnityAPI::AirConditionerFanSpeedReply* response) { return this->AirConditionerFanSpeedControl(context, request, response); }));}
    void SetMessageAllocatorFor_AirConditionerFanSpeedControl(
        ::grpc::experimental::MessageAllocator< ::UnityAPI::AirConditionerFanSpeedRequest, ::UnityAPI::AirConditionerFanSpeedReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(40);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(40);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::UnityAPI::AirConditionerFanSpeedRequest, ::UnityAPI::AirConditionerFanSpeedReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_AirConditionerFanSpeedControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AirConditionerFanSpeedControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::AirConditionerFanSpeedRequest* /*request*/, ::UnityAPI::AirConditionerFanSpeedReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AirConditionerFanSpeedControl(
      ::grpc::CallbackServerContext* /*context*/, const ::UnityAPI::AirConditionerFanSpeedRequest* /*request*/, ::UnityAPI::AirConditionerFanSpeedReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AirConditionerFanSpeedControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::UnityAPI::AirConditionerFanSpeedRequest* /*request*/, ::UnityAPI::AirConditionerFanSpeedReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_HandlingControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_HandlingControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(41,
          new ::grpc::internal::CallbackUnaryHandler< ::UnityAPI::HandlingRequest, ::UnityAPI::HandlingReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::UnityAPI::HandlingRequest* request, ::UnityAPI::HandlingReply* response) { return this->HandlingControl(context, request, response); }));}
    void SetMessageAllocatorFor_HandlingControl(
        ::grpc::experimental::MessageAllocator< ::UnityAPI::HandlingRequest, ::UnityAPI::HandlingReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(41);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(41);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::UnityAPI::HandlingRequest, ::UnityAPI::HandlingReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_HandlingControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HandlingControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::HandlingRequest* /*request*/, ::UnityAPI::HandlingReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* HandlingControl(
      ::grpc::CallbackServerContext* /*context*/, const ::UnityAPI::HandlingRequest* /*request*/, ::UnityAPI::HandlingReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* HandlingControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::UnityAPI::HandlingRequest* /*request*/, ::UnityAPI::HandlingReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CentralDoorLockSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_CentralDoorLockSwitchControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(42,
          new ::grpc::internal::CallbackUnaryHandler< ::UnityAPI::CentralDoorLockSwitchRequest, ::UnityAPI::CentralDoorLockSwitchReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::UnityAPI::CentralDoorLockSwitchRequest* request, ::UnityAPI::CentralDoorLockSwitchReply* response) { return this->CentralDoorLockSwitchControl(context, request, response); }));}
    void SetMessageAllocatorFor_CentralDoorLockSwitchControl(
        ::grpc::experimental::MessageAllocator< ::UnityAPI::CentralDoorLockSwitchRequest, ::UnityAPI::CentralDoorLockSwitchReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(42);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(42);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::UnityAPI::CentralDoorLockSwitchRequest, ::UnityAPI::CentralDoorLockSwitchReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CentralDoorLockSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CentralDoorLockSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::CentralDoorLockSwitchRequest* /*request*/, ::UnityAPI::CentralDoorLockSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CentralDoorLockSwitchControl(
      ::grpc::CallbackServerContext* /*context*/, const ::UnityAPI::CentralDoorLockSwitchRequest* /*request*/, ::UnityAPI::CentralDoorLockSwitchReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CentralDoorLockSwitchControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::UnityAPI::CentralDoorLockSwitchRequest* /*request*/, ::UnityAPI::CentralDoorLockSwitchReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_FrontRightDoorLockSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_FrontRightDoorLockSwitchControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(43,
          new ::grpc::internal::CallbackUnaryHandler< ::UnityAPI::FrontRightDoorLockSwitchRequest, ::UnityAPI::FrontRightDoorLockSwitchReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::UnityAPI::FrontRightDoorLockSwitchRequest* request, ::UnityAPI::FrontRightDoorLockSwitchReply* response) { return this->FrontRightDoorLockSwitchControl(context, request, response); }));}
    void SetMessageAllocatorFor_FrontRightDoorLockSwitchControl(
        ::grpc::experimental::MessageAllocator< ::UnityAPI::FrontRightDoorLockSwitchRequest, ::UnityAPI::FrontRightDoorLockSwitchReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(43);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(43);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::UnityAPI::FrontRightDoorLockSwitchRequest, ::UnityAPI::FrontRightDoorLockSwitchReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_FrontRightDoorLockSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontRightDoorLockSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontRightDoorLockSwitchRequest* /*request*/, ::UnityAPI::FrontRightDoorLockSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FrontRightDoorLockSwitchControl(
      ::grpc::CallbackServerContext* /*context*/, const ::UnityAPI::FrontRightDoorLockSwitchRequest* /*request*/, ::UnityAPI::FrontRightDoorLockSwitchReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FrontRightDoorLockSwitchControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::UnityAPI::FrontRightDoorLockSwitchRequest* /*request*/, ::UnityAPI::FrontRightDoorLockSwitchReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_FrontLeftDoorLockSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_FrontLeftDoorLockSwitchControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(44,
          new ::grpc::internal::CallbackUnaryHandler< ::UnityAPI::FrontLeftDoorLockSwitchRequest, ::UnityAPI::FrontLeftDoorLockSwitchReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::UnityAPI::FrontLeftDoorLockSwitchRequest* request, ::UnityAPI::FrontLeftDoorLockSwitchReply* response) { return this->FrontLeftDoorLockSwitchControl(context, request, response); }));}
    void SetMessageAllocatorFor_FrontLeftDoorLockSwitchControl(
        ::grpc::experimental::MessageAllocator< ::UnityAPI::FrontLeftDoorLockSwitchRequest, ::UnityAPI::FrontLeftDoorLockSwitchReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(44);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(44);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::UnityAPI::FrontLeftDoorLockSwitchRequest, ::UnityAPI::FrontLeftDoorLockSwitchReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_FrontLeftDoorLockSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontLeftDoorLockSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontLeftDoorLockSwitchRequest* /*request*/, ::UnityAPI::FrontLeftDoorLockSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FrontLeftDoorLockSwitchControl(
      ::grpc::CallbackServerContext* /*context*/, const ::UnityAPI::FrontLeftDoorLockSwitchRequest* /*request*/, ::UnityAPI::FrontLeftDoorLockSwitchReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FrontLeftDoorLockSwitchControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::UnityAPI::FrontLeftDoorLockSwitchRequest* /*request*/, ::UnityAPI::FrontLeftDoorLockSwitchReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RearRightDoorLockSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_RearRightDoorLockSwitchControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(45,
          new ::grpc::internal::CallbackUnaryHandler< ::UnityAPI::RearRightDoorLockSwitchRequest, ::UnityAPI::RearRightDoorLockSwitchReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::UnityAPI::RearRightDoorLockSwitchRequest* request, ::UnityAPI::RearRightDoorLockSwitchReply* response) { return this->RearRightDoorLockSwitchControl(context, request, response); }));}
    void SetMessageAllocatorFor_RearRightDoorLockSwitchControl(
        ::grpc::experimental::MessageAllocator< ::UnityAPI::RearRightDoorLockSwitchRequest, ::UnityAPI::RearRightDoorLockSwitchReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(45);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(45);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::UnityAPI::RearRightDoorLockSwitchRequest, ::UnityAPI::RearRightDoorLockSwitchReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_RearRightDoorLockSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearRightDoorLockSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearRightDoorLockSwitchRequest* /*request*/, ::UnityAPI::RearRightDoorLockSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RearRightDoorLockSwitchControl(
      ::grpc::CallbackServerContext* /*context*/, const ::UnityAPI::RearRightDoorLockSwitchRequest* /*request*/, ::UnityAPI::RearRightDoorLockSwitchReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RearRightDoorLockSwitchControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::UnityAPI::RearRightDoorLockSwitchRequest* /*request*/, ::UnityAPI::RearRightDoorLockSwitchReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RearLeftDoorLockSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_RearLeftDoorLockSwitchControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(46,
          new ::grpc::internal::CallbackUnaryHandler< ::UnityAPI::RearLeftDoorLockSwitchRequest, ::UnityAPI::RearLeftDoorLockSwitchReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::UnityAPI::RearLeftDoorLockSwitchRequest* request, ::UnityAPI::RearLeftDoorLockSwitchReply* response) { return this->RearLeftDoorLockSwitchControl(context, request, response); }));}
    void SetMessageAllocatorFor_RearLeftDoorLockSwitchControl(
        ::grpc::experimental::MessageAllocator< ::UnityAPI::RearLeftDoorLockSwitchRequest, ::UnityAPI::RearLeftDoorLockSwitchReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(46);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(46);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::UnityAPI::RearLeftDoorLockSwitchRequest, ::UnityAPI::RearLeftDoorLockSwitchReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_RearLeftDoorLockSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearLeftDoorLockSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearLeftDoorLockSwitchRequest* /*request*/, ::UnityAPI::RearLeftDoorLockSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RearLeftDoorLockSwitchControl(
      ::grpc::CallbackServerContext* /*context*/, const ::UnityAPI::RearLeftDoorLockSwitchRequest* /*request*/, ::UnityAPI::RearLeftDoorLockSwitchReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RearLeftDoorLockSwitchControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::UnityAPI::RearLeftDoorLockSwitchRequest* /*request*/, ::UnityAPI::RearLeftDoorLockSwitchReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_get_database : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_get_database() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(47,
          new ::grpc::internal::CallbackUnaryHandler< ::UnityAPI::getDBRequest, ::UnityAPI::getDBReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::UnityAPI::getDBRequest* request, ::UnityAPI::getDBReply* response) { return this->get_database(context, request, response); }));}
    void SetMessageAllocatorFor_get_database(
        ::grpc::experimental::MessageAllocator< ::UnityAPI::getDBRequest, ::UnityAPI::getDBReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(47);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(47);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::UnityAPI::getDBRequest, ::UnityAPI::getDBReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_get_database() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_database(::grpc::ServerContext* /*context*/, const ::UnityAPI::getDBRequest* /*request*/, ::UnityAPI::getDBReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* get_database(
      ::grpc::CallbackServerContext* /*context*/, const ::UnityAPI::getDBRequest* /*request*/, ::UnityAPI::getDBReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* get_database(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::UnityAPI::getDBRequest* /*request*/, ::UnityAPI::getDBReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_send_update_database : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_send_update_database() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(48,
          new ::grpc::internal::CallbackUnaryHandler< ::UnityAPI::setDBRequest, ::UnityAPI::setDBReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::UnityAPI::setDBRequest* request, ::UnityAPI::setDBReply* response) { return this->send_update_database(context, request, response); }));}
    void SetMessageAllocatorFor_send_update_database(
        ::grpc::experimental::MessageAllocator< ::UnityAPI::setDBRequest, ::UnityAPI::setDBReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(48);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(48);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::UnityAPI::setDBRequest, ::UnityAPI::setDBReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_send_update_database() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status send_update_database(::grpc::ServerContext* /*context*/, const ::UnityAPI::setDBRequest* /*request*/, ::UnityAPI::setDBReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* send_update_database(
      ::grpc::CallbackServerContext* /*context*/, const ::UnityAPI::setDBRequest* /*request*/, ::UnityAPI::setDBReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* send_update_database(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::UnityAPI::setDBRequest* /*request*/, ::UnityAPI::setDBReply* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_FrontLowLightControl<ExperimentalWithCallbackMethod_FrontHighLightControl<ExperimentalWithCallbackMethod_RearLightControl<ExperimentalWithCallbackMethod_FrontDaytimeLightControl<ExperimentalWithCallbackMethod_BrakeLightControl<ExperimentalWithCallbackMethod_ReverseLightControl<ExperimentalWithCallbackMethod_FrontFogLightControl<ExperimentalWithCallbackMethod_RearFogLightControl<ExperimentalWithCallbackMethod_ClearanceLampControl<ExperimentalWithCallbackMethod_FrontLeftBlinkerLightControl<ExperimentalWithCallbackMethod_FrontRightBlinkerLightControl<ExperimentalWithCallbackMethod_RearLeftBlinkerLightControl<ExperimentalWithCallbackMethod_RearRightBlinkerLightControl<ExperimentalWithCallbackMethod_FrontWiperControl<ExperimentalWithCallbackMethod_RearWiperControl<ExperimentalWithCallbackMethod_LeftSideMirrorControl<ExperimentalWithCallbackMethod_RightSideMirrorControl<ExperimentalWithCallbackMethod_FrontRightDoorControl<ExperimentalWithCallbackMethod_FrontLeftDoorControl<ExperimentalWithCallbackMethod_RearRightDoorControl<ExperimentalWithCallbackMethod_RearLeftDoorControl<ExperimentalWithCallbackMethod_TrunkControl<ExperimentalWithCallbackMethod_SunRoofControl<ExperimentalWithCallbackMethod_FrontRightPowerWindowsControl<ExperimentalWithCallbackMethod_FrontLeftPowerWindowsControl<ExperimentalWithCallbackMethod_RearRightPowerWindowsControl<ExperimentalWithCallbackMethod_RearLeftPowerWindowsControl<ExperimentalWithCallbackMethod_SideMirrorSwitchControl<ExperimentalWithCallbackMethod_InstrumentLightControl<ExperimentalWithCallbackMethod_PassgenerRoomDomeLightControl<ExperimentalWithCallbackMethod_ReadingLightDriverSideControl<ExperimentalWithCallbackMethod_ReadingLightPassgenerSideControl<ExperimentalWithCallbackMethod_FrontRightPowerWindowsSwitchControl<ExperimentalWithCallbackMethod_FrontLeftPowerWindowsSwitchControl<ExperimentalWithCallbackMethod_RearRightPowerWindowsSwitchControl<ExperimentalWithCallbackMethod_RearLeftPowerWindowsSwitchControl<ExperimentalWithCallbackMethod_HornControl<ExperimentalWithCallbackMethod_BuzzerControl<ExperimentalWithCallbackMethod_AirConditionerControl<ExperimentalWithCallbackMethod_AirConditionerTemperatureControl<ExperimentalWithCallbackMethod_AirConditionerFanSpeedControl<ExperimentalWithCallbackMethod_HandlingControl<ExperimentalWithCallbackMethod_CentralDoorLockSwitchControl<ExperimentalWithCallbackMethod_FrontRightDoorLockSwitchControl<ExperimentalWithCallbackMethod_FrontLeftDoorLockSwitchControl<ExperimentalWithCallbackMethod_RearRightDoorLockSwitchControl<ExperimentalWithCallbackMethod_RearLeftDoorLockSwitchControl<ExperimentalWithCallbackMethod_get_database<ExperimentalWithCallbackMethod_send_update_database<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_FrontLowLightControl<ExperimentalWithCallbackMethod_FrontHighLightControl<ExperimentalWithCallbackMethod_RearLightControl<ExperimentalWithCallbackMethod_FrontDaytimeLightControl<ExperimentalWithCallbackMethod_BrakeLightControl<ExperimentalWithCallbackMethod_ReverseLightControl<ExperimentalWithCallbackMethod_FrontFogLightControl<ExperimentalWithCallbackMethod_RearFogLightControl<ExperimentalWithCallbackMethod_ClearanceLampControl<ExperimentalWithCallbackMethod_FrontLeftBlinkerLightControl<ExperimentalWithCallbackMethod_FrontRightBlinkerLightControl<ExperimentalWithCallbackMethod_RearLeftBlinkerLightControl<ExperimentalWithCallbackMethod_RearRightBlinkerLightControl<ExperimentalWithCallbackMethod_FrontWiperControl<ExperimentalWithCallbackMethod_RearWiperControl<ExperimentalWithCallbackMethod_LeftSideMirrorControl<ExperimentalWithCallbackMethod_RightSideMirrorControl<ExperimentalWithCallbackMethod_FrontRightDoorControl<ExperimentalWithCallbackMethod_FrontLeftDoorControl<ExperimentalWithCallbackMethod_RearRightDoorControl<ExperimentalWithCallbackMethod_RearLeftDoorControl<ExperimentalWithCallbackMethod_TrunkControl<ExperimentalWithCallbackMethod_SunRoofControl<ExperimentalWithCallbackMethod_FrontRightPowerWindowsControl<ExperimentalWithCallbackMethod_FrontLeftPowerWindowsControl<ExperimentalWithCallbackMethod_RearRightPowerWindowsControl<ExperimentalWithCallbackMethod_RearLeftPowerWindowsControl<ExperimentalWithCallbackMethod_SideMirrorSwitchControl<ExperimentalWithCallbackMethod_InstrumentLightControl<ExperimentalWithCallbackMethod_PassgenerRoomDomeLightControl<ExperimentalWithCallbackMethod_ReadingLightDriverSideControl<ExperimentalWithCallbackMethod_ReadingLightPassgenerSideControl<ExperimentalWithCallbackMethod_FrontRightPowerWindowsSwitchControl<ExperimentalWithCallbackMethod_FrontLeftPowerWindowsSwitchControl<ExperimentalWithCallbackMethod_RearRightPowerWindowsSwitchControl<ExperimentalWithCallbackMethod_RearLeftPowerWindowsSwitchControl<ExperimentalWithCallbackMethod_HornControl<ExperimentalWithCallbackMethod_BuzzerControl<ExperimentalWithCallbackMethod_AirConditionerControl<ExperimentalWithCallbackMethod_AirConditionerTemperatureControl<ExperimentalWithCallbackMethod_AirConditionerFanSpeedControl<ExperimentalWithCallbackMethod_HandlingControl<ExperimentalWithCallbackMethod_CentralDoorLockSwitchControl<ExperimentalWithCallbackMethod_FrontRightDoorLockSwitchControl<ExperimentalWithCallbackMethod_FrontLeftDoorLockSwitchControl<ExperimentalWithCallbackMethod_RearRightDoorLockSwitchControl<ExperimentalWithCallbackMethod_RearLeftDoorLockSwitchControl<ExperimentalWithCallbackMethod_get_database<ExperimentalWithCallbackMethod_send_update_database<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_FrontLowLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_FrontLowLightControl() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_FrontLowLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontLowLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontLowLightRequest* /*request*/, ::UnityAPI::FrontLowLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_FrontHighLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_FrontHighLightControl() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_FrontHighLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontHighLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontHighLightRequest* /*request*/, ::UnityAPI::FrontHighLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RearLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RearLightControl() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_RearLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearLightRequest* /*request*/, ::UnityAPI::RearLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_FrontDaytimeLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_FrontDaytimeLightControl() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_FrontDaytimeLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontDaytimeLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontDaytimeLightRequest* /*request*/, ::UnityAPI::FrontDaytimeLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_BrakeLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_BrakeLightControl() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_BrakeLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BrakeLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::BrakeLightRequest* /*request*/, ::UnityAPI::BrakeLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ReverseLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ReverseLightControl() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_ReverseLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReverseLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::ReverseLightRequest* /*request*/, ::UnityAPI::ReverseLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_FrontFogLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_FrontFogLightControl() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_FrontFogLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontFogLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontFogLightRequest* /*request*/, ::UnityAPI::FrontFogLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RearFogLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RearFogLightControl() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_RearFogLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearFogLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearFogLightRequest* /*request*/, ::UnityAPI::RearFogLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ClearanceLampControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ClearanceLampControl() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_ClearanceLampControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClearanceLampControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::ClearanceLampRequest* /*request*/, ::UnityAPI::ClearanceLampReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_FrontLeftBlinkerLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_FrontLeftBlinkerLightControl() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_FrontLeftBlinkerLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontLeftBlinkerLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontLeftBlinkerLightRequest* /*request*/, ::UnityAPI::FrontLeftBlinkerLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_FrontRightBlinkerLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_FrontRightBlinkerLightControl() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_FrontRightBlinkerLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontRightBlinkerLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontRightBlinkerLightRequest* /*request*/, ::UnityAPI::FrontRightBlinkerLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RearLeftBlinkerLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RearLeftBlinkerLightControl() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_RearLeftBlinkerLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearLeftBlinkerLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearLeftBlinkerLightRequest* /*request*/, ::UnityAPI::RearLeftBlinkerLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RearRightBlinkerLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RearRightBlinkerLightControl() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_RearRightBlinkerLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearRightBlinkerLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearRightBlinkerLightRequest* /*request*/, ::UnityAPI::RearRightBlinkerLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_FrontWiperControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_FrontWiperControl() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_FrontWiperControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontWiperControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontWiperRequest* /*request*/, ::UnityAPI::FrontWiperReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RearWiperControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RearWiperControl() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_RearWiperControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearWiperControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearWiperRequest* /*request*/, ::UnityAPI::RearWiperReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LeftSideMirrorControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LeftSideMirrorControl() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_LeftSideMirrorControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeftSideMirrorControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::LeftSideMirrorRequest* /*request*/, ::UnityAPI::LeftSideMirrorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RightSideMirrorControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RightSideMirrorControl() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_RightSideMirrorControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RightSideMirrorControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RightSideMirrorRequest* /*request*/, ::UnityAPI::RightSideMirrorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_FrontRightDoorControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_FrontRightDoorControl() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_FrontRightDoorControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontRightDoorControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontRightDoorRequest* /*request*/, ::UnityAPI::FrontRightDoorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_FrontLeftDoorControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_FrontLeftDoorControl() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_FrontLeftDoorControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontLeftDoorControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontLeftDoorRequest* /*request*/, ::UnityAPI::FrontLeftDoorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RearRightDoorControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RearRightDoorControl() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_RearRightDoorControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearRightDoorControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearRightDoorRequest* /*request*/, ::UnityAPI::RearRightDoorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RearLeftDoorControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RearLeftDoorControl() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_RearLeftDoorControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearLeftDoorControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearLeftDoorRequest* /*request*/, ::UnityAPI::RearLeftDoorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_TrunkControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_TrunkControl() {
      ::grpc::Service::MarkMethodGeneric(21);
    }
    ~WithGenericMethod_TrunkControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TrunkControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::TrunkRequest* /*request*/, ::UnityAPI::TrunkReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SunRoofControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SunRoofControl() {
      ::grpc::Service::MarkMethodGeneric(22);
    }
    ~WithGenericMethod_SunRoofControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SunRoofControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::SunRoofRequest* /*request*/, ::UnityAPI::SunRoofReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_FrontRightPowerWindowsControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_FrontRightPowerWindowsControl() {
      ::grpc::Service::MarkMethodGeneric(23);
    }
    ~WithGenericMethod_FrontRightPowerWindowsControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontRightPowerWindowsControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontRightPowerWindowsRequest* /*request*/, ::UnityAPI::FrontRightPowerWindowsReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_FrontLeftPowerWindowsControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_FrontLeftPowerWindowsControl() {
      ::grpc::Service::MarkMethodGeneric(24);
    }
    ~WithGenericMethod_FrontLeftPowerWindowsControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontLeftPowerWindowsControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontLeftPowerWindowsRequest* /*request*/, ::UnityAPI::FrontLeftPowerWindowsReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RearRightPowerWindowsControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RearRightPowerWindowsControl() {
      ::grpc::Service::MarkMethodGeneric(25);
    }
    ~WithGenericMethod_RearRightPowerWindowsControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearRightPowerWindowsControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearRightPowerWindowsRequest* /*request*/, ::UnityAPI::RearRightPowerWindowsReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RearLeftPowerWindowsControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RearLeftPowerWindowsControl() {
      ::grpc::Service::MarkMethodGeneric(26);
    }
    ~WithGenericMethod_RearLeftPowerWindowsControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearLeftPowerWindowsControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearLeftPowerWindowsRequest* /*request*/, ::UnityAPI::RearLeftPowerWindowsReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SideMirrorSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SideMirrorSwitchControl() {
      ::grpc::Service::MarkMethodGeneric(27);
    }
    ~WithGenericMethod_SideMirrorSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SideMirrorSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::SideMirrorSwitchRequest* /*request*/, ::UnityAPI::SideMirrorSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_InstrumentLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_InstrumentLightControl() {
      ::grpc::Service::MarkMethodGeneric(28);
    }
    ~WithGenericMethod_InstrumentLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InstrumentLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::InstrumentLightRequest* /*request*/, ::UnityAPI::InstrumentLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PassgenerRoomDomeLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PassgenerRoomDomeLightControl() {
      ::grpc::Service::MarkMethodGeneric(29);
    }
    ~WithGenericMethod_PassgenerRoomDomeLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PassgenerRoomDomeLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::PassgenerRoomDomeLightRequest* /*request*/, ::UnityAPI::PassgenerRoomDomeLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ReadingLightDriverSideControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ReadingLightDriverSideControl() {
      ::grpc::Service::MarkMethodGeneric(30);
    }
    ~WithGenericMethod_ReadingLightDriverSideControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadingLightDriverSideControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::ReadingLightDriverSideRequest* /*request*/, ::UnityAPI::ReadingLightDriverSideReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ReadingLightPassgenerSideControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ReadingLightPassgenerSideControl() {
      ::grpc::Service::MarkMethodGeneric(31);
    }
    ~WithGenericMethod_ReadingLightPassgenerSideControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadingLightPassgenerSideControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::ReadingLightPassgenerSideRequest* /*request*/, ::UnityAPI::ReadingLightPassgenerSideReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_FrontRightPowerWindowsSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_FrontRightPowerWindowsSwitchControl() {
      ::grpc::Service::MarkMethodGeneric(32);
    }
    ~WithGenericMethod_FrontRightPowerWindowsSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontRightPowerWindowsSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontRightPowerWindowsSwitchRequest* /*request*/, ::UnityAPI::FrontRightPowerWindowsSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_FrontLeftPowerWindowsSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_FrontLeftPowerWindowsSwitchControl() {
      ::grpc::Service::MarkMethodGeneric(33);
    }
    ~WithGenericMethod_FrontLeftPowerWindowsSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontLeftPowerWindowsSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontLeftPowerWindowsSwitchRequest* /*request*/, ::UnityAPI::FrontLeftPowerWindowsSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RearRightPowerWindowsSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RearRightPowerWindowsSwitchControl() {
      ::grpc::Service::MarkMethodGeneric(34);
    }
    ~WithGenericMethod_RearRightPowerWindowsSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearRightPowerWindowsSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearRightPowerWindowsSwitchRequest* /*request*/, ::UnityAPI::RearRightPowerWindowsSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RearLeftPowerWindowsSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RearLeftPowerWindowsSwitchControl() {
      ::grpc::Service::MarkMethodGeneric(35);
    }
    ~WithGenericMethod_RearLeftPowerWindowsSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearLeftPowerWindowsSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearLeftPowerWindowsSwitchRequest* /*request*/, ::UnityAPI::RearLeftPowerWindowsSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_HornControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_HornControl() {
      ::grpc::Service::MarkMethodGeneric(36);
    }
    ~WithGenericMethod_HornControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HornControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::HornRequest* /*request*/, ::UnityAPI::HornReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_BuzzerControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_BuzzerControl() {
      ::grpc::Service::MarkMethodGeneric(37);
    }
    ~WithGenericMethod_BuzzerControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BuzzerControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::BuzzerRequest* /*request*/, ::UnityAPI::BuzzerReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AirConditionerControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AirConditionerControl() {
      ::grpc::Service::MarkMethodGeneric(38);
    }
    ~WithGenericMethod_AirConditionerControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AirConditionerControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::AirConditionerRequest* /*request*/, ::UnityAPI::AirConditionerReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AirConditionerTemperatureControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AirConditionerTemperatureControl() {
      ::grpc::Service::MarkMethodGeneric(39);
    }
    ~WithGenericMethod_AirConditionerTemperatureControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AirConditionerTemperatureControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::AirCondTemperatureRequest* /*request*/, ::UnityAPI::AirCondTemperatureReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AirConditionerFanSpeedControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AirConditionerFanSpeedControl() {
      ::grpc::Service::MarkMethodGeneric(40);
    }
    ~WithGenericMethod_AirConditionerFanSpeedControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AirConditionerFanSpeedControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::AirConditionerFanSpeedRequest* /*request*/, ::UnityAPI::AirConditionerFanSpeedReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_HandlingControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_HandlingControl() {
      ::grpc::Service::MarkMethodGeneric(41);
    }
    ~WithGenericMethod_HandlingControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HandlingControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::HandlingRequest* /*request*/, ::UnityAPI::HandlingReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CentralDoorLockSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CentralDoorLockSwitchControl() {
      ::grpc::Service::MarkMethodGeneric(42);
    }
    ~WithGenericMethod_CentralDoorLockSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CentralDoorLockSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::CentralDoorLockSwitchRequest* /*request*/, ::UnityAPI::CentralDoorLockSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_FrontRightDoorLockSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_FrontRightDoorLockSwitchControl() {
      ::grpc::Service::MarkMethodGeneric(43);
    }
    ~WithGenericMethod_FrontRightDoorLockSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontRightDoorLockSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontRightDoorLockSwitchRequest* /*request*/, ::UnityAPI::FrontRightDoorLockSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_FrontLeftDoorLockSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_FrontLeftDoorLockSwitchControl() {
      ::grpc::Service::MarkMethodGeneric(44);
    }
    ~WithGenericMethod_FrontLeftDoorLockSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontLeftDoorLockSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontLeftDoorLockSwitchRequest* /*request*/, ::UnityAPI::FrontLeftDoorLockSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RearRightDoorLockSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RearRightDoorLockSwitchControl() {
      ::grpc::Service::MarkMethodGeneric(45);
    }
    ~WithGenericMethod_RearRightDoorLockSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearRightDoorLockSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearRightDoorLockSwitchRequest* /*request*/, ::UnityAPI::RearRightDoorLockSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RearLeftDoorLockSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RearLeftDoorLockSwitchControl() {
      ::grpc::Service::MarkMethodGeneric(46);
    }
    ~WithGenericMethod_RearLeftDoorLockSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearLeftDoorLockSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearLeftDoorLockSwitchRequest* /*request*/, ::UnityAPI::RearLeftDoorLockSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_database : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_database() {
      ::grpc::Service::MarkMethodGeneric(47);
    }
    ~WithGenericMethod_get_database() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_database(::grpc::ServerContext* /*context*/, const ::UnityAPI::getDBRequest* /*request*/, ::UnityAPI::getDBReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_send_update_database : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_send_update_database() {
      ::grpc::Service::MarkMethodGeneric(48);
    }
    ~WithGenericMethod_send_update_database() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status send_update_database(::grpc::ServerContext* /*context*/, const ::UnityAPI::setDBRequest* /*request*/, ::UnityAPI::setDBReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_FrontLowLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_FrontLowLightControl() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_FrontLowLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontLowLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontLowLightRequest* /*request*/, ::UnityAPI::FrontLowLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFrontLowLightControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_FrontHighLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_FrontHighLightControl() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_FrontHighLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontHighLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontHighLightRequest* /*request*/, ::UnityAPI::FrontHighLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFrontHighLightControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RearLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RearLightControl() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_RearLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearLightRequest* /*request*/, ::UnityAPI::RearLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRearLightControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_FrontDaytimeLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_FrontDaytimeLightControl() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_FrontDaytimeLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontDaytimeLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontDaytimeLightRequest* /*request*/, ::UnityAPI::FrontDaytimeLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFrontDaytimeLightControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_BrakeLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_BrakeLightControl() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_BrakeLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BrakeLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::BrakeLightRequest* /*request*/, ::UnityAPI::BrakeLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBrakeLightControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ReverseLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ReverseLightControl() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_ReverseLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReverseLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::ReverseLightRequest* /*request*/, ::UnityAPI::ReverseLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReverseLightControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_FrontFogLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_FrontFogLightControl() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_FrontFogLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontFogLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontFogLightRequest* /*request*/, ::UnityAPI::FrontFogLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFrontFogLightControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RearFogLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RearFogLightControl() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_RearFogLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearFogLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearFogLightRequest* /*request*/, ::UnityAPI::RearFogLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRearFogLightControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ClearanceLampControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ClearanceLampControl() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_ClearanceLampControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClearanceLampControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::ClearanceLampRequest* /*request*/, ::UnityAPI::ClearanceLampReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestClearanceLampControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_FrontLeftBlinkerLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_FrontLeftBlinkerLightControl() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_FrontLeftBlinkerLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontLeftBlinkerLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontLeftBlinkerLightRequest* /*request*/, ::UnityAPI::FrontLeftBlinkerLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFrontLeftBlinkerLightControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_FrontRightBlinkerLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_FrontRightBlinkerLightControl() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_FrontRightBlinkerLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontRightBlinkerLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontRightBlinkerLightRequest* /*request*/, ::UnityAPI::FrontRightBlinkerLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFrontRightBlinkerLightControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RearLeftBlinkerLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RearLeftBlinkerLightControl() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_RearLeftBlinkerLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearLeftBlinkerLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearLeftBlinkerLightRequest* /*request*/, ::UnityAPI::RearLeftBlinkerLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRearLeftBlinkerLightControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RearRightBlinkerLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RearRightBlinkerLightControl() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_RearRightBlinkerLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearRightBlinkerLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearRightBlinkerLightRequest* /*request*/, ::UnityAPI::RearRightBlinkerLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRearRightBlinkerLightControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_FrontWiperControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_FrontWiperControl() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_FrontWiperControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontWiperControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontWiperRequest* /*request*/, ::UnityAPI::FrontWiperReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFrontWiperControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RearWiperControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RearWiperControl() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_RearWiperControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearWiperControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearWiperRequest* /*request*/, ::UnityAPI::RearWiperReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRearWiperControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LeftSideMirrorControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LeftSideMirrorControl() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_LeftSideMirrorControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeftSideMirrorControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::LeftSideMirrorRequest* /*request*/, ::UnityAPI::LeftSideMirrorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLeftSideMirrorControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RightSideMirrorControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RightSideMirrorControl() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_RightSideMirrorControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RightSideMirrorControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RightSideMirrorRequest* /*request*/, ::UnityAPI::RightSideMirrorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRightSideMirrorControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_FrontRightDoorControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_FrontRightDoorControl() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_FrontRightDoorControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontRightDoorControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontRightDoorRequest* /*request*/, ::UnityAPI::FrontRightDoorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFrontRightDoorControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_FrontLeftDoorControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_FrontLeftDoorControl() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_FrontLeftDoorControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontLeftDoorControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontLeftDoorRequest* /*request*/, ::UnityAPI::FrontLeftDoorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFrontLeftDoorControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RearRightDoorControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RearRightDoorControl() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_RearRightDoorControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearRightDoorControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearRightDoorRequest* /*request*/, ::UnityAPI::RearRightDoorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRearRightDoorControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RearLeftDoorControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RearLeftDoorControl() {
      ::grpc::Service::MarkMethodRaw(20);
    }
    ~WithRawMethod_RearLeftDoorControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearLeftDoorControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearLeftDoorRequest* /*request*/, ::UnityAPI::RearLeftDoorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRearLeftDoorControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_TrunkControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_TrunkControl() {
      ::grpc::Service::MarkMethodRaw(21);
    }
    ~WithRawMethod_TrunkControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TrunkControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::TrunkRequest* /*request*/, ::UnityAPI::TrunkReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTrunkControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SunRoofControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SunRoofControl() {
      ::grpc::Service::MarkMethodRaw(22);
    }
    ~WithRawMethod_SunRoofControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SunRoofControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::SunRoofRequest* /*request*/, ::UnityAPI::SunRoofReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSunRoofControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_FrontRightPowerWindowsControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_FrontRightPowerWindowsControl() {
      ::grpc::Service::MarkMethodRaw(23);
    }
    ~WithRawMethod_FrontRightPowerWindowsControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontRightPowerWindowsControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontRightPowerWindowsRequest* /*request*/, ::UnityAPI::FrontRightPowerWindowsReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFrontRightPowerWindowsControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_FrontLeftPowerWindowsControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_FrontLeftPowerWindowsControl() {
      ::grpc::Service::MarkMethodRaw(24);
    }
    ~WithRawMethod_FrontLeftPowerWindowsControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontLeftPowerWindowsControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontLeftPowerWindowsRequest* /*request*/, ::UnityAPI::FrontLeftPowerWindowsReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFrontLeftPowerWindowsControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RearRightPowerWindowsControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RearRightPowerWindowsControl() {
      ::grpc::Service::MarkMethodRaw(25);
    }
    ~WithRawMethod_RearRightPowerWindowsControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearRightPowerWindowsControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearRightPowerWindowsRequest* /*request*/, ::UnityAPI::RearRightPowerWindowsReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRearRightPowerWindowsControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RearLeftPowerWindowsControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RearLeftPowerWindowsControl() {
      ::grpc::Service::MarkMethodRaw(26);
    }
    ~WithRawMethod_RearLeftPowerWindowsControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearLeftPowerWindowsControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearLeftPowerWindowsRequest* /*request*/, ::UnityAPI::RearLeftPowerWindowsReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRearLeftPowerWindowsControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SideMirrorSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SideMirrorSwitchControl() {
      ::grpc::Service::MarkMethodRaw(27);
    }
    ~WithRawMethod_SideMirrorSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SideMirrorSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::SideMirrorSwitchRequest* /*request*/, ::UnityAPI::SideMirrorSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSideMirrorSwitchControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_InstrumentLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_InstrumentLightControl() {
      ::grpc::Service::MarkMethodRaw(28);
    }
    ~WithRawMethod_InstrumentLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InstrumentLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::InstrumentLightRequest* /*request*/, ::UnityAPI::InstrumentLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestInstrumentLightControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PassgenerRoomDomeLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PassgenerRoomDomeLightControl() {
      ::grpc::Service::MarkMethodRaw(29);
    }
    ~WithRawMethod_PassgenerRoomDomeLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PassgenerRoomDomeLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::PassgenerRoomDomeLightRequest* /*request*/, ::UnityAPI::PassgenerRoomDomeLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPassgenerRoomDomeLightControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(29, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ReadingLightDriverSideControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ReadingLightDriverSideControl() {
      ::grpc::Service::MarkMethodRaw(30);
    }
    ~WithRawMethod_ReadingLightDriverSideControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadingLightDriverSideControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::ReadingLightDriverSideRequest* /*request*/, ::UnityAPI::ReadingLightDriverSideReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReadingLightDriverSideControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(30, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ReadingLightPassgenerSideControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ReadingLightPassgenerSideControl() {
      ::grpc::Service::MarkMethodRaw(31);
    }
    ~WithRawMethod_ReadingLightPassgenerSideControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadingLightPassgenerSideControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::ReadingLightPassgenerSideRequest* /*request*/, ::UnityAPI::ReadingLightPassgenerSideReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReadingLightPassgenerSideControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(31, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_FrontRightPowerWindowsSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_FrontRightPowerWindowsSwitchControl() {
      ::grpc::Service::MarkMethodRaw(32);
    }
    ~WithRawMethod_FrontRightPowerWindowsSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontRightPowerWindowsSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontRightPowerWindowsSwitchRequest* /*request*/, ::UnityAPI::FrontRightPowerWindowsSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFrontRightPowerWindowsSwitchControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(32, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_FrontLeftPowerWindowsSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_FrontLeftPowerWindowsSwitchControl() {
      ::grpc::Service::MarkMethodRaw(33);
    }
    ~WithRawMethod_FrontLeftPowerWindowsSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontLeftPowerWindowsSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontLeftPowerWindowsSwitchRequest* /*request*/, ::UnityAPI::FrontLeftPowerWindowsSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFrontLeftPowerWindowsSwitchControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(33, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RearRightPowerWindowsSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RearRightPowerWindowsSwitchControl() {
      ::grpc::Service::MarkMethodRaw(34);
    }
    ~WithRawMethod_RearRightPowerWindowsSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearRightPowerWindowsSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearRightPowerWindowsSwitchRequest* /*request*/, ::UnityAPI::RearRightPowerWindowsSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRearRightPowerWindowsSwitchControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(34, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RearLeftPowerWindowsSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RearLeftPowerWindowsSwitchControl() {
      ::grpc::Service::MarkMethodRaw(35);
    }
    ~WithRawMethod_RearLeftPowerWindowsSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearLeftPowerWindowsSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearLeftPowerWindowsSwitchRequest* /*request*/, ::UnityAPI::RearLeftPowerWindowsSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRearLeftPowerWindowsSwitchControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(35, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_HornControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_HornControl() {
      ::grpc::Service::MarkMethodRaw(36);
    }
    ~WithRawMethod_HornControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HornControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::HornRequest* /*request*/, ::UnityAPI::HornReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHornControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(36, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_BuzzerControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_BuzzerControl() {
      ::grpc::Service::MarkMethodRaw(37);
    }
    ~WithRawMethod_BuzzerControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BuzzerControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::BuzzerRequest* /*request*/, ::UnityAPI::BuzzerReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBuzzerControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(37, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AirConditionerControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AirConditionerControl() {
      ::grpc::Service::MarkMethodRaw(38);
    }
    ~WithRawMethod_AirConditionerControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AirConditionerControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::AirConditionerRequest* /*request*/, ::UnityAPI::AirConditionerReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAirConditionerControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(38, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AirConditionerTemperatureControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AirConditionerTemperatureControl() {
      ::grpc::Service::MarkMethodRaw(39);
    }
    ~WithRawMethod_AirConditionerTemperatureControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AirConditionerTemperatureControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::AirCondTemperatureRequest* /*request*/, ::UnityAPI::AirCondTemperatureReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAirConditionerTemperatureControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(39, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AirConditionerFanSpeedControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AirConditionerFanSpeedControl() {
      ::grpc::Service::MarkMethodRaw(40);
    }
    ~WithRawMethod_AirConditionerFanSpeedControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AirConditionerFanSpeedControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::AirConditionerFanSpeedRequest* /*request*/, ::UnityAPI::AirConditionerFanSpeedReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAirConditionerFanSpeedControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(40, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_HandlingControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_HandlingControl() {
      ::grpc::Service::MarkMethodRaw(41);
    }
    ~WithRawMethod_HandlingControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HandlingControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::HandlingRequest* /*request*/, ::UnityAPI::HandlingReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHandlingControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(41, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CentralDoorLockSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CentralDoorLockSwitchControl() {
      ::grpc::Service::MarkMethodRaw(42);
    }
    ~WithRawMethod_CentralDoorLockSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CentralDoorLockSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::CentralDoorLockSwitchRequest* /*request*/, ::UnityAPI::CentralDoorLockSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCentralDoorLockSwitchControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(42, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_FrontRightDoorLockSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_FrontRightDoorLockSwitchControl() {
      ::grpc::Service::MarkMethodRaw(43);
    }
    ~WithRawMethod_FrontRightDoorLockSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontRightDoorLockSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontRightDoorLockSwitchRequest* /*request*/, ::UnityAPI::FrontRightDoorLockSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFrontRightDoorLockSwitchControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(43, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_FrontLeftDoorLockSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_FrontLeftDoorLockSwitchControl() {
      ::grpc::Service::MarkMethodRaw(44);
    }
    ~WithRawMethod_FrontLeftDoorLockSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontLeftDoorLockSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontLeftDoorLockSwitchRequest* /*request*/, ::UnityAPI::FrontLeftDoorLockSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFrontLeftDoorLockSwitchControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(44, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RearRightDoorLockSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RearRightDoorLockSwitchControl() {
      ::grpc::Service::MarkMethodRaw(45);
    }
    ~WithRawMethod_RearRightDoorLockSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearRightDoorLockSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearRightDoorLockSwitchRequest* /*request*/, ::UnityAPI::RearRightDoorLockSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRearRightDoorLockSwitchControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(45, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RearLeftDoorLockSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RearLeftDoorLockSwitchControl() {
      ::grpc::Service::MarkMethodRaw(46);
    }
    ~WithRawMethod_RearLeftDoorLockSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearLeftDoorLockSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearLeftDoorLockSwitchRequest* /*request*/, ::UnityAPI::RearLeftDoorLockSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRearLeftDoorLockSwitchControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(46, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_database : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_database() {
      ::grpc::Service::MarkMethodRaw(47);
    }
    ~WithRawMethod_get_database() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_database(::grpc::ServerContext* /*context*/, const ::UnityAPI::getDBRequest* /*request*/, ::UnityAPI::getDBReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_database(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(47, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_send_update_database : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_send_update_database() {
      ::grpc::Service::MarkMethodRaw(48);
    }
    ~WithRawMethod_send_update_database() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status send_update_database(::grpc::ServerContext* /*context*/, const ::UnityAPI::setDBRequest* /*request*/, ::UnityAPI::setDBReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestsend_update_database(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(48, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_FrontLowLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_FrontLowLightControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->FrontLowLightControl(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_FrontLowLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontLowLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontLowLightRequest* /*request*/, ::UnityAPI::FrontLowLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FrontLowLightControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FrontLowLightControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_FrontHighLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_FrontHighLightControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->FrontHighLightControl(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_FrontHighLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontHighLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontHighLightRequest* /*request*/, ::UnityAPI::FrontHighLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FrontHighLightControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FrontHighLightControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RearLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_RearLightControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RearLightControl(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_RearLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearLightRequest* /*request*/, ::UnityAPI::RearLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RearLightControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RearLightControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_FrontDaytimeLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_FrontDaytimeLightControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->FrontDaytimeLightControl(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_FrontDaytimeLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontDaytimeLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontDaytimeLightRequest* /*request*/, ::UnityAPI::FrontDaytimeLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FrontDaytimeLightControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FrontDaytimeLightControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_BrakeLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_BrakeLightControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->BrakeLightControl(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_BrakeLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BrakeLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::BrakeLightRequest* /*request*/, ::UnityAPI::BrakeLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* BrakeLightControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* BrakeLightControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ReverseLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ReverseLightControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ReverseLightControl(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ReverseLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReverseLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::ReverseLightRequest* /*request*/, ::UnityAPI::ReverseLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ReverseLightControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ReverseLightControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_FrontFogLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_FrontFogLightControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->FrontFogLightControl(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_FrontFogLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontFogLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontFogLightRequest* /*request*/, ::UnityAPI::FrontFogLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FrontFogLightControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FrontFogLightControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RearFogLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_RearFogLightControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RearFogLightControl(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_RearFogLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearFogLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearFogLightRequest* /*request*/, ::UnityAPI::RearFogLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RearFogLightControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RearFogLightControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ClearanceLampControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ClearanceLampControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ClearanceLampControl(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ClearanceLampControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClearanceLampControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::ClearanceLampRequest* /*request*/, ::UnityAPI::ClearanceLampReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ClearanceLampControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ClearanceLampControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_FrontLeftBlinkerLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_FrontLeftBlinkerLightControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->FrontLeftBlinkerLightControl(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_FrontLeftBlinkerLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontLeftBlinkerLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontLeftBlinkerLightRequest* /*request*/, ::UnityAPI::FrontLeftBlinkerLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FrontLeftBlinkerLightControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FrontLeftBlinkerLightControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_FrontRightBlinkerLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_FrontRightBlinkerLightControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->FrontRightBlinkerLightControl(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_FrontRightBlinkerLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontRightBlinkerLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontRightBlinkerLightRequest* /*request*/, ::UnityAPI::FrontRightBlinkerLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FrontRightBlinkerLightControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FrontRightBlinkerLightControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RearLeftBlinkerLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_RearLeftBlinkerLightControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RearLeftBlinkerLightControl(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_RearLeftBlinkerLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearLeftBlinkerLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearLeftBlinkerLightRequest* /*request*/, ::UnityAPI::RearLeftBlinkerLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RearLeftBlinkerLightControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RearLeftBlinkerLightControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RearRightBlinkerLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_RearRightBlinkerLightControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RearRightBlinkerLightControl(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_RearRightBlinkerLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearRightBlinkerLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearRightBlinkerLightRequest* /*request*/, ::UnityAPI::RearRightBlinkerLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RearRightBlinkerLightControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RearRightBlinkerLightControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_FrontWiperControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_FrontWiperControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->FrontWiperControl(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_FrontWiperControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontWiperControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontWiperRequest* /*request*/, ::UnityAPI::FrontWiperReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FrontWiperControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FrontWiperControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RearWiperControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_RearWiperControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RearWiperControl(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_RearWiperControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearWiperControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearWiperRequest* /*request*/, ::UnityAPI::RearWiperReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RearWiperControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RearWiperControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_LeftSideMirrorControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_LeftSideMirrorControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->LeftSideMirrorControl(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_LeftSideMirrorControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeftSideMirrorControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::LeftSideMirrorRequest* /*request*/, ::UnityAPI::LeftSideMirrorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LeftSideMirrorControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LeftSideMirrorControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RightSideMirrorControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_RightSideMirrorControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RightSideMirrorControl(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_RightSideMirrorControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RightSideMirrorControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RightSideMirrorRequest* /*request*/, ::UnityAPI::RightSideMirrorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RightSideMirrorControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RightSideMirrorControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_FrontRightDoorControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_FrontRightDoorControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->FrontRightDoorControl(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_FrontRightDoorControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontRightDoorControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontRightDoorRequest* /*request*/, ::UnityAPI::FrontRightDoorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FrontRightDoorControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FrontRightDoorControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_FrontLeftDoorControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_FrontLeftDoorControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->FrontLeftDoorControl(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_FrontLeftDoorControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontLeftDoorControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontLeftDoorRequest* /*request*/, ::UnityAPI::FrontLeftDoorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FrontLeftDoorControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FrontLeftDoorControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RearRightDoorControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_RearRightDoorControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RearRightDoorControl(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_RearRightDoorControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearRightDoorControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearRightDoorRequest* /*request*/, ::UnityAPI::RearRightDoorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RearRightDoorControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RearRightDoorControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RearLeftDoorControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_RearLeftDoorControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RearLeftDoorControl(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_RearLeftDoorControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearLeftDoorControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearLeftDoorRequest* /*request*/, ::UnityAPI::RearLeftDoorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RearLeftDoorControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RearLeftDoorControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_TrunkControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_TrunkControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->TrunkControl(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_TrunkControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TrunkControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::TrunkRequest* /*request*/, ::UnityAPI::TrunkReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* TrunkControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* TrunkControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SunRoofControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SunRoofControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(22,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SunRoofControl(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_SunRoofControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SunRoofControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::SunRoofRequest* /*request*/, ::UnityAPI::SunRoofReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SunRoofControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SunRoofControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_FrontRightPowerWindowsControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_FrontRightPowerWindowsControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(23,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->FrontRightPowerWindowsControl(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_FrontRightPowerWindowsControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontRightPowerWindowsControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontRightPowerWindowsRequest* /*request*/, ::UnityAPI::FrontRightPowerWindowsReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FrontRightPowerWindowsControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FrontRightPowerWindowsControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_FrontLeftPowerWindowsControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_FrontLeftPowerWindowsControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(24,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->FrontLeftPowerWindowsControl(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_FrontLeftPowerWindowsControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontLeftPowerWindowsControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontLeftPowerWindowsRequest* /*request*/, ::UnityAPI::FrontLeftPowerWindowsReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FrontLeftPowerWindowsControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FrontLeftPowerWindowsControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RearRightPowerWindowsControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_RearRightPowerWindowsControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(25,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RearRightPowerWindowsControl(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_RearRightPowerWindowsControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearRightPowerWindowsControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearRightPowerWindowsRequest* /*request*/, ::UnityAPI::RearRightPowerWindowsReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RearRightPowerWindowsControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RearRightPowerWindowsControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RearLeftPowerWindowsControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_RearLeftPowerWindowsControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(26,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RearLeftPowerWindowsControl(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_RearLeftPowerWindowsControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearLeftPowerWindowsControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearLeftPowerWindowsRequest* /*request*/, ::UnityAPI::RearLeftPowerWindowsReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RearLeftPowerWindowsControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RearLeftPowerWindowsControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SideMirrorSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SideMirrorSwitchControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(27,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SideMirrorSwitchControl(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_SideMirrorSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SideMirrorSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::SideMirrorSwitchRequest* /*request*/, ::UnityAPI::SideMirrorSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SideMirrorSwitchControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SideMirrorSwitchControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_InstrumentLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_InstrumentLightControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(28,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->InstrumentLightControl(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_InstrumentLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InstrumentLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::InstrumentLightRequest* /*request*/, ::UnityAPI::InstrumentLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* InstrumentLightControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* InstrumentLightControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PassgenerRoomDomeLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PassgenerRoomDomeLightControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(29,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PassgenerRoomDomeLightControl(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PassgenerRoomDomeLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PassgenerRoomDomeLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::PassgenerRoomDomeLightRequest* /*request*/, ::UnityAPI::PassgenerRoomDomeLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PassgenerRoomDomeLightControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PassgenerRoomDomeLightControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ReadingLightDriverSideControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ReadingLightDriverSideControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(30,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ReadingLightDriverSideControl(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ReadingLightDriverSideControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadingLightDriverSideControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::ReadingLightDriverSideRequest* /*request*/, ::UnityAPI::ReadingLightDriverSideReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ReadingLightDriverSideControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ReadingLightDriverSideControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ReadingLightPassgenerSideControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ReadingLightPassgenerSideControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(31,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ReadingLightPassgenerSideControl(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ReadingLightPassgenerSideControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadingLightPassgenerSideControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::ReadingLightPassgenerSideRequest* /*request*/, ::UnityAPI::ReadingLightPassgenerSideReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ReadingLightPassgenerSideControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ReadingLightPassgenerSideControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_FrontRightPowerWindowsSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_FrontRightPowerWindowsSwitchControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(32,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->FrontRightPowerWindowsSwitchControl(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_FrontRightPowerWindowsSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontRightPowerWindowsSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontRightPowerWindowsSwitchRequest* /*request*/, ::UnityAPI::FrontRightPowerWindowsSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FrontRightPowerWindowsSwitchControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FrontRightPowerWindowsSwitchControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_FrontLeftPowerWindowsSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_FrontLeftPowerWindowsSwitchControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(33,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->FrontLeftPowerWindowsSwitchControl(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_FrontLeftPowerWindowsSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontLeftPowerWindowsSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontLeftPowerWindowsSwitchRequest* /*request*/, ::UnityAPI::FrontLeftPowerWindowsSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FrontLeftPowerWindowsSwitchControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FrontLeftPowerWindowsSwitchControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RearRightPowerWindowsSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_RearRightPowerWindowsSwitchControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(34,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RearRightPowerWindowsSwitchControl(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_RearRightPowerWindowsSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearRightPowerWindowsSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearRightPowerWindowsSwitchRequest* /*request*/, ::UnityAPI::RearRightPowerWindowsSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RearRightPowerWindowsSwitchControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RearRightPowerWindowsSwitchControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RearLeftPowerWindowsSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_RearLeftPowerWindowsSwitchControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(35,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RearLeftPowerWindowsSwitchControl(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_RearLeftPowerWindowsSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearLeftPowerWindowsSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearLeftPowerWindowsSwitchRequest* /*request*/, ::UnityAPI::RearLeftPowerWindowsSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RearLeftPowerWindowsSwitchControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RearLeftPowerWindowsSwitchControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_HornControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_HornControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(36,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->HornControl(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_HornControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HornControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::HornRequest* /*request*/, ::UnityAPI::HornReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* HornControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* HornControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_BuzzerControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_BuzzerControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(37,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->BuzzerControl(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_BuzzerControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BuzzerControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::BuzzerRequest* /*request*/, ::UnityAPI::BuzzerReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* BuzzerControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* BuzzerControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AirConditionerControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AirConditionerControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(38,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AirConditionerControl(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_AirConditionerControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AirConditionerControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::AirConditionerRequest* /*request*/, ::UnityAPI::AirConditionerReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AirConditionerControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AirConditionerControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AirConditionerTemperatureControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AirConditionerTemperatureControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(39,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AirConditionerTemperatureControl(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_AirConditionerTemperatureControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AirConditionerTemperatureControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::AirCondTemperatureRequest* /*request*/, ::UnityAPI::AirCondTemperatureReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AirConditionerTemperatureControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AirConditionerTemperatureControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AirConditionerFanSpeedControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AirConditionerFanSpeedControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(40,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AirConditionerFanSpeedControl(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_AirConditionerFanSpeedControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AirConditionerFanSpeedControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::AirConditionerFanSpeedRequest* /*request*/, ::UnityAPI::AirConditionerFanSpeedReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AirConditionerFanSpeedControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AirConditionerFanSpeedControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_HandlingControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_HandlingControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(41,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->HandlingControl(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_HandlingControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HandlingControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::HandlingRequest* /*request*/, ::UnityAPI::HandlingReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* HandlingControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* HandlingControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CentralDoorLockSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_CentralDoorLockSwitchControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(42,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CentralDoorLockSwitchControl(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_CentralDoorLockSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CentralDoorLockSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::CentralDoorLockSwitchRequest* /*request*/, ::UnityAPI::CentralDoorLockSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CentralDoorLockSwitchControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CentralDoorLockSwitchControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_FrontRightDoorLockSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_FrontRightDoorLockSwitchControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(43,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->FrontRightDoorLockSwitchControl(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_FrontRightDoorLockSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontRightDoorLockSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontRightDoorLockSwitchRequest* /*request*/, ::UnityAPI::FrontRightDoorLockSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FrontRightDoorLockSwitchControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FrontRightDoorLockSwitchControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_FrontLeftDoorLockSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_FrontLeftDoorLockSwitchControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(44,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->FrontLeftDoorLockSwitchControl(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_FrontLeftDoorLockSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrontLeftDoorLockSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontLeftDoorLockSwitchRequest* /*request*/, ::UnityAPI::FrontLeftDoorLockSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FrontLeftDoorLockSwitchControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FrontLeftDoorLockSwitchControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RearRightDoorLockSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_RearRightDoorLockSwitchControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(45,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RearRightDoorLockSwitchControl(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_RearRightDoorLockSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearRightDoorLockSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearRightDoorLockSwitchRequest* /*request*/, ::UnityAPI::RearRightDoorLockSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RearRightDoorLockSwitchControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RearRightDoorLockSwitchControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RearLeftDoorLockSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_RearLeftDoorLockSwitchControl() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(46,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RearLeftDoorLockSwitchControl(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_RearLeftDoorLockSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RearLeftDoorLockSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearLeftDoorLockSwitchRequest* /*request*/, ::UnityAPI::RearLeftDoorLockSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RearLeftDoorLockSwitchControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RearLeftDoorLockSwitchControl(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_get_database : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_get_database() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(47,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_database(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_get_database() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_database(::grpc::ServerContext* /*context*/, const ::UnityAPI::getDBRequest* /*request*/, ::UnityAPI::getDBReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* get_database(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* get_database(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_send_update_database : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_send_update_database() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(48,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->send_update_database(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_send_update_database() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status send_update_database(::grpc::ServerContext* /*context*/, const ::UnityAPI::setDBRequest* /*request*/, ::UnityAPI::setDBReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* send_update_database(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* send_update_database(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FrontLowLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_FrontLowLightControl() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::UnityAPI::FrontLowLightRequest, ::UnityAPI::FrontLowLightReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::UnityAPI::FrontLowLightRequest, ::UnityAPI::FrontLowLightReply>* streamer) {
                       return this->StreamedFrontLowLightControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_FrontLowLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FrontLowLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontLowLightRequest* /*request*/, ::UnityAPI::FrontLowLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFrontLowLightControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::UnityAPI::FrontLowLightRequest,::UnityAPI::FrontLowLightReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FrontHighLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_FrontHighLightControl() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::UnityAPI::FrontHighLightRequest, ::UnityAPI::FrontHighLightReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::UnityAPI::FrontHighLightRequest, ::UnityAPI::FrontHighLightReply>* streamer) {
                       return this->StreamedFrontHighLightControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_FrontHighLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FrontHighLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontHighLightRequest* /*request*/, ::UnityAPI::FrontHighLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFrontHighLightControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::UnityAPI::FrontHighLightRequest,::UnityAPI::FrontHighLightReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RearLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RearLightControl() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::UnityAPI::RearLightRequest, ::UnityAPI::RearLightReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::UnityAPI::RearLightRequest, ::UnityAPI::RearLightReply>* streamer) {
                       return this->StreamedRearLightControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RearLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RearLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearLightRequest* /*request*/, ::UnityAPI::RearLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRearLightControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::UnityAPI::RearLightRequest,::UnityAPI::RearLightReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FrontDaytimeLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_FrontDaytimeLightControl() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::UnityAPI::FrontDaytimeLightRequest, ::UnityAPI::FrontDaytimeLightReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::UnityAPI::FrontDaytimeLightRequest, ::UnityAPI::FrontDaytimeLightReply>* streamer) {
                       return this->StreamedFrontDaytimeLightControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_FrontDaytimeLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FrontDaytimeLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontDaytimeLightRequest* /*request*/, ::UnityAPI::FrontDaytimeLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFrontDaytimeLightControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::UnityAPI::FrontDaytimeLightRequest,::UnityAPI::FrontDaytimeLightReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_BrakeLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_BrakeLightControl() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::UnityAPI::BrakeLightRequest, ::UnityAPI::BrakeLightReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::UnityAPI::BrakeLightRequest, ::UnityAPI::BrakeLightReply>* streamer) {
                       return this->StreamedBrakeLightControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_BrakeLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status BrakeLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::BrakeLightRequest* /*request*/, ::UnityAPI::BrakeLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedBrakeLightControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::UnityAPI::BrakeLightRequest,::UnityAPI::BrakeLightReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ReverseLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ReverseLightControl() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::UnityAPI::ReverseLightRequest, ::UnityAPI::ReverseLightReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::UnityAPI::ReverseLightRequest, ::UnityAPI::ReverseLightReply>* streamer) {
                       return this->StreamedReverseLightControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ReverseLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ReverseLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::ReverseLightRequest* /*request*/, ::UnityAPI::ReverseLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedReverseLightControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::UnityAPI::ReverseLightRequest,::UnityAPI::ReverseLightReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FrontFogLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_FrontFogLightControl() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::UnityAPI::FrontFogLightRequest, ::UnityAPI::FrontFogLightReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::UnityAPI::FrontFogLightRequest, ::UnityAPI::FrontFogLightReply>* streamer) {
                       return this->StreamedFrontFogLightControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_FrontFogLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FrontFogLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontFogLightRequest* /*request*/, ::UnityAPI::FrontFogLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFrontFogLightControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::UnityAPI::FrontFogLightRequest,::UnityAPI::FrontFogLightReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RearFogLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RearFogLightControl() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::UnityAPI::RearFogLightRequest, ::UnityAPI::RearFogLightReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::UnityAPI::RearFogLightRequest, ::UnityAPI::RearFogLightReply>* streamer) {
                       return this->StreamedRearFogLightControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RearFogLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RearFogLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearFogLightRequest* /*request*/, ::UnityAPI::RearFogLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRearFogLightControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::UnityAPI::RearFogLightRequest,::UnityAPI::RearFogLightReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ClearanceLampControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ClearanceLampControl() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::UnityAPI::ClearanceLampRequest, ::UnityAPI::ClearanceLampReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::UnityAPI::ClearanceLampRequest, ::UnityAPI::ClearanceLampReply>* streamer) {
                       return this->StreamedClearanceLampControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ClearanceLampControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ClearanceLampControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::ClearanceLampRequest* /*request*/, ::UnityAPI::ClearanceLampReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedClearanceLampControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::UnityAPI::ClearanceLampRequest,::UnityAPI::ClearanceLampReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FrontLeftBlinkerLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_FrontLeftBlinkerLightControl() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::UnityAPI::FrontLeftBlinkerLightRequest, ::UnityAPI::FrontLeftBlinkerLightReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::UnityAPI::FrontLeftBlinkerLightRequest, ::UnityAPI::FrontLeftBlinkerLightReply>* streamer) {
                       return this->StreamedFrontLeftBlinkerLightControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_FrontLeftBlinkerLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FrontLeftBlinkerLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontLeftBlinkerLightRequest* /*request*/, ::UnityAPI::FrontLeftBlinkerLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFrontLeftBlinkerLightControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::UnityAPI::FrontLeftBlinkerLightRequest,::UnityAPI::FrontLeftBlinkerLightReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FrontRightBlinkerLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_FrontRightBlinkerLightControl() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::UnityAPI::FrontRightBlinkerLightRequest, ::UnityAPI::FrontRightBlinkerLightReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::UnityAPI::FrontRightBlinkerLightRequest, ::UnityAPI::FrontRightBlinkerLightReply>* streamer) {
                       return this->StreamedFrontRightBlinkerLightControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_FrontRightBlinkerLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FrontRightBlinkerLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontRightBlinkerLightRequest* /*request*/, ::UnityAPI::FrontRightBlinkerLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFrontRightBlinkerLightControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::UnityAPI::FrontRightBlinkerLightRequest,::UnityAPI::FrontRightBlinkerLightReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RearLeftBlinkerLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RearLeftBlinkerLightControl() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::UnityAPI::RearLeftBlinkerLightRequest, ::UnityAPI::RearLeftBlinkerLightReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::UnityAPI::RearLeftBlinkerLightRequest, ::UnityAPI::RearLeftBlinkerLightReply>* streamer) {
                       return this->StreamedRearLeftBlinkerLightControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RearLeftBlinkerLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RearLeftBlinkerLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearLeftBlinkerLightRequest* /*request*/, ::UnityAPI::RearLeftBlinkerLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRearLeftBlinkerLightControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::UnityAPI::RearLeftBlinkerLightRequest,::UnityAPI::RearLeftBlinkerLightReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RearRightBlinkerLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RearRightBlinkerLightControl() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::UnityAPI::RearRightBlinkerLightRequest, ::UnityAPI::RearRightBlinkerLightReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::UnityAPI::RearRightBlinkerLightRequest, ::UnityAPI::RearRightBlinkerLightReply>* streamer) {
                       return this->StreamedRearRightBlinkerLightControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RearRightBlinkerLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RearRightBlinkerLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearRightBlinkerLightRequest* /*request*/, ::UnityAPI::RearRightBlinkerLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRearRightBlinkerLightControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::UnityAPI::RearRightBlinkerLightRequest,::UnityAPI::RearRightBlinkerLightReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FrontWiperControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_FrontWiperControl() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::UnityAPI::FrontWiperRequest, ::UnityAPI::FrontWiperReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::UnityAPI::FrontWiperRequest, ::UnityAPI::FrontWiperReply>* streamer) {
                       return this->StreamedFrontWiperControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_FrontWiperControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FrontWiperControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontWiperRequest* /*request*/, ::UnityAPI::FrontWiperReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFrontWiperControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::UnityAPI::FrontWiperRequest,::UnityAPI::FrontWiperReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RearWiperControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RearWiperControl() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::UnityAPI::RearWiperRequest, ::UnityAPI::RearWiperReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::UnityAPI::RearWiperRequest, ::UnityAPI::RearWiperReply>* streamer) {
                       return this->StreamedRearWiperControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RearWiperControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RearWiperControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearWiperRequest* /*request*/, ::UnityAPI::RearWiperReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRearWiperControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::UnityAPI::RearWiperRequest,::UnityAPI::RearWiperReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LeftSideMirrorControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_LeftSideMirrorControl() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler<
          ::UnityAPI::LeftSideMirrorRequest, ::UnityAPI::LeftSideMirrorReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::UnityAPI::LeftSideMirrorRequest, ::UnityAPI::LeftSideMirrorReply>* streamer) {
                       return this->StreamedLeftSideMirrorControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_LeftSideMirrorControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LeftSideMirrorControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::LeftSideMirrorRequest* /*request*/, ::UnityAPI::LeftSideMirrorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLeftSideMirrorControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::UnityAPI::LeftSideMirrorRequest,::UnityAPI::LeftSideMirrorReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RightSideMirrorControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RightSideMirrorControl() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler<
          ::UnityAPI::RightSideMirrorRequest, ::UnityAPI::RightSideMirrorReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::UnityAPI::RightSideMirrorRequest, ::UnityAPI::RightSideMirrorReply>* streamer) {
                       return this->StreamedRightSideMirrorControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RightSideMirrorControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RightSideMirrorControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RightSideMirrorRequest* /*request*/, ::UnityAPI::RightSideMirrorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRightSideMirrorControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::UnityAPI::RightSideMirrorRequest,::UnityAPI::RightSideMirrorReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FrontRightDoorControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_FrontRightDoorControl() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler<
          ::UnityAPI::FrontRightDoorRequest, ::UnityAPI::FrontRightDoorReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::UnityAPI::FrontRightDoorRequest, ::UnityAPI::FrontRightDoorReply>* streamer) {
                       return this->StreamedFrontRightDoorControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_FrontRightDoorControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FrontRightDoorControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontRightDoorRequest* /*request*/, ::UnityAPI::FrontRightDoorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFrontRightDoorControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::UnityAPI::FrontRightDoorRequest,::UnityAPI::FrontRightDoorReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FrontLeftDoorControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_FrontLeftDoorControl() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler<
          ::UnityAPI::FrontLeftDoorRequest, ::UnityAPI::FrontLeftDoorReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::UnityAPI::FrontLeftDoorRequest, ::UnityAPI::FrontLeftDoorReply>* streamer) {
                       return this->StreamedFrontLeftDoorControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_FrontLeftDoorControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FrontLeftDoorControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontLeftDoorRequest* /*request*/, ::UnityAPI::FrontLeftDoorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFrontLeftDoorControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::UnityAPI::FrontLeftDoorRequest,::UnityAPI::FrontLeftDoorReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RearRightDoorControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RearRightDoorControl() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler<
          ::UnityAPI::RearRightDoorRequest, ::UnityAPI::RearRightDoorReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::UnityAPI::RearRightDoorRequest, ::UnityAPI::RearRightDoorReply>* streamer) {
                       return this->StreamedRearRightDoorControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RearRightDoorControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RearRightDoorControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearRightDoorRequest* /*request*/, ::UnityAPI::RearRightDoorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRearRightDoorControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::UnityAPI::RearRightDoorRequest,::UnityAPI::RearRightDoorReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RearLeftDoorControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RearLeftDoorControl() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::StreamedUnaryHandler<
          ::UnityAPI::RearLeftDoorRequest, ::UnityAPI::RearLeftDoorReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::UnityAPI::RearLeftDoorRequest, ::UnityAPI::RearLeftDoorReply>* streamer) {
                       return this->StreamedRearLeftDoorControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RearLeftDoorControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RearLeftDoorControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearLeftDoorRequest* /*request*/, ::UnityAPI::RearLeftDoorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRearLeftDoorControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::UnityAPI::RearLeftDoorRequest,::UnityAPI::RearLeftDoorReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_TrunkControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_TrunkControl() {
      ::grpc::Service::MarkMethodStreamed(21,
        new ::grpc::internal::StreamedUnaryHandler<
          ::UnityAPI::TrunkRequest, ::UnityAPI::TrunkReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::UnityAPI::TrunkRequest, ::UnityAPI::TrunkReply>* streamer) {
                       return this->StreamedTrunkControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_TrunkControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TrunkControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::TrunkRequest* /*request*/, ::UnityAPI::TrunkReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTrunkControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::UnityAPI::TrunkRequest,::UnityAPI::TrunkReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SunRoofControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SunRoofControl() {
      ::grpc::Service::MarkMethodStreamed(22,
        new ::grpc::internal::StreamedUnaryHandler<
          ::UnityAPI::SunRoofRequest, ::UnityAPI::SunRoofReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::UnityAPI::SunRoofRequest, ::UnityAPI::SunRoofReply>* streamer) {
                       return this->StreamedSunRoofControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SunRoofControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SunRoofControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::SunRoofRequest* /*request*/, ::UnityAPI::SunRoofReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSunRoofControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::UnityAPI::SunRoofRequest,::UnityAPI::SunRoofReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FrontRightPowerWindowsControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_FrontRightPowerWindowsControl() {
      ::grpc::Service::MarkMethodStreamed(23,
        new ::grpc::internal::StreamedUnaryHandler<
          ::UnityAPI::FrontRightPowerWindowsRequest, ::UnityAPI::FrontRightPowerWindowsReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::UnityAPI::FrontRightPowerWindowsRequest, ::UnityAPI::FrontRightPowerWindowsReply>* streamer) {
                       return this->StreamedFrontRightPowerWindowsControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_FrontRightPowerWindowsControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FrontRightPowerWindowsControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontRightPowerWindowsRequest* /*request*/, ::UnityAPI::FrontRightPowerWindowsReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFrontRightPowerWindowsControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::UnityAPI::FrontRightPowerWindowsRequest,::UnityAPI::FrontRightPowerWindowsReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FrontLeftPowerWindowsControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_FrontLeftPowerWindowsControl() {
      ::grpc::Service::MarkMethodStreamed(24,
        new ::grpc::internal::StreamedUnaryHandler<
          ::UnityAPI::FrontLeftPowerWindowsRequest, ::UnityAPI::FrontLeftPowerWindowsReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::UnityAPI::FrontLeftPowerWindowsRequest, ::UnityAPI::FrontLeftPowerWindowsReply>* streamer) {
                       return this->StreamedFrontLeftPowerWindowsControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_FrontLeftPowerWindowsControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FrontLeftPowerWindowsControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontLeftPowerWindowsRequest* /*request*/, ::UnityAPI::FrontLeftPowerWindowsReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFrontLeftPowerWindowsControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::UnityAPI::FrontLeftPowerWindowsRequest,::UnityAPI::FrontLeftPowerWindowsReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RearRightPowerWindowsControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RearRightPowerWindowsControl() {
      ::grpc::Service::MarkMethodStreamed(25,
        new ::grpc::internal::StreamedUnaryHandler<
          ::UnityAPI::RearRightPowerWindowsRequest, ::UnityAPI::RearRightPowerWindowsReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::UnityAPI::RearRightPowerWindowsRequest, ::UnityAPI::RearRightPowerWindowsReply>* streamer) {
                       return this->StreamedRearRightPowerWindowsControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RearRightPowerWindowsControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RearRightPowerWindowsControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearRightPowerWindowsRequest* /*request*/, ::UnityAPI::RearRightPowerWindowsReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRearRightPowerWindowsControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::UnityAPI::RearRightPowerWindowsRequest,::UnityAPI::RearRightPowerWindowsReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RearLeftPowerWindowsControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RearLeftPowerWindowsControl() {
      ::grpc::Service::MarkMethodStreamed(26,
        new ::grpc::internal::StreamedUnaryHandler<
          ::UnityAPI::RearLeftPowerWindowsRequest, ::UnityAPI::RearLeftPowerWindowsReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::UnityAPI::RearLeftPowerWindowsRequest, ::UnityAPI::RearLeftPowerWindowsReply>* streamer) {
                       return this->StreamedRearLeftPowerWindowsControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RearLeftPowerWindowsControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RearLeftPowerWindowsControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearLeftPowerWindowsRequest* /*request*/, ::UnityAPI::RearLeftPowerWindowsReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRearLeftPowerWindowsControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::UnityAPI::RearLeftPowerWindowsRequest,::UnityAPI::RearLeftPowerWindowsReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SideMirrorSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SideMirrorSwitchControl() {
      ::grpc::Service::MarkMethodStreamed(27,
        new ::grpc::internal::StreamedUnaryHandler<
          ::UnityAPI::SideMirrorSwitchRequest, ::UnityAPI::SideMirrorSwitchReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::UnityAPI::SideMirrorSwitchRequest, ::UnityAPI::SideMirrorSwitchReply>* streamer) {
                       return this->StreamedSideMirrorSwitchControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SideMirrorSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SideMirrorSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::SideMirrorSwitchRequest* /*request*/, ::UnityAPI::SideMirrorSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSideMirrorSwitchControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::UnityAPI::SideMirrorSwitchRequest,::UnityAPI::SideMirrorSwitchReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_InstrumentLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_InstrumentLightControl() {
      ::grpc::Service::MarkMethodStreamed(28,
        new ::grpc::internal::StreamedUnaryHandler<
          ::UnityAPI::InstrumentLightRequest, ::UnityAPI::InstrumentLightReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::UnityAPI::InstrumentLightRequest, ::UnityAPI::InstrumentLightReply>* streamer) {
                       return this->StreamedInstrumentLightControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_InstrumentLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status InstrumentLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::InstrumentLightRequest* /*request*/, ::UnityAPI::InstrumentLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedInstrumentLightControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::UnityAPI::InstrumentLightRequest,::UnityAPI::InstrumentLightReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PassgenerRoomDomeLightControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PassgenerRoomDomeLightControl() {
      ::grpc::Service::MarkMethodStreamed(29,
        new ::grpc::internal::StreamedUnaryHandler<
          ::UnityAPI::PassgenerRoomDomeLightRequest, ::UnityAPI::PassgenerRoomDomeLightReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::UnityAPI::PassgenerRoomDomeLightRequest, ::UnityAPI::PassgenerRoomDomeLightReply>* streamer) {
                       return this->StreamedPassgenerRoomDomeLightControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PassgenerRoomDomeLightControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PassgenerRoomDomeLightControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::PassgenerRoomDomeLightRequest* /*request*/, ::UnityAPI::PassgenerRoomDomeLightReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPassgenerRoomDomeLightControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::UnityAPI::PassgenerRoomDomeLightRequest,::UnityAPI::PassgenerRoomDomeLightReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ReadingLightDriverSideControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ReadingLightDriverSideControl() {
      ::grpc::Service::MarkMethodStreamed(30,
        new ::grpc::internal::StreamedUnaryHandler<
          ::UnityAPI::ReadingLightDriverSideRequest, ::UnityAPI::ReadingLightDriverSideReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::UnityAPI::ReadingLightDriverSideRequest, ::UnityAPI::ReadingLightDriverSideReply>* streamer) {
                       return this->StreamedReadingLightDriverSideControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ReadingLightDriverSideControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ReadingLightDriverSideControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::ReadingLightDriverSideRequest* /*request*/, ::UnityAPI::ReadingLightDriverSideReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedReadingLightDriverSideControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::UnityAPI::ReadingLightDriverSideRequest,::UnityAPI::ReadingLightDriverSideReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ReadingLightPassgenerSideControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ReadingLightPassgenerSideControl() {
      ::grpc::Service::MarkMethodStreamed(31,
        new ::grpc::internal::StreamedUnaryHandler<
          ::UnityAPI::ReadingLightPassgenerSideRequest, ::UnityAPI::ReadingLightPassgenerSideReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::UnityAPI::ReadingLightPassgenerSideRequest, ::UnityAPI::ReadingLightPassgenerSideReply>* streamer) {
                       return this->StreamedReadingLightPassgenerSideControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ReadingLightPassgenerSideControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ReadingLightPassgenerSideControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::ReadingLightPassgenerSideRequest* /*request*/, ::UnityAPI::ReadingLightPassgenerSideReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedReadingLightPassgenerSideControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::UnityAPI::ReadingLightPassgenerSideRequest,::UnityAPI::ReadingLightPassgenerSideReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FrontRightPowerWindowsSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_FrontRightPowerWindowsSwitchControl() {
      ::grpc::Service::MarkMethodStreamed(32,
        new ::grpc::internal::StreamedUnaryHandler<
          ::UnityAPI::FrontRightPowerWindowsSwitchRequest, ::UnityAPI::FrontRightPowerWindowsSwitchReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::UnityAPI::FrontRightPowerWindowsSwitchRequest, ::UnityAPI::FrontRightPowerWindowsSwitchReply>* streamer) {
                       return this->StreamedFrontRightPowerWindowsSwitchControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_FrontRightPowerWindowsSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FrontRightPowerWindowsSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontRightPowerWindowsSwitchRequest* /*request*/, ::UnityAPI::FrontRightPowerWindowsSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFrontRightPowerWindowsSwitchControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::UnityAPI::FrontRightPowerWindowsSwitchRequest,::UnityAPI::FrontRightPowerWindowsSwitchReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FrontLeftPowerWindowsSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_FrontLeftPowerWindowsSwitchControl() {
      ::grpc::Service::MarkMethodStreamed(33,
        new ::grpc::internal::StreamedUnaryHandler<
          ::UnityAPI::FrontLeftPowerWindowsSwitchRequest, ::UnityAPI::FrontLeftPowerWindowsSwitchReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::UnityAPI::FrontLeftPowerWindowsSwitchRequest, ::UnityAPI::FrontLeftPowerWindowsSwitchReply>* streamer) {
                       return this->StreamedFrontLeftPowerWindowsSwitchControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_FrontLeftPowerWindowsSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FrontLeftPowerWindowsSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontLeftPowerWindowsSwitchRequest* /*request*/, ::UnityAPI::FrontLeftPowerWindowsSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFrontLeftPowerWindowsSwitchControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::UnityAPI::FrontLeftPowerWindowsSwitchRequest,::UnityAPI::FrontLeftPowerWindowsSwitchReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RearRightPowerWindowsSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RearRightPowerWindowsSwitchControl() {
      ::grpc::Service::MarkMethodStreamed(34,
        new ::grpc::internal::StreamedUnaryHandler<
          ::UnityAPI::RearRightPowerWindowsSwitchRequest, ::UnityAPI::RearRightPowerWindowsSwitchReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::UnityAPI::RearRightPowerWindowsSwitchRequest, ::UnityAPI::RearRightPowerWindowsSwitchReply>* streamer) {
                       return this->StreamedRearRightPowerWindowsSwitchControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RearRightPowerWindowsSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RearRightPowerWindowsSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearRightPowerWindowsSwitchRequest* /*request*/, ::UnityAPI::RearRightPowerWindowsSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRearRightPowerWindowsSwitchControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::UnityAPI::RearRightPowerWindowsSwitchRequest,::UnityAPI::RearRightPowerWindowsSwitchReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RearLeftPowerWindowsSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RearLeftPowerWindowsSwitchControl() {
      ::grpc::Service::MarkMethodStreamed(35,
        new ::grpc::internal::StreamedUnaryHandler<
          ::UnityAPI::RearLeftPowerWindowsSwitchRequest, ::UnityAPI::RearLeftPowerWindowsSwitchReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::UnityAPI::RearLeftPowerWindowsSwitchRequest, ::UnityAPI::RearLeftPowerWindowsSwitchReply>* streamer) {
                       return this->StreamedRearLeftPowerWindowsSwitchControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RearLeftPowerWindowsSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RearLeftPowerWindowsSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearLeftPowerWindowsSwitchRequest* /*request*/, ::UnityAPI::RearLeftPowerWindowsSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRearLeftPowerWindowsSwitchControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::UnityAPI::RearLeftPowerWindowsSwitchRequest,::UnityAPI::RearLeftPowerWindowsSwitchReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_HornControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_HornControl() {
      ::grpc::Service::MarkMethodStreamed(36,
        new ::grpc::internal::StreamedUnaryHandler<
          ::UnityAPI::HornRequest, ::UnityAPI::HornReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::UnityAPI::HornRequest, ::UnityAPI::HornReply>* streamer) {
                       return this->StreamedHornControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_HornControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status HornControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::HornRequest* /*request*/, ::UnityAPI::HornReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedHornControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::UnityAPI::HornRequest,::UnityAPI::HornReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_BuzzerControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_BuzzerControl() {
      ::grpc::Service::MarkMethodStreamed(37,
        new ::grpc::internal::StreamedUnaryHandler<
          ::UnityAPI::BuzzerRequest, ::UnityAPI::BuzzerReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::UnityAPI::BuzzerRequest, ::UnityAPI::BuzzerReply>* streamer) {
                       return this->StreamedBuzzerControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_BuzzerControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status BuzzerControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::BuzzerRequest* /*request*/, ::UnityAPI::BuzzerReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedBuzzerControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::UnityAPI::BuzzerRequest,::UnityAPI::BuzzerReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AirConditionerControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AirConditionerControl() {
      ::grpc::Service::MarkMethodStreamed(38,
        new ::grpc::internal::StreamedUnaryHandler<
          ::UnityAPI::AirConditionerRequest, ::UnityAPI::AirConditionerReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::UnityAPI::AirConditionerRequest, ::UnityAPI::AirConditionerReply>* streamer) {
                       return this->StreamedAirConditionerControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AirConditionerControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AirConditionerControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::AirConditionerRequest* /*request*/, ::UnityAPI::AirConditionerReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAirConditionerControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::UnityAPI::AirConditionerRequest,::UnityAPI::AirConditionerReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AirConditionerTemperatureControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AirConditionerTemperatureControl() {
      ::grpc::Service::MarkMethodStreamed(39,
        new ::grpc::internal::StreamedUnaryHandler<
          ::UnityAPI::AirCondTemperatureRequest, ::UnityAPI::AirCondTemperatureReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::UnityAPI::AirCondTemperatureRequest, ::UnityAPI::AirCondTemperatureReply>* streamer) {
                       return this->StreamedAirConditionerTemperatureControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AirConditionerTemperatureControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AirConditionerTemperatureControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::AirCondTemperatureRequest* /*request*/, ::UnityAPI::AirCondTemperatureReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAirConditionerTemperatureControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::UnityAPI::AirCondTemperatureRequest,::UnityAPI::AirCondTemperatureReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AirConditionerFanSpeedControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AirConditionerFanSpeedControl() {
      ::grpc::Service::MarkMethodStreamed(40,
        new ::grpc::internal::StreamedUnaryHandler<
          ::UnityAPI::AirConditionerFanSpeedRequest, ::UnityAPI::AirConditionerFanSpeedReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::UnityAPI::AirConditionerFanSpeedRequest, ::UnityAPI::AirConditionerFanSpeedReply>* streamer) {
                       return this->StreamedAirConditionerFanSpeedControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AirConditionerFanSpeedControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AirConditionerFanSpeedControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::AirConditionerFanSpeedRequest* /*request*/, ::UnityAPI::AirConditionerFanSpeedReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAirConditionerFanSpeedControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::UnityAPI::AirConditionerFanSpeedRequest,::UnityAPI::AirConditionerFanSpeedReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_HandlingControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_HandlingControl() {
      ::grpc::Service::MarkMethodStreamed(41,
        new ::grpc::internal::StreamedUnaryHandler<
          ::UnityAPI::HandlingRequest, ::UnityAPI::HandlingReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::UnityAPI::HandlingRequest, ::UnityAPI::HandlingReply>* streamer) {
                       return this->StreamedHandlingControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_HandlingControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status HandlingControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::HandlingRequest* /*request*/, ::UnityAPI::HandlingReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedHandlingControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::UnityAPI::HandlingRequest,::UnityAPI::HandlingReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CentralDoorLockSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CentralDoorLockSwitchControl() {
      ::grpc::Service::MarkMethodStreamed(42,
        new ::grpc::internal::StreamedUnaryHandler<
          ::UnityAPI::CentralDoorLockSwitchRequest, ::UnityAPI::CentralDoorLockSwitchReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::UnityAPI::CentralDoorLockSwitchRequest, ::UnityAPI::CentralDoorLockSwitchReply>* streamer) {
                       return this->StreamedCentralDoorLockSwitchControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CentralDoorLockSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CentralDoorLockSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::CentralDoorLockSwitchRequest* /*request*/, ::UnityAPI::CentralDoorLockSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCentralDoorLockSwitchControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::UnityAPI::CentralDoorLockSwitchRequest,::UnityAPI::CentralDoorLockSwitchReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FrontRightDoorLockSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_FrontRightDoorLockSwitchControl() {
      ::grpc::Service::MarkMethodStreamed(43,
        new ::grpc::internal::StreamedUnaryHandler<
          ::UnityAPI::FrontRightDoorLockSwitchRequest, ::UnityAPI::FrontRightDoorLockSwitchReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::UnityAPI::FrontRightDoorLockSwitchRequest, ::UnityAPI::FrontRightDoorLockSwitchReply>* streamer) {
                       return this->StreamedFrontRightDoorLockSwitchControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_FrontRightDoorLockSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FrontRightDoorLockSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontRightDoorLockSwitchRequest* /*request*/, ::UnityAPI::FrontRightDoorLockSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFrontRightDoorLockSwitchControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::UnityAPI::FrontRightDoorLockSwitchRequest,::UnityAPI::FrontRightDoorLockSwitchReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FrontLeftDoorLockSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_FrontLeftDoorLockSwitchControl() {
      ::grpc::Service::MarkMethodStreamed(44,
        new ::grpc::internal::StreamedUnaryHandler<
          ::UnityAPI::FrontLeftDoorLockSwitchRequest, ::UnityAPI::FrontLeftDoorLockSwitchReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::UnityAPI::FrontLeftDoorLockSwitchRequest, ::UnityAPI::FrontLeftDoorLockSwitchReply>* streamer) {
                       return this->StreamedFrontLeftDoorLockSwitchControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_FrontLeftDoorLockSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FrontLeftDoorLockSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::FrontLeftDoorLockSwitchRequest* /*request*/, ::UnityAPI::FrontLeftDoorLockSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFrontLeftDoorLockSwitchControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::UnityAPI::FrontLeftDoorLockSwitchRequest,::UnityAPI::FrontLeftDoorLockSwitchReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RearRightDoorLockSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RearRightDoorLockSwitchControl() {
      ::grpc::Service::MarkMethodStreamed(45,
        new ::grpc::internal::StreamedUnaryHandler<
          ::UnityAPI::RearRightDoorLockSwitchRequest, ::UnityAPI::RearRightDoorLockSwitchReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::UnityAPI::RearRightDoorLockSwitchRequest, ::UnityAPI::RearRightDoorLockSwitchReply>* streamer) {
                       return this->StreamedRearRightDoorLockSwitchControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RearRightDoorLockSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RearRightDoorLockSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearRightDoorLockSwitchRequest* /*request*/, ::UnityAPI::RearRightDoorLockSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRearRightDoorLockSwitchControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::UnityAPI::RearRightDoorLockSwitchRequest,::UnityAPI::RearRightDoorLockSwitchReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RearLeftDoorLockSwitchControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RearLeftDoorLockSwitchControl() {
      ::grpc::Service::MarkMethodStreamed(46,
        new ::grpc::internal::StreamedUnaryHandler<
          ::UnityAPI::RearLeftDoorLockSwitchRequest, ::UnityAPI::RearLeftDoorLockSwitchReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::UnityAPI::RearLeftDoorLockSwitchRequest, ::UnityAPI::RearLeftDoorLockSwitchReply>* streamer) {
                       return this->StreamedRearLeftDoorLockSwitchControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RearLeftDoorLockSwitchControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RearLeftDoorLockSwitchControl(::grpc::ServerContext* /*context*/, const ::UnityAPI::RearLeftDoorLockSwitchRequest* /*request*/, ::UnityAPI::RearLeftDoorLockSwitchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRearLeftDoorLockSwitchControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::UnityAPI::RearLeftDoorLockSwitchRequest,::UnityAPI::RearLeftDoorLockSwitchReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_database : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_database() {
      ::grpc::Service::MarkMethodStreamed(47,
        new ::grpc::internal::StreamedUnaryHandler<
          ::UnityAPI::getDBRequest, ::UnityAPI::getDBReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::UnityAPI::getDBRequest, ::UnityAPI::getDBReply>* streamer) {
                       return this->Streamedget_database(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_database() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_database(::grpc::ServerContext* /*context*/, const ::UnityAPI::getDBRequest* /*request*/, ::UnityAPI::getDBReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_database(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::UnityAPI::getDBRequest,::UnityAPI::getDBReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_send_update_database : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_send_update_database() {
      ::grpc::Service::MarkMethodStreamed(48,
        new ::grpc::internal::StreamedUnaryHandler<
          ::UnityAPI::setDBRequest, ::UnityAPI::setDBReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::UnityAPI::setDBRequest, ::UnityAPI::setDBReply>* streamer) {
                       return this->Streamedsend_update_database(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_send_update_database() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status send_update_database(::grpc::ServerContext* /*context*/, const ::UnityAPI::setDBRequest* /*request*/, ::UnityAPI::setDBReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedsend_update_database(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::UnityAPI::setDBRequest,::UnityAPI::setDBReply>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_FrontLowLightControl<WithStreamedUnaryMethod_FrontHighLightControl<WithStreamedUnaryMethod_RearLightControl<WithStreamedUnaryMethod_FrontDaytimeLightControl<WithStreamedUnaryMethod_BrakeLightControl<WithStreamedUnaryMethod_ReverseLightControl<WithStreamedUnaryMethod_FrontFogLightControl<WithStreamedUnaryMethod_RearFogLightControl<WithStreamedUnaryMethod_ClearanceLampControl<WithStreamedUnaryMethod_FrontLeftBlinkerLightControl<WithStreamedUnaryMethod_FrontRightBlinkerLightControl<WithStreamedUnaryMethod_RearLeftBlinkerLightControl<WithStreamedUnaryMethod_RearRightBlinkerLightControl<WithStreamedUnaryMethod_FrontWiperControl<WithStreamedUnaryMethod_RearWiperControl<WithStreamedUnaryMethod_LeftSideMirrorControl<WithStreamedUnaryMethod_RightSideMirrorControl<WithStreamedUnaryMethod_FrontRightDoorControl<WithStreamedUnaryMethod_FrontLeftDoorControl<WithStreamedUnaryMethod_RearRightDoorControl<WithStreamedUnaryMethod_RearLeftDoorControl<WithStreamedUnaryMethod_TrunkControl<WithStreamedUnaryMethod_SunRoofControl<WithStreamedUnaryMethod_FrontRightPowerWindowsControl<WithStreamedUnaryMethod_FrontLeftPowerWindowsControl<WithStreamedUnaryMethod_RearRightPowerWindowsControl<WithStreamedUnaryMethod_RearLeftPowerWindowsControl<WithStreamedUnaryMethod_SideMirrorSwitchControl<WithStreamedUnaryMethod_InstrumentLightControl<WithStreamedUnaryMethod_PassgenerRoomDomeLightControl<WithStreamedUnaryMethod_ReadingLightDriverSideControl<WithStreamedUnaryMethod_ReadingLightPassgenerSideControl<WithStreamedUnaryMethod_FrontRightPowerWindowsSwitchControl<WithStreamedUnaryMethod_FrontLeftPowerWindowsSwitchControl<WithStreamedUnaryMethod_RearRightPowerWindowsSwitchControl<WithStreamedUnaryMethod_RearLeftPowerWindowsSwitchControl<WithStreamedUnaryMethod_HornControl<WithStreamedUnaryMethod_BuzzerControl<WithStreamedUnaryMethod_AirConditionerControl<WithStreamedUnaryMethod_AirConditionerTemperatureControl<WithStreamedUnaryMethod_AirConditionerFanSpeedControl<WithStreamedUnaryMethod_HandlingControl<WithStreamedUnaryMethod_CentralDoorLockSwitchControl<WithStreamedUnaryMethod_FrontRightDoorLockSwitchControl<WithStreamedUnaryMethod_FrontLeftDoorLockSwitchControl<WithStreamedUnaryMethod_RearRightDoorLockSwitchControl<WithStreamedUnaryMethod_RearLeftDoorLockSwitchControl<WithStreamedUnaryMethod_get_database<WithStreamedUnaryMethod_send_update_database<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_FrontLowLightControl<WithStreamedUnaryMethod_FrontHighLightControl<WithStreamedUnaryMethod_RearLightControl<WithStreamedUnaryMethod_FrontDaytimeLightControl<WithStreamedUnaryMethod_BrakeLightControl<WithStreamedUnaryMethod_ReverseLightControl<WithStreamedUnaryMethod_FrontFogLightControl<WithStreamedUnaryMethod_RearFogLightControl<WithStreamedUnaryMethod_ClearanceLampControl<WithStreamedUnaryMethod_FrontLeftBlinkerLightControl<WithStreamedUnaryMethod_FrontRightBlinkerLightControl<WithStreamedUnaryMethod_RearLeftBlinkerLightControl<WithStreamedUnaryMethod_RearRightBlinkerLightControl<WithStreamedUnaryMethod_FrontWiperControl<WithStreamedUnaryMethod_RearWiperControl<WithStreamedUnaryMethod_LeftSideMirrorControl<WithStreamedUnaryMethod_RightSideMirrorControl<WithStreamedUnaryMethod_FrontRightDoorControl<WithStreamedUnaryMethod_FrontLeftDoorControl<WithStreamedUnaryMethod_RearRightDoorControl<WithStreamedUnaryMethod_RearLeftDoorControl<WithStreamedUnaryMethod_TrunkControl<WithStreamedUnaryMethod_SunRoofControl<WithStreamedUnaryMethod_FrontRightPowerWindowsControl<WithStreamedUnaryMethod_FrontLeftPowerWindowsControl<WithStreamedUnaryMethod_RearRightPowerWindowsControl<WithStreamedUnaryMethod_RearLeftPowerWindowsControl<WithStreamedUnaryMethod_SideMirrorSwitchControl<WithStreamedUnaryMethod_InstrumentLightControl<WithStreamedUnaryMethod_PassgenerRoomDomeLightControl<WithStreamedUnaryMethod_ReadingLightDriverSideControl<WithStreamedUnaryMethod_ReadingLightPassgenerSideControl<WithStreamedUnaryMethod_FrontRightPowerWindowsSwitchControl<WithStreamedUnaryMethod_FrontLeftPowerWindowsSwitchControl<WithStreamedUnaryMethod_RearRightPowerWindowsSwitchControl<WithStreamedUnaryMethod_RearLeftPowerWindowsSwitchControl<WithStreamedUnaryMethod_HornControl<WithStreamedUnaryMethod_BuzzerControl<WithStreamedUnaryMethod_AirConditionerControl<WithStreamedUnaryMethod_AirConditionerTemperatureControl<WithStreamedUnaryMethod_AirConditionerFanSpeedControl<WithStreamedUnaryMethod_HandlingControl<WithStreamedUnaryMethod_CentralDoorLockSwitchControl<WithStreamedUnaryMethod_FrontRightDoorLockSwitchControl<WithStreamedUnaryMethod_FrontLeftDoorLockSwitchControl<WithStreamedUnaryMethod_RearRightDoorLockSwitchControl<WithStreamedUnaryMethod_RearLeftDoorLockSwitchControl<WithStreamedUnaryMethod_get_database<WithStreamedUnaryMethod_send_update_database<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace UnityAPI


#endif  // GRPC_UnityAPI_2eproto__INCLUDED
